/*! jQuery v2.2.3 | (c) jQuery Foundation | jquery.org/license */
!function(n,t){"object"==typeof module&&"object"==typeof module.exports?module.exports=n.document?t(n,!0):function(n){if(!n.document)throw new Error("jQuery requires a window with a document");return t(n)}:t(n)}("undefined"!=typeof window?window:this,function(n,t){function ii(n){var t=!!n&&"length"in n&&n.length,r=i.type(n);return"function"===r||i.isWindow(n)?!1:"array"===r||0===t||"number"==typeof t&&t>0&&t-1 in n}function ri(n,t,r){if(i.isFunction(t))return i.grep(n,function(n,i){return!!t.call(n,i,n)!==r});if(t.nodeType)return i.grep(n,function(n){return n===t!==r});if("string"==typeof t){if(bf.test(t))return i.filter(t,n,r);t=i.filter(t,n)}return i.grep(n,function(n){return lt.call(t,n)>-1!==r})}function hr(n,t){while((n=n[t])&&1!==n.nodeType);return n}function kf(n){var t={};return i.each(n.match(h)||[],function(n,i){t[i]=!0}),t}function yt(){u.removeEventListener("DOMContentLoaded",yt);n.removeEventListener("load",yt);i.ready()}function et(){this.expando=i.expando+et.uid++}function lr(n,t,r){var u;if(void 0===r&&1===n.nodeType)if(u="data-"+t.replace(cr,"-$&").toLowerCase(),r=n.getAttribute(u),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:df.test(r)?i.parseJSON(r):r}catch(f){}e.set(n,t,r)}else r=void 0;return r}function vr(n,t,r,u){var h,e=1,l=20,c=u?function(){return u.cur()}:function(){return i.css(n,t,"")},s=c(),o=r&&r[3]||(i.cssNumber[t]?"":"px"),f=(i.cssNumber[t]||"px"!==o&&+s)&&ot.exec(i.css(n,t));if(f&&f[3]!==o){o=o||f[3];r=r||[];f=+s||1;do e=e||".5",f/=e,i.style(n,t,f+o);while(e!==(e=c()/s)&&1!==e&&--l)}return r&&(f=+f||+s||0,h=r[1]?f+(r[1]+1)*r[2]:+r[2],u&&(u.unit=o,u.start=f,u.end=h)),h}function o(n,t){var r="undefined"!=typeof n.getElementsByTagName?n.getElementsByTagName(t||"*"):"undefined"!=typeof n.querySelectorAll?n.querySelectorAll(t||"*"):[];return void 0===t||t&&i.nodeName(n,t)?i.merge([n],r):r}function ui(n,t){for(var i=0,u=n.length;u>i;i++)r.set(n[i],"globalEval",!t||r.get(t[i],"globalEval"))}function kr(n,t,r,u,f){for(var e,s,p,a,w,v,h=t.createDocumentFragment(),y=[],l=0,b=n.length;b>l;l++)if(e=n[l],e||0===e)if("object"===i.type(e))i.merge(y,e.nodeType?[e]:e);else if(br.test(e)){for(s=s||h.appendChild(t.createElement("div")),p=(pr.exec(e)||["",""])[1].toLowerCase(),a=c[p]||c._default,s.innerHTML=a[1]+i.htmlPrefilter(e)+a[2],v=a[0];v--;)s=s.lastChild;i.merge(y,s.childNodes);s=h.firstChild;s.textContent=""}else y.push(t.createTextNode(e));for(h.textContent="",l=0;e=y[l++];)if(u&&i.inArray(e,u)>-1)f&&f.push(e);else if(w=i.contains(e.ownerDocument,e),s=o(h.appendChild(e),"script"),w&&ui(s),r)for(v=0;e=s[v++];)wr.test(e.type||"")&&r.push(e);return h}function pt(){return!0}function nt(){return!1}function gr(){try{return u.activeElement}catch(n){}}function fi(n,t,r,u,f,e){var o,s;if("object"==typeof t){"string"!=typeof r&&(u=u||r,r=void 0);for(s in t)fi(n,s,r,u,t[s],e);return n}if(null==u&&null==f?(f=r,u=r=void 0):null==f&&("string"==typeof r?(f=u,u=void 0):(f=u,u=r,r=void 0)),f===!1)f=nt;else if(!f)return n;return 1===e&&(o=f,f=function(n){return i().off(n),o.apply(this,arguments)},f.guid=o.guid||(o.guid=i.guid++)),n.each(function(){i.event.add(this,t,f,u,r)})}function nu(n,t){return i.nodeName(n,"table")&&i.nodeName(11!==t.nodeType?t:t.firstChild,"tr")?n.getElementsByTagName("tbody")[0]||n.appendChild(n.ownerDocument.createElement("tbody")):n}function ee(n){return n.type=(null!==n.getAttribute("type"))+"/"+n.type,n}function oe(n){var t=ue.exec(n.type);return t?n.type=t[1]:n.removeAttribute("type"),n}function tu(n,t){var u,c,f,s,h,l,a,o;if(1===t.nodeType){if(r.hasData(n)&&(s=r.access(n),h=r.set(t,s),o=s.events)){delete h.handle;h.events={};for(f in o)for(u=0,c=o[f].length;c>u;u++)i.event.add(t,f,o[f][u])}e.hasData(n)&&(l=e.access(n),a=i.extend({},l),e.set(t,a))}}function se(n,t){var i=t.nodeName.toLowerCase();"input"===i&&yr.test(n.type)?t.checked=n.checked:"input"!==i&&"textarea"!==i||(t.defaultValue=n.defaultValue)}function b(n,t,u,e){t=gi.apply([],t);var l,p,c,a,s,w,h=0,v=n.length,d=v-1,y=t[0],k=i.isFunction(y);if(k||v>1&&"string"==typeof y&&!f.checkClone&&re.test(y))return n.each(function(i){var r=n.eq(i);k&&(t[0]=y.call(this,i,r.html()));b(r,t,u,e)});if(v&&(l=kr(t,n[0].ownerDocument,!1,n,e),p=l.firstChild,1===l.childNodes.length&&(l=p),p||e)){for(c=i.map(o(l,"script"),ee),a=c.length;v>h;h++)s=l,h!==d&&(s=i.clone(s,!0,!0),a&&i.merge(c,o(s,"script"))),u.call(n[h],s,h);if(a)for(w=c[c.length-1].ownerDocument,i.map(c,oe),h=0;a>h;h++)s=c[h],wr.test(s.type||"")&&!r.access(s,"globalEval")&&i.contains(w,s)&&(s.src?i._evalUrl&&i._evalUrl(s.src):i.globalEval(s.textContent.replace(fe,"")))}return n}function iu(n,t,r){for(var u,e=t?i.filter(t,n):n,f=0;null!=(u=e[f]);f++)r||1!==u.nodeType||i.cleanData(o(u)),u.parentNode&&(r&&i.contains(u.ownerDocument,u)&&ui(o(u,"script")),u.parentNode.removeChild(u));return n}function ru(n,t){var r=i(t.createElement(n)).appendTo(t.body),u=i.css(r[0],"display");return r.detach(),u}function oi(n){var r=u,t=ei[n];return t||(t=ru(n,r),"none"!==t&&t||(wt=(wt||i("<iframe frameborder='0' width='0' height='0'/>")).appendTo(r.documentElement),r=wt[0].contentDocument,r.write(),r.close(),t=ru(n,r),wt.detach()),ei[n]=t),t}function tt(n,t,r){var o,s,h,u,e=n.style;return r=r||bt(n),u=r?r.getPropertyValue(t)||r[t]:void 0,""!==u&&void 0!==u||i.contains(n.ownerDocument,n)||(u=i.style(n,t)),r&&!f.pixelMarginRight()&&si.test(u)&&uu.test(t)&&(o=e.width,s=e.minWidth,h=e.maxWidth,e.minWidth=e.maxWidth=e.width=u,u=r.width,e.width=o,e.minWidth=s,e.maxWidth=h),void 0!==u?u+"":u}function ci(n,t){return{get:function(){return n()?void delete this.get:(this.get=t).apply(this,arguments)}}}function su(n){if(n in ou)return n;for(var i=n[0].toUpperCase()+n.slice(1),t=eu.length;t--;)if(n=eu[t]+i,n in ou)return n}function hu(n,t,i){var r=ot.exec(t);return r?Math.max(0,r[2]-(i||0))+(r[3]||"px"):t}function cu(n,t,r,u,f){for(var e=r===(u?"border":"content")?4:"width"===t?1:0,o=0;4>e;e+=2)"margin"===r&&(o+=i.css(n,r+w[e],!0,f)),u?("content"===r&&(o-=i.css(n,"padding"+w[e],!0,f)),"margin"!==r&&(o-=i.css(n,"border"+w[e]+"Width",!0,f))):(o+=i.css(n,"padding"+w[e],!0,f),"padding"!==r&&(o+=i.css(n,"border"+w[e]+"Width",!0,f)));return o}function lu(t,r,e){var h=!0,o="width"===r?t.offsetWidth:t.offsetHeight,s=bt(t),c="border-box"===i.css(t,"boxSizing",!1,s);if(u.msFullscreenElement&&n.top!==n&&t.getClientRects().length&&(o=Math.round(100*t.getBoundingClientRect()[r])),0>=o||null==o){if(o=tt(t,r,s),(0>o||null==o)&&(o=t.style[r]),si.test(o))return o;h=c&&(f.boxSizingReliable()||o===t.style[r]);o=parseFloat(o)||0}return o+cu(t,r,e||(c?"border":"content"),h,s)+"px"}function au(n,t){for(var e,u,s,o=[],f=0,h=n.length;h>f;f++)u=n[f],u.style&&(o[f]=r.get(u,"olddisplay"),e=u.style.display,t?(o[f]||"none"!==e||(u.style.display=""),""===u.style.display&&st(u)&&(o[f]=r.access(u,"olddisplay",oi(u.nodeName)))):(s=st(u),"none"===e&&s||r.set(u,"olddisplay",s?e:i.css(u,"display"))));for(f=0;h>f;f++)u=n[f],u.style&&(t&&"none"!==u.style.display&&""!==u.style.display||(u.style.display=t?o[f]||"":"none"));return n}function s(n,t,i,r,u){return new s.prototype.init(n,t,i,r,u)}function pu(){return n.setTimeout(function(){it=void 0}),it=i.now()}function dt(n,t){var r,u=0,i={height:n};for(t=t?1:0;4>u;u+=2-t)r=w[u],i["margin"+r]=i["padding"+r]=n;return t&&(i.opacity=i.width=n),i}function wu(n,t,i){for(var u,f=(l.tweeners[t]||[]).concat(l.tweeners["*"]),r=0,e=f.length;e>r;r++)if(u=f[r].call(i,t,n))return u}function le(n,t,u){var f,a,p,v,o,w,h,b,l=this,y={},s=n.style,c=n.nodeType&&st(n),e=r.get(n,"fxshow");u.queue||(o=i._queueHooks(n,"fx"),null==o.unqueued&&(o.unqueued=0,w=o.empty.fire,o.empty.fire=function(){o.unqueued||w()}),o.unqueued++,l.always(function(){l.always(function(){o.unqueued--;i.queue(n,"fx").length||o.empty.fire()})}));1===n.nodeType&&("height"in t||"width"in t)&&(u.overflow=[s.overflow,s.overflowX,s.overflowY],h=i.css(n,"display"),b="none"===h?r.get(n,"olddisplay")||oi(n.nodeName):h,"inline"===b&&"none"===i.css(n,"float")&&(s.display="inline-block"));u.overflow&&(s.overflow="hidden",l.always(function(){s.overflow=u.overflow[0];s.overflowX=u.overflow[1];s.overflowY=u.overflow[2]}));for(f in t)if(a=t[f],vu.exec(a)){if(delete t[f],p=p||"toggle"===a,a===(c?"hide":"show")){if("show"!==a||!e||void 0===e[f])continue;c=!0}y[f]=e&&e[f]||i.style(n,f)}else h=void 0;if(i.isEmptyObject(y))"inline"===("none"===h?oi(n.nodeName):h)&&(s.display=h);else{e?"hidden"in e&&(c=e.hidden):e=r.access(n,"fxshow",{});p&&(e.hidden=!c);c?i(n).show():l.done(function(){i(n).hide()});l.done(function(){var t;r.remove(n,"fxshow");for(t in y)i.style(n,t,y[t])});for(f in y)v=wu(c?e[f]:0,f,l),f in e||(e[f]=v.start,c&&(v.end=v.start,v.start="width"===f||"height"===f?1:0))}}function ae(n,t){var r,f,e,u,o;for(r in n)if(f=i.camelCase(r),e=t[f],u=n[r],i.isArray(u)&&(e=u[1],u=n[r]=u[0]),r!==f&&(n[f]=u,delete n[r]),o=i.cssHooks[f],o&&"expand"in o){u=o.expand(u);delete n[f];for(r in u)r in n||(n[r]=u[r],t[r]=e)}else t[f]=e}function l(n,t,r){var e,o,s=0,a=l.prefilters.length,f=i.Deferred().always(function(){delete c.elem}),c=function(){if(o)return!1;for(var s=it||pu(),t=Math.max(0,u.startTime+u.duration-s),h=t/u.duration||0,i=1-h,r=0,e=u.tweens.length;e>r;r++)u.tweens[r].run(i);return f.notifyWith(n,[u,i,t]),1>i&&e?t:(f.resolveWith(n,[u]),!1)},u=f.promise({elem:n,props:i.extend({},t),opts:i.extend(!0,{specialEasing:{},easing:i.easing._default},r),originalProperties:t,originalOptions:r,startTime:it||pu(),duration:r.duration,tweens:[],createTween:function(t,r){var f=i.Tween(n,u.opts,t,r,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(f),f},stop:function(t){var i=0,r=t?u.tweens.length:0;if(o)return this;for(o=!0;r>i;i++)u.tweens[i].run(1);return t?(f.notifyWith(n,[u,1,0]),f.resolveWith(n,[u,t])):f.rejectWith(n,[u,t]),this}}),h=u.props;for(ae(h,u.opts.specialEasing);a>s;s++)if(e=l.prefilters[s].call(u,n,h,u.opts))return i.isFunction(e.stop)&&(i._queueHooks(u.elem,u.opts.queue).stop=i.proxy(e.stop,e)),e;return i.map(h,wu,u),i.isFunction(u.opts.start)&&u.opts.start.call(n,u),i.fx.timer(i.extend(c,{elem:n,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function k(n){return n.getAttribute&&n.getAttribute("class")||""}function ff(n){return function(t,r){"string"!=typeof t&&(r=t,t="*");var u,f=0,e=t.toLowerCase().match(h)||[];if(i.isFunction(r))while(u=e[f++])"+"===u[0]?(u=u.slice(1)||"*",(n[u]=n[u]||[]).unshift(r)):(n[u]=n[u]||[]).push(r)}}function ef(n,t,r,u){function e(s){var h;return f[s]=!0,i.each(n[s]||[],function(n,i){var s=i(t,r,u);return"string"!=typeof s||o||f[s]?o?!(h=s):void 0:(t.dataTypes.unshift(s),e(s),!1)}),h}var f={},o=n===yi;return e(t.dataTypes[0])||!f["*"]&&e("*")}function wi(n,t){var r,u,f=i.ajaxSettings.flatOptions||{};for(r in t)void 0!==t[r]&&((f[r]?n:u||(u={}))[r]=t[r]);return u&&i.extend(!0,n,u),n}function be(n,t,i){for(var e,u,f,o,s=n.contents,r=n.dataTypes;"*"===r[0];)r.shift(),void 0===e&&(e=n.mimeType||t.getResponseHeader("Content-Type"));if(e)for(u in s)if(s[u]&&s[u].test(e)){r.unshift(u);break}if(r[0]in i)f=r[0];else{for(u in i){if(!r[0]||n.converters[u+" "+r[0]]){f=u;break}o||(o=u)}f=f||o}if(f)return(f!==r[0]&&r.unshift(f),i[f])}function ke(n,t,i,r){var h,u,f,s,e,o={},c=n.dataTypes.slice();if(c[1])for(f in n.converters)o[f.toLowerCase()]=n.converters[f];for(u=c.shift();u;)if(n.responseFields[u]&&(i[n.responseFields[u]]=t),!e&&r&&n.dataFilter&&(t=n.dataFilter(t,n.dataType)),e=u,u=c.shift())if("*"===u)u=e;else if("*"!==e&&e!==u){if(f=o[e+" "+u]||o["* "+u],!f)for(h in o)if(s=h.split(" "),s[1]===u&&(f=o[e+" "+s[0]]||o["* "+s[0]])){f===!0?f=o[h]:o[h]!==!0&&(u=s[0],c.unshift(s[1]));break}if(f!==!0)if(f&&n.throws)t=f(t);else try{t=f(t)}catch(l){return{state:"parsererror",error:f?l:"No conversion from "+e+" to "+u}}}return{state:"success",data:t}}function bi(n,t,r,u){var f;if(i.isArray(t))i.each(t,function(t,i){r||ge.test(n)?u(n,i):bi(n+"["+("object"==typeof i&&null!=i?t:"")+"]",i,r,u)});else if(r||"object"!==i.type(t))u(n,t);else for(f in t)bi(n+"["+f+"]",t[f],r,u)}function hf(n){return i.isWindow(n)?n:9===n.nodeType&&n.defaultView}var y=[],u=n.document,v=y.slice,gi=y.concat,ti=y.push,lt=y.indexOf,at={},af=at.toString,ft=at.hasOwnProperty,f={},nr="2.2.3",i=function(n,t){return new i.fn.init(n,t)},vf=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,yf=/^-ms-/,pf=/-([\da-z])/gi,wf=function(n,t){return t.toUpperCase()},p,ur,fr,er,or,sr,h,vt,a,g,br,wt,ei,it,kt,vu,yu,bu,rt,ku,du,gt,gu,nf,li,sf,ut,ki,ni,di,cf,lf;i.fn=i.prototype={jquery:nr,constructor:i,selector:"",length:0,toArray:function(){return v.call(this)},get:function(n){return null!=n?0>n?this[n+this.length]:this[n]:v.call(this)},pushStack:function(n){var t=i.merge(this.constructor(),n);return t.prevObject=this,t.context=this.context,t},each:function(n){return i.each(this,n)},map:function(n){return this.pushStack(i.map(this,function(t,i){return n.call(t,i,t)}))},slice:function(){return this.pushStack(v.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(n){var i=this.length,t=+n+(0>n?i:0);return this.pushStack(t>=0&&i>t?[this[t]]:[])},end:function(){return this.prevObject||this.constructor()},push:ti,sort:y.sort,splice:y.splice};i.extend=i.fn.extend=function(){var e,f,r,t,o,s,n=arguments[0]||{},u=1,c=arguments.length,h=!1;for("boolean"==typeof n&&(h=n,n=arguments[u]||{},u++),"object"==typeof n||i.isFunction(n)||(n={}),u===c&&(n=this,u--);c>u;u++)if(null!=(e=arguments[u]))for(f in e)r=n[f],t=e[f],n!==t&&(h&&t&&(i.isPlainObject(t)||(o=i.isArray(t)))?(o?(o=!1,s=r&&i.isArray(r)?r:[]):s=r&&i.isPlainObject(r)?r:{},n[f]=i.extend(h,s,t)):void 0!==t&&(n[f]=t));return n};i.extend({expando:"jQuery"+(nr+Math.random()).replace(/\D/g,""),isReady:!0,error:function(n){throw new Error(n);},noop:function(){},isFunction:function(n){return"function"===i.type(n)},isArray:Array.isArray,isWindow:function(n){return null!=n&&n===n.window},isNumeric:function(n){var t=n&&n.toString();return!i.isArray(n)&&t-parseFloat(t)+1>=0},isPlainObject:function(n){var t;if("object"!==i.type(n)||n.nodeType||i.isWindow(n)||n.constructor&&!ft.call(n,"constructor")&&!ft.call(n.constructor.prototype||{},"isPrototypeOf"))return!1;for(t in n);return void 0===t||ft.call(n,t)},isEmptyObject:function(n){for(var t in n)return!1;return!0},type:function(n){return null==n?n+"":"object"==typeof n||"function"==typeof n?at[af.call(n)]||"object":typeof n},globalEval:function(n){var t,r=eval;n=i.trim(n);n&&(1===n.indexOf("use strict")?(t=u.createElement("script"),t.text=n,u.head.appendChild(t).parentNode.removeChild(t)):r(n))},camelCase:function(n){return n.replace(yf,"ms-").replace(pf,wf)},nodeName:function(n,t){return n.nodeName&&n.nodeName.toLowerCase()===t.toLowerCase()},each:function(n,t){var r,i=0;if(ii(n)){for(r=n.length;r>i;i++)if(t.call(n[i],i,n[i])===!1)break}else for(i in n)if(t.call(n[i],i,n[i])===!1)break;return n},trim:function(n){return null==n?"":(n+"").replace(vf,"")},makeArray:function(n,t){var r=t||[];return null!=n&&(ii(Object(n))?i.merge(r,"string"==typeof n?[n]:n):ti.call(r,n)),r},inArray:function(n,t,i){return null==t?-1:lt.call(t,n,i)},merge:function(n,t){for(var u=+t.length,i=0,r=n.length;u>i;i++)n[r++]=t[i];return n.length=r,n},grep:function(n,t,i){for(var u,f=[],r=0,e=n.length,o=!i;e>r;r++)u=!t(n[r],r),u!==o&&f.push(n[r]);return f},map:function(n,t,i){var e,u,r=0,f=[];if(ii(n))for(e=n.length;e>r;r++)u=t(n[r],r,i),null!=u&&f.push(u);else for(r in n)u=t(n[r],r,i),null!=u&&f.push(u);return gi.apply([],f)},guid:1,proxy:function(n,t){var u,f,r;return"string"==typeof t&&(u=n[t],t=n,n=u),i.isFunction(n)?(f=v.call(arguments,2),r=function(){return n.apply(t||this,f.concat(v.call(arguments)))},r.guid=n.guid=n.guid||i.guid++,r):void 0},now:Date.now,support:f});"function"==typeof Symbol&&(i.fn[Symbol.iterator]=y[Symbol.iterator]);i.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(n,t){at["[object "+t+"]"]=t.toLowerCase()});p=function(n){function u(n,t,r,u){var l,w,a,s,nt,d,y,g,p=t&&t.ownerDocument,v=t?t.nodeType:9;if(r=r||[],"string"!=typeof n||!n||1!==v&&9!==v&&11!==v)return r;if(!u&&((t?t.ownerDocument||t:c)!==i&&b(t),t=t||i,h)){if(11!==v&&(d=sr.exec(n)))if(l=d[1]){if(9===v){if(!(a=t.getElementById(l)))return r;if(a.id===l)return r.push(a),r}else if(p&&(a=p.getElementById(l))&&et(t,a)&&a.id===l)return r.push(a),r}else{if(d[2])return k.apply(r,t.getElementsByTagName(n)),r;if((l=d[3])&&f.getElementsByClassName&&t.getElementsByClassName)return k.apply(r,t.getElementsByClassName(l)),r}if(f.qsa&&!lt[n+" "]&&(!o||!o.test(n))){if(1!==v)p=t,g=n;else if("object"!==t.nodeName.toLowerCase()){for((s=t.getAttribute("id"))?s=s.replace(hr,"\\$&"):t.setAttribute("id",s=e),y=ft(n),w=y.length,nt=yi.test(s)?"#"+s:"[id='"+s+"']";w--;)y[w]=nt+" "+yt(y[w]);g=y.join(",");p=gt.test(n)&&ii(t.parentNode)||t}if(g)try{return k.apply(r,p.querySelectorAll(g)),r}catch(tt){}finally{s===e&&t.removeAttribute("id")}}}return si(n.replace(at,"$1"),t,r,u)}function ni(){function n(r,u){return i.push(r+" ")>t.cacheLength&&delete n[i.shift()],n[r+" "]=u}var i=[];return n}function l(n){return n[e]=!0,n}function a(n){var t=i.createElement("div");try{return!!n(t)}catch(r){return!1}finally{t.parentNode&&t.parentNode.removeChild(t);t=null}}function ti(n,i){for(var r=n.split("|"),u=r.length;u--;)t.attrHandle[r[u]]=i}function wi(n,t){var i=t&&n,r=i&&1===n.nodeType&&1===t.nodeType&&(~t.sourceIndex||li)-(~n.sourceIndex||li);if(r)return r;if(i)while(i=i.nextSibling)if(i===t)return-1;return n?1:-1}function cr(n){return function(t){var i=t.nodeName.toLowerCase();return"input"===i&&t.type===n}}function lr(n){return function(t){var i=t.nodeName.toLowerCase();return("input"===i||"button"===i)&&t.type===n}}function it(n){return l(function(t){return t=+t,l(function(i,r){for(var u,f=n([],i.length,t),e=f.length;e--;)i[u=f[e]]&&(i[u]=!(r[u]=i[u]))})})}function ii(n){return n&&"undefined"!=typeof n.getElementsByTagName&&n}function bi(){}function yt(n){for(var t=0,r=n.length,i="";r>t;t++)i+=n[t].value;return i}function ri(n,t,i){var r=t.dir,u=i&&"parentNode"===r,f=ki++;return t.first?function(t,i,f){while(t=t[r])if(1===t.nodeType||u)return n(t,i,f)}:function(t,i,o){var s,h,c,l=[v,f];if(o){while(t=t[r])if((1===t.nodeType||u)&&n(t,i,o))return!0}else while(t=t[r])if(1===t.nodeType||u){if(c=t[e]||(t[e]={}),h=c[t.uniqueID]||(c[t.uniqueID]={}),(s=h[r])&&s[0]===v&&s[1]===f)return l[2]=s[2];if(h[r]=l,l[2]=n(t,i,o))return!0}}}function ui(n){return n.length>1?function(t,i,r){for(var u=n.length;u--;)if(!n[u](t,i,r))return!1;return!0}:n[0]}function ar(n,t,i){for(var r=0,f=t.length;f>r;r++)u(n,t[r],i);return i}function pt(n,t,i,r,u){for(var e,o=[],f=0,s=n.length,h=null!=t;s>f;f++)(e=n[f])&&(i&&!i(e,r,u)||(o.push(e),h&&t.push(f)));return o}function fi(n,t,i,r,u,f){return r&&!r[e]&&(r=fi(r)),u&&!u[e]&&(u=fi(u,f)),l(function(f,e,o,s){var l,c,a,p=[],y=[],w=e.length,b=f||ar(t||"*",o.nodeType?[o]:o,[]),v=!n||!f&&t?b:pt(b,p,n,o,s),h=i?u||(f?n:w||r)?[]:e:v;if(i&&i(v,h,o,s),r)for(l=pt(h,y),r(l,[],o,s),c=l.length;c--;)(a=l[c])&&(h[y[c]]=!(v[y[c]]=a));if(f){if(u||n){if(u){for(l=[],c=h.length;c--;)(a=h[c])&&l.push(v[c]=a);u(null,h=[],l,s)}for(c=h.length;c--;)(a=h[c])&&(l=u?nt(f,a):p[c])>-1&&(f[l]=!(e[l]=a))}}else h=pt(h===e?h.splice(w,h.length):h),u?u(null,e,h,s):k.apply(e,h)})}function ei(n){for(var o,u,r,s=n.length,h=t.relative[n[0].type],c=h||t.relative[" "],i=h?1:0,l=ri(function(n){return n===o},c,!0),a=ri(function(n){return nt(o,n)>-1},c,!0),f=[function(n,t,i){var r=!h&&(i||t!==ht)||((o=t).nodeType?l(n,t,i):a(n,t,i));return o=null,r}];s>i;i++)if(u=t.relative[n[i].type])f=[ri(ui(f),u)];else{if(u=t.filter[n[i].type].apply(null,n[i].matches),u[e]){for(r=++i;s>r;r++)if(t.relative[n[r].type])break;return fi(i>1&&ui(f),i>1&&yt(n.slice(0,i-1).concat({value:" "===n[i-2].type?"*":""})).replace(at,"$1"),u,r>i&&ei(n.slice(i,r)),s>r&&ei(n=n.slice(r)),s>r&&yt(n))}f.push(u)}return ui(f)}function vr(n,r){var f=r.length>0,e=n.length>0,o=function(o,s,c,l,a){var y,nt,d,g=0,p="0",tt=o&&[],w=[],it=ht,rt=o||e&&t.find.TAG("*",a),ut=v+=null==it?1:Math.random()||.1,ft=rt.length;for(a&&(ht=s===i||s||a);p!==ft&&null!=(y=rt[p]);p++){if(e&&y){for(nt=0,s||y.ownerDocument===i||(b(y),c=!h);d=n[nt++];)if(d(y,s||i,c)){l.push(y);break}a&&(v=ut)}f&&((y=!d&&y)&&g--,o&&tt.push(y))}if(g+=p,f&&p!==g){for(nt=0;d=r[nt++];)d(tt,w,s,c);if(o){if(g>0)while(p--)tt[p]||w[p]||(w[p]=gi.call(l));w=pt(w)}k.apply(l,w);a&&!o&&w.length>0&&g+r.length>1&&u.uniqueSort(l)}return a&&(v=ut,ht=it),tt};return f?l(o):o}var rt,f,t,st,oi,ft,wt,si,ht,w,ut,b,i,s,h,o,d,ct,et,e="sizzle"+1*new Date,c=n.document,v=0,ki=0,hi=ni(),ci=ni(),lt=ni(),bt=function(n,t){return n===t&&(ut=!0),0},li=-2147483648,di={}.hasOwnProperty,g=[],gi=g.pop,nr=g.push,k=g.push,ai=g.slice,nt=function(n,t){for(var i=0,r=n.length;r>i;i++)if(n[i]===t)return i;return-1},kt="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",r="[\\x20\\t\\r\\n\\f]",tt="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",vi="\\["+r+"*("+tt+")(?:"+r+"*([*^$|!~]?=)"+r+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+tt+"))|)"+r+"*\\]",dt=":("+tt+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+vi+")*)|.*)\\)|)",tr=new RegExp(r+"+","g"),at=new RegExp("^"+r+"+|((?:^|[^\\\\])(?:\\\\.)*)"+r+"+$","g"),ir=new RegExp("^"+r+"*,"+r+"*"),rr=new RegExp("^"+r+"*([>+~]|"+r+")"+r+"*"),ur=new RegExp("="+r+"*([^\\]'\"]*?)"+r+"*\\]","g"),fr=new RegExp(dt),yi=new RegExp("^"+tt+"$"),vt={ID:new RegExp("^#("+tt+")"),CLASS:new RegExp("^\\.("+tt+")"),TAG:new RegExp("^("+tt+"|[*])"),ATTR:new RegExp("^"+vi),PSEUDO:new RegExp("^"+dt),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+r+"*(even|odd|(([+-]|)(\\d*)n|)"+r+"*(?:([+-]|)"+r+"*(\\d+)|))"+r+"*\\)|)","i"),bool:new RegExp("^(?:"+kt+")$","i"),needsContext:new RegExp("^"+r+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+r+"*((?:-\\d)?\\d*)"+r+"*\\)|)(?=[^-]|$)","i")},er=/^(?:input|select|textarea|button)$/i,or=/^h\d$/i,ot=/^[^{]+\{\s*\[native \w/,sr=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,gt=/[+~]/,hr=/'|\\/g,y=new RegExp("\\\\([\\da-f]{1,6}"+r+"?|("+r+")|.)","ig"),p=function(n,t,i){var r="0x"+t-65536;return r!==r||i?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},pi=function(){b()};try{k.apply(g=ai.call(c.childNodes),c.childNodes);g[c.childNodes.length].nodeType}catch(yr){k={apply:g.length?function(n,t){nr.apply(n,ai.call(t))}:function(n,t){for(var i=n.length,r=0;n[i++]=t[r++];);n.length=i-1}}}f=u.support={};oi=u.isXML=function(n){var t=n&&(n.ownerDocument||n).documentElement;return t?"HTML"!==t.nodeName:!1};b=u.setDocument=function(n){var v,u,l=n?n.ownerDocument||n:c;return l!==i&&9===l.nodeType&&l.documentElement?(i=l,s=i.documentElement,h=!oi(i),(u=i.defaultView)&&u.top!==u&&(u.addEventListener?u.addEventListener("unload",pi,!1):u.attachEvent&&u.attachEvent("onunload",pi)),f.attributes=a(function(n){return n.className="i",!n.getAttribute("className")}),f.getElementsByTagName=a(function(n){return n.appendChild(i.createComment("")),!n.getElementsByTagName("*").length}),f.getElementsByClassName=ot.test(i.getElementsByClassName),f.getById=a(function(n){return s.appendChild(n).id=e,!i.getElementsByName||!i.getElementsByName(e).length}),f.getById?(t.find.ID=function(n,t){if("undefined"!=typeof t.getElementById&&h){var i=t.getElementById(n);return i?[i]:[]}},t.filter.ID=function(n){var t=n.replace(y,p);return function(n){return n.getAttribute("id")===t}}):(delete t.find.ID,t.filter.ID=function(n){var t=n.replace(y,p);return function(n){var i="undefined"!=typeof n.getAttributeNode&&n.getAttributeNode("id");return i&&i.value===t}}),t.find.TAG=f.getElementsByTagName?function(n,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(n):f.qsa?t.querySelectorAll(n):void 0}:function(n,t){var i,r=[],f=0,u=t.getElementsByTagName(n);if("*"===n){while(i=u[f++])1===i.nodeType&&r.push(i);return r}return u},t.find.CLASS=f.getElementsByClassName&&function(n,t){if("undefined"!=typeof t.getElementsByClassName&&h)return t.getElementsByClassName(n)},d=[],o=[],(f.qsa=ot.test(i.querySelectorAll))&&(a(function(n){s.appendChild(n).innerHTML="<a id='"+e+"'><\/a><select id='"+e+"-\r\\' msallowcapture=''><option selected=''><\/option><\/select>";n.querySelectorAll("[msallowcapture^='']").length&&o.push("[*^$]="+r+"*(?:''|\"\")");n.querySelectorAll("[selected]").length||o.push("\\["+r+"*(?:value|"+kt+")");n.querySelectorAll("[id~="+e+"-]").length||o.push("~=");n.querySelectorAll(":checked").length||o.push(":checked");n.querySelectorAll("a#"+e+"+*").length||o.push(".#.+[+~]")}),a(function(n){var t=i.createElement("input");t.setAttribute("type","hidden");n.appendChild(t).setAttribute("name","D");n.querySelectorAll("[name=d]").length&&o.push("name"+r+"*[*^$|!~]?=");n.querySelectorAll(":enabled").length||o.push(":enabled",":disabled");n.querySelectorAll("*,:x");o.push(",.*:")})),(f.matchesSelector=ot.test(ct=s.matches||s.webkitMatchesSelector||s.mozMatchesSelector||s.oMatchesSelector||s.msMatchesSelector))&&a(function(n){f.disconnectedMatch=ct.call(n,"div");ct.call(n,"[s!='']:x");d.push("!=",dt)}),o=o.length&&new RegExp(o.join("|")),d=d.length&&new RegExp(d.join("|")),v=ot.test(s.compareDocumentPosition),et=v||ot.test(s.contains)?function(n,t){var r=9===n.nodeType?n.documentElement:n,i=t&&t.parentNode;return n===i||!(!i||1!==i.nodeType||!(r.contains?r.contains(i):n.compareDocumentPosition&&16&n.compareDocumentPosition(i)))}:function(n,t){if(t)while(t=t.parentNode)if(t===n)return!0;return!1},bt=v?function(n,t){if(n===t)return ut=!0,0;var r=!n.compareDocumentPosition-!t.compareDocumentPosition;return r?r:(r=(n.ownerDocument||n)===(t.ownerDocument||t)?n.compareDocumentPosition(t):1,1&r||!f.sortDetached&&t.compareDocumentPosition(n)===r?n===i||n.ownerDocument===c&&et(c,n)?-1:t===i||t.ownerDocument===c&&et(c,t)?1:w?nt(w,n)-nt(w,t):0:4&r?-1:1)}:function(n,t){if(n===t)return ut=!0,0;var r,u=0,o=n.parentNode,s=t.parentNode,f=[n],e=[t];if(!o||!s)return n===i?-1:t===i?1:o?-1:s?1:w?nt(w,n)-nt(w,t):0;if(o===s)return wi(n,t);for(r=n;r=r.parentNode;)f.unshift(r);for(r=t;r=r.parentNode;)e.unshift(r);while(f[u]===e[u])u++;return u?wi(f[u],e[u]):f[u]===c?-1:e[u]===c?1:0},i):i};u.matches=function(n,t){return u(n,null,null,t)};u.matchesSelector=function(n,t){if((n.ownerDocument||n)!==i&&b(n),t=t.replace(ur,"='$1']"),f.matchesSelector&&h&&!lt[t+" "]&&(!d||!d.test(t))&&(!o||!o.test(t)))try{var r=ct.call(n,t);if(r||f.disconnectedMatch||n.document&&11!==n.document.nodeType)return r}catch(e){}return u(t,i,null,[n]).length>0};u.contains=function(n,t){return(n.ownerDocument||n)!==i&&b(n),et(n,t)};u.attr=function(n,r){(n.ownerDocument||n)!==i&&b(n);var e=t.attrHandle[r.toLowerCase()],u=e&&di.call(t.attrHandle,r.toLowerCase())?e(n,r,!h):void 0;return void 0!==u?u:f.attributes||!h?n.getAttribute(r):(u=n.getAttributeNode(r))&&u.specified?u.value:null};u.error=function(n){throw new Error("Syntax error, unrecognized expression: "+n);};u.uniqueSort=function(n){var r,u=[],t=0,i=0;if(ut=!f.detectDuplicates,w=!f.sortStable&&n.slice(0),n.sort(bt),ut){while(r=n[i++])r===n[i]&&(t=u.push(i));while(t--)n.splice(u[t],1)}return w=null,n};st=u.getText=function(n){var r,i="",u=0,t=n.nodeType;if(t){if(1===t||9===t||11===t){if("string"==typeof n.textContent)return n.textContent;for(n=n.firstChild;n;n=n.nextSibling)i+=st(n)}else if(3===t||4===t)return n.nodeValue}else while(r=n[u++])i+=st(r);return i};t=u.selectors={cacheLength:50,createPseudo:l,match:vt,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(n){return n[1]=n[1].replace(y,p),n[3]=(n[3]||n[4]||n[5]||"").replace(y,p),"~="===n[2]&&(n[3]=" "+n[3]+" "),n.slice(0,4)},CHILD:function(n){return n[1]=n[1].toLowerCase(),"nth"===n[1].slice(0,3)?(n[3]||u.error(n[0]),n[4]=+(n[4]?n[5]+(n[6]||1):2*("even"===n[3]||"odd"===n[3])),n[5]=+(n[7]+n[8]||"odd"===n[3])):n[3]&&u.error(n[0]),n},PSEUDO:function(n){var i,t=!n[6]&&n[2];return vt.CHILD.test(n[0])?null:(n[3]?n[2]=n[4]||n[5]||"":t&&fr.test(t)&&(i=ft(t,!0))&&(i=t.indexOf(")",t.length-i)-t.length)&&(n[0]=n[0].slice(0,i),n[2]=t.slice(0,i)),n.slice(0,3))}},filter:{TAG:function(n){var t=n.replace(y,p).toLowerCase();return"*"===n?function(){return!0}:function(n){return n.nodeName&&n.nodeName.toLowerCase()===t}},CLASS:function(n){var t=hi[n+" "];return t||(t=new RegExp("(^|"+r+")"+n+"("+r+"|$)"))&&hi(n,function(n){return t.test("string"==typeof n.className&&n.className||"undefined"!=typeof n.getAttribute&&n.getAttribute("class")||"")})},ATTR:function(n,t,i){return function(r){var f=u.attr(r,n);return null==f?"!="===t:t?(f+="","="===t?f===i:"!="===t?f!==i:"^="===t?i&&0===f.indexOf(i):"*="===t?i&&f.indexOf(i)>-1:"$="===t?i&&f.slice(-i.length)===i:"~="===t?(" "+f.replace(tr," ")+" ").indexOf(i)>-1:"|="===t?f===i||f.slice(0,i.length+1)===i+"-":!1):!0}},CHILD:function(n,t,i,r,u){var s="nth"!==n.slice(0,3),o="last"!==n.slice(-4),f="of-type"===t;return 1===r&&0===u?function(n){return!!n.parentNode}:function(t,i,h){var p,w,y,c,a,b,k=s!==o?"nextSibling":"previousSibling",d=t.parentNode,nt=f&&t.nodeName.toLowerCase(),g=!h&&!f,l=!1;if(d){if(s){while(k){for(c=t;c=c[k];)if(f?c.nodeName.toLowerCase()===nt:1===c.nodeType)return!1;b=k="only"===n&&!b&&"nextSibling"}return!0}if(b=[o?d.firstChild:d.lastChild],o&&g){for(c=d,y=c[e]||(c[e]={}),w=y[c.uniqueID]||(y[c.uniqueID]={}),p=w[n]||[],a=p[0]===v&&p[1],l=a&&p[2],c=a&&d.childNodes[a];c=++a&&c&&c[k]||(l=a=0)||b.pop();)if(1===c.nodeType&&++l&&c===t){w[n]=[v,a,l];break}}else if(g&&(c=t,y=c[e]||(c[e]={}),w=y[c.uniqueID]||(y[c.uniqueID]={}),p=w[n]||[],a=p[0]===v&&p[1],l=a),l===!1)while(c=++a&&c&&c[k]||(l=a=0)||b.pop())if((f?c.nodeName.toLowerCase()===nt:1===c.nodeType)&&++l&&(g&&(y=c[e]||(c[e]={}),w=y[c.uniqueID]||(y[c.uniqueID]={}),w[n]=[v,l]),c===t))break;return l-=u,l===r||l%r==0&&l/r>=0}}},PSEUDO:function(n,i){var f,r=t.pseudos[n]||t.setFilters[n.toLowerCase()]||u.error("unsupported pseudo: "+n);return r[e]?r(i):r.length>1?(f=[n,n,"",i],t.setFilters.hasOwnProperty(n.toLowerCase())?l(function(n,t){for(var u,f=r(n,i),e=f.length;e--;)u=nt(n,f[e]),n[u]=!(t[u]=f[e])}):function(n){return r(n,0,f)}):r}},pseudos:{not:l(function(n){var t=[],r=[],i=wt(n.replace(at,"$1"));return i[e]?l(function(n,t,r,u){for(var e,o=i(n,null,u,[]),f=n.length;f--;)(e=o[f])&&(n[f]=!(t[f]=e))}):function(n,u,f){return t[0]=n,i(t,null,f,r),t[0]=null,!r.pop()}}),has:l(function(n){return function(t){return u(n,t).length>0}}),contains:l(function(n){return n=n.replace(y,p),function(t){return(t.textContent||t.innerText||st(t)).indexOf(n)>-1}}),lang:l(function(n){return yi.test(n||"")||u.error("unsupported lang: "+n),n=n.replace(y,p).toLowerCase(),function(t){var i;do if(i=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return i=i.toLowerCase(),i===n||0===i.indexOf(n+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var i=n.location&&n.location.hash;return i&&i.slice(1)===t.id},root:function(n){return n===s},focus:function(n){return n===i.activeElement&&(!i.hasFocus||i.hasFocus())&&!!(n.type||n.href||~n.tabIndex)},enabled:function(n){return n.disabled===!1},disabled:function(n){return n.disabled===!0},checked:function(n){var t=n.nodeName.toLowerCase();return"input"===t&&!!n.checked||"option"===t&&!!n.selected},selected:function(n){return n.parentNode&&n.parentNode.selectedIndex,n.selected===!0},empty:function(n){for(n=n.firstChild;n;n=n.nextSibling)if(n.nodeType<6)return!1;return!0},parent:function(n){return!t.pseudos.empty(n)},header:function(n){return or.test(n.nodeName)},input:function(n){return er.test(n.nodeName)},button:function(n){var t=n.nodeName.toLowerCase();return"input"===t&&"button"===n.type||"button"===t},text:function(n){var t;return"input"===n.nodeName.toLowerCase()&&"text"===n.type&&(null==(t=n.getAttribute("type"))||"text"===t.toLowerCase())},first:it(function(){return[0]}),last:it(function(n,t){return[t-1]}),eq:it(function(n,t,i){return[0>i?i+t:i]}),even:it(function(n,t){for(var i=0;t>i;i+=2)n.push(i);return n}),odd:it(function(n,t){for(var i=1;t>i;i+=2)n.push(i);return n}),lt:it(function(n,t,i){for(var r=0>i?i+t:i;--r>=0;)n.push(r);return n}),gt:it(function(n,t,i){for(var r=0>i?i+t:i;++r<t;)n.push(r);return n})}};t.pseudos.nth=t.pseudos.eq;for(rt in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})t.pseudos[rt]=cr(rt);for(rt in{submit:!0,reset:!0})t.pseudos[rt]=lr(rt);return bi.prototype=t.filters=t.pseudos,t.setFilters=new bi,ft=u.tokenize=function(n,i){var e,f,s,o,r,h,c,l=ci[n+" "];if(l)return i?0:l.slice(0);for(r=n,h=[],c=t.preFilter;r;){(!e||(f=ir.exec(r)))&&(f&&(r=r.slice(f[0].length)||r),h.push(s=[]));e=!1;(f=rr.exec(r))&&(e=f.shift(),s.push({value:e,type:f[0].replace(at," ")}),r=r.slice(e.length));for(o in t.filter)(f=vt[o].exec(r))&&(!c[o]||(f=c[o](f)))&&(e=f.shift(),s.push({value:e,type:o,matches:f}),r=r.slice(e.length));if(!e)break}return i?r.length:r?u.error(n):ci(n,h).slice(0)},wt=u.compile=function(n,t){var r,u=[],f=[],i=lt[n+" "];if(!i){for(t||(t=ft(n)),r=t.length;r--;)i=ei(t[r]),i[e]?u.push(i):f.push(i);i=lt(n,vr(f,u));i.selector=n}return i},si=u.select=function(n,i,r,u){var s,e,o,a,v,l="function"==typeof n&&n,c=!u&&ft(n=l.selector||n);if(r=r||[],1===c.length){if(e=c[0]=c[0].slice(0),e.length>2&&"ID"===(o=e[0]).type&&f.getById&&9===i.nodeType&&h&&t.relative[e[1].type]){if(i=(t.find.ID(o.matches[0].replace(y,p),i)||[])[0],!i)return r;l&&(i=i.parentNode);n=n.slice(e.shift().value.length)}for(s=vt.needsContext.test(n)?0:e.length;s--;){if(o=e[s],t.relative[a=o.type])break;if((v=t.find[a])&&(u=v(o.matches[0].replace(y,p),gt.test(e[0].type)&&ii(i.parentNode)||i))){if(e.splice(s,1),n=u.length&&yt(e),!n)return k.apply(r,u),r;break}}}return(l||wt(n,c))(u,i,!h,r,!i||gt.test(n)&&ii(i.parentNode)||i),r},f.sortStable=e.split("").sort(bt).join("")===e,f.detectDuplicates=!!ut,b(),f.sortDetached=a(function(n){return 1&n.compareDocumentPosition(i.createElement("div"))}),a(function(n){return n.innerHTML="<a href='#'><\/a>","#"===n.firstChild.getAttribute("href")})||ti("type|href|height|width",function(n,t,i){if(!i)return n.getAttribute(t,"type"===t.toLowerCase()?1:2)}),f.attributes&&a(function(n){return n.innerHTML="<input/>",n.firstChild.setAttribute("value",""),""===n.firstChild.getAttribute("value")})||ti("value",function(n,t,i){if(!i&&"input"===n.nodeName.toLowerCase())return n.defaultValue}),a(function(n){return null==n.getAttribute("disabled")})||ti(kt,function(n,t,i){var r;if(!i)return n[t]===!0?t.toLowerCase():(r=n.getAttributeNode(t))&&r.specified?r.value:null}),u}(n);i.find=p;i.expr=p.selectors;i.expr[":"]=i.expr.pseudos;i.uniqueSort=i.unique=p.uniqueSort;i.text=p.getText;i.isXMLDoc=p.isXML;i.contains=p.contains;var d=function(n,t,r){for(var u=[],f=void 0!==r;(n=n[t])&&9!==n.nodeType;)if(1===n.nodeType){if(f&&i(n).is(r))break;u.push(n)}return u},tr=function(n,t){for(var i=[];n;n=n.nextSibling)1===n.nodeType&&n!==t&&i.push(n);return i},ir=i.expr.match.needsContext,rr=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,bf=/^.[^:#\[\.,]*$/;i.filter=function(n,t,r){var u=t[0];return r&&(n=":not("+n+")"),1===t.length&&1===u.nodeType?i.find.matchesSelector(u,n)?[u]:[]:i.find.matches(n,i.grep(t,function(n){return 1===n.nodeType}))};i.fn.extend({find:function(n){var t,u=this.length,r=[],f=this;if("string"!=typeof n)return this.pushStack(i(n).filter(function(){for(t=0;u>t;t++)if(i.contains(f[t],this))return!0}));for(t=0;u>t;t++)i.find(n,f[t],r);return r=this.pushStack(u>1?i.unique(r):r),r.selector=this.selector?this.selector+" "+n:n,r},filter:function(n){return this.pushStack(ri(this,n||[],!1))},not:function(n){return this.pushStack(ri(this,n||[],!0))},is:function(n){return!!ri(this,"string"==typeof n&&ir.test(n)?i(n):n||[],!1).length}});fr=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;er=i.fn.init=function(n,t,r){var f,e;if(!n)return this;if(r=r||ur,"string"==typeof n){if(f="<"===n[0]&&">"===n[n.length-1]&&n.length>=3?[null,n,null]:fr.exec(n),!f||!f[1]&&t)return!t||t.jquery?(t||r).find(n):this.constructor(t).find(n);if(f[1]){if(t=t instanceof i?t[0]:t,i.merge(this,i.parseHTML(f[1],t&&t.nodeType?t.ownerDocument||t:u,!0)),rr.test(f[1])&&i.isPlainObject(t))for(f in t)i.isFunction(this[f])?this[f](t[f]):this.attr(f,t[f]);return this}return e=u.getElementById(f[2]),e&&e.parentNode&&(this.length=1,this[0]=e),this.context=u,this.selector=n,this}return n.nodeType?(this.context=this[0]=n,this.length=1,this):i.isFunction(n)?void 0!==r.ready?r.ready(n):n(i):(void 0!==n.selector&&(this.selector=n.selector,this.context=n.context),i.makeArray(n,this))};er.prototype=i.fn;ur=i(u);or=/^(?:parents|prev(?:Until|All))/;sr={children:!0,contents:!0,next:!0,prev:!0};i.fn.extend({has:function(n){var t=i(n,this),r=t.length;return this.filter(function(){for(var n=0;r>n;n++)if(i.contains(this,t[n]))return!0})},closest:function(n,t){for(var r,f=0,o=this.length,u=[],e=ir.test(n)||"string"!=typeof n?i(n,t||this.context):0;o>f;f++)for(r=this[f];r&&r!==t;r=r.parentNode)if(r.nodeType<11&&(e?e.index(r)>-1:1===r.nodeType&&i.find.matchesSelector(r,n))){u.push(r);break}return this.pushStack(u.length>1?i.uniqueSort(u):u)},index:function(n){return n?"string"==typeof n?lt.call(i(n),this[0]):lt.call(this,n.jquery?n[0]:n):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(n,t){return this.pushStack(i.uniqueSort(i.merge(this.get(),i(n,t))))},addBack:function(n){return this.add(null==n?this.prevObject:this.prevObject.filter(n))}});i.each({parent:function(n){var t=n.parentNode;return t&&11!==t.nodeType?t:null},parents:function(n){return d(n,"parentNode")},parentsUntil:function(n,t,i){return d(n,"parentNode",i)},next:function(n){return hr(n,"nextSibling")},prev:function(n){return hr(n,"previousSibling")},nextAll:function(n){return d(n,"nextSibling")},prevAll:function(n){return d(n,"previousSibling")},nextUntil:function(n,t,i){return d(n,"nextSibling",i)},prevUntil:function(n,t,i){return d(n,"previousSibling",i)},siblings:function(n){return tr((n.parentNode||{}).firstChild,n)},children:function(n){return tr(n.firstChild)},contents:function(n){return n.contentDocument||i.merge([],n.childNodes)}},function(n,t){i.fn[n]=function(r,u){var f=i.map(this,t,r);return"Until"!==n.slice(-5)&&(u=r),u&&"string"==typeof u&&(f=i.filter(u,f)),this.length>1&&(sr[n]||i.uniqueSort(f),or.test(n)&&f.reverse()),this.pushStack(f)}});h=/\S+/g;i.Callbacks=function(n){n="string"==typeof n?kf(n):i.extend({},n);var o,r,h,f,t=[],e=[],u=-1,c=function(){for(f=n.once,h=o=!0;e.length;u=-1)for(r=e.shift();++u<t.length;)t[u].apply(r[0],r[1])===!1&&n.stopOnFalse&&(u=t.length,r=!1);n.memory||(r=!1);o=!1;f&&(t=r?[]:"")},s={add:function(){return t&&(r&&!o&&(u=t.length-1,e.push(r)),function f(r){i.each(r,function(r,u){i.isFunction(u)?n.unique&&s.has(u)||t.push(u):u&&u.length&&"string"!==i.type(u)&&f(u)})}(arguments),r&&!o&&c()),this},remove:function(){return i.each(arguments,function(n,r){for(var f;(f=i.inArray(r,t,f))>-1;)t.splice(f,1),u>=f&&u--}),this},has:function(n){return n?i.inArray(n,t)>-1:t.length>0},empty:function(){return t&&(t=[]),this},disable:function(){return f=e=[],t=r="",this},disabled:function(){return!t},lock:function(){return f=e=[],r||(t=r=""),this},locked:function(){return!!f},fireWith:function(n,t){return f||(t=t||[],t=[n,t.slice?t.slice():t],e.push(t),o||c()),this},fire:function(){return s.fireWith(this,arguments),this},fired:function(){return!!h}};return s};i.extend({Deferred:function(n){var u=[["resolve","done",i.Callbacks("once memory"),"resolved"],["reject","fail",i.Callbacks("once memory"),"rejected"],["notify","progress",i.Callbacks("memory")]],f="pending",r={state:function(){return f},always:function(){return t.done(arguments).fail(arguments),this},then:function(){var n=arguments;return i.Deferred(function(f){i.each(u,function(u,e){var o=i.isFunction(n[u])&&n[u];t[e[1]](function(){var n=o&&o.apply(this,arguments);n&&i.isFunction(n.promise)?n.promise().progress(f.notify).done(f.resolve).fail(f.reject):f[e[0]+"With"](this===r?f.promise():this,o?[n]:arguments)})});n=null}).promise()},promise:function(n){return null!=n?i.extend(n,r):r}},t={};return r.pipe=r.then,i.each(u,function(n,i){var e=i[2],o=i[3];r[i[1]]=e.add;o&&e.add(function(){f=o},u[1^n][2].disable,u[2][2].lock);t[i[0]]=function(){return t[i[0]+"With"](this===t?r:this,arguments),this};t[i[0]+"With"]=e.fireWith}),r.promise(t),n&&n.call(t,t),t},when:function(n){var t=0,u=v.call(arguments),r=u.length,e=1!==r||n&&i.isFunction(n.promise)?r:0,f=1===e?n:i.Deferred(),h=function(n,t,i){return function(r){t[n]=this;i[n]=arguments.length>1?v.call(arguments):r;i===o?f.notifyWith(t,i):--e||f.resolveWith(t,i)}},o,c,s;if(r>1)for(o=new Array(r),c=new Array(r),s=new Array(r);r>t;t++)u[t]&&i.isFunction(u[t].promise)?u[t].promise().progress(h(t,c,o)).done(h(t,s,u)).fail(f.reject):--e;return e||f.resolveWith(s,u),f.promise()}});i.fn.ready=function(n){return i.ready.promise().done(n),this};i.extend({isReady:!1,readyWait:1,holdReady:function(n){n?i.readyWait++:i.ready(!0)},ready:function(n){(n===!0?--i.readyWait:i.isReady)||(i.isReady=!0,n!==!0&&--i.readyWait>0||(vt.resolveWith(u,[i]),i.fn.triggerHandler&&(i(u).triggerHandler("ready"),i(u).off("ready"))))}});i.ready.promise=function(t){return vt||(vt=i.Deferred(),"complete"===u.readyState||"loading"!==u.readyState&&!u.documentElement.doScroll?n.setTimeout(i.ready):(u.addEventListener("DOMContentLoaded",yt),n.addEventListener("load",yt))),vt.promise(t)};i.ready.promise();a=function(n,t,r,u,f,e,o){var s=0,c=n.length,h=null==r;if("object"===i.type(r)){f=!0;for(s in r)a(n,t,s,r[s],!0,e,o)}else if(void 0!==u&&(f=!0,i.isFunction(u)||(o=!0),h&&(o?(t.call(n,u),t=null):(h=t,t=function(n,t,r){return h.call(i(n),r)})),t))for(;c>s;s++)t(n[s],r,o?u:u.call(n[s],s,t(n[s],r)));return f?n:h?t.call(n):c?t(n[0],r):e};g=function(n){return 1===n.nodeType||9===n.nodeType||!+n.nodeType};et.uid=1;et.prototype={register:function(n,t){var i=t||{};return n.nodeType?n[this.expando]=i:Object.defineProperty(n,this.expando,{value:i,writable:!0,configurable:!0}),n[this.expando]},cache:function(n){if(!g(n))return{};var t=n[this.expando];return t||(t={},g(n)&&(n.nodeType?n[this.expando]=t:Object.defineProperty(n,this.expando,{value:t,configurable:!0}))),t},set:function(n,t,i){var r,u=this.cache(n);if("string"==typeof t)u[t]=i;else for(r in t)u[r]=t[r];return u},get:function(n,t){return void 0===t?this.cache(n):n[this.expando]&&n[this.expando][t]},access:function(n,t,r){var u;return void 0===t||t&&"string"==typeof t&&void 0===r?(u=this.get(n,t),void 0!==u?u:this.get(n,i.camelCase(t))):(this.set(n,t,r),void 0!==r?r:t)},remove:function(n,t){var f,r,e,u=n[this.expando];if(void 0!==u){if(void 0===t)this.register(n);else for(i.isArray(t)?r=t.concat(t.map(i.camelCase)):(e=i.camelCase(t),(t in u)?r=[t,e]:(r=e,r=(r in u)?[r]:r.match(h)||[])),f=r.length;f--;)delete u[r[f]];(void 0===t||i.isEmptyObject(u))&&(n.nodeType?n[this.expando]=void 0:delete n[this.expando])}},hasData:function(n){var t=n[this.expando];return void 0!==t&&!i.isEmptyObject(t)}};var r=new et,e=new et,df=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,cr=/[A-Z]/g;i.extend({hasData:function(n){return e.hasData(n)||r.hasData(n)},data:function(n,t,i){return e.access(n,t,i)},removeData:function(n,t){e.remove(n,t)},_data:function(n,t,i){return r.access(n,t,i)},_removeData:function(n,t){r.remove(n,t)}});i.fn.extend({data:function(n,t){var o,f,s,u=this[0],h=u&&u.attributes;if(void 0===n){if(this.length&&(s=e.get(u),1===u.nodeType&&!r.get(u,"hasDataAttrs"))){for(o=h.length;o--;)h[o]&&(f=h[o].name,0===f.indexOf("data-")&&(f=i.camelCase(f.slice(5)),lr(u,f,s[f])));r.set(u,"hasDataAttrs",!0)}return s}return"object"==typeof n?this.each(function(){e.set(this,n)}):a(this,function(t){var r,f;if(u&&void 0===t){if((r=e.get(u,n)||e.get(u,n.replace(cr,"-$&").toLowerCase()),void 0!==r)||(f=i.camelCase(n),r=e.get(u,f),void 0!==r)||(r=lr(u,f,void 0),void 0!==r))return r}else f=i.camelCase(n),this.each(function(){var i=e.get(this,f);e.set(this,f,t);n.indexOf("-")>-1&&void 0!==i&&e.set(this,n,t)})},null,t,arguments.length>1,null,!0)},removeData:function(n){return this.each(function(){e.remove(this,n)})}});i.extend({queue:function(n,t,u){var f;if(n)return(t=(t||"fx")+"queue",f=r.get(n,t),u&&(!f||i.isArray(u)?f=r.access(n,t,i.makeArray(u)):f.push(u)),f||[])},dequeue:function(n,t){t=t||"fx";var r=i.queue(n,t),e=r.length,u=r.shift(),f=i._queueHooks(n,t),o=function(){i.dequeue(n,t)};"inprogress"===u&&(u=r.shift(),e--);u&&("fx"===t&&r.unshift("inprogress"),delete f.stop,u.call(n,o,f));!e&&f&&f.empty.fire()},_queueHooks:function(n,t){var u=t+"queueHooks";return r.get(n,u)||r.access(n,u,{empty:i.Callbacks("once memory").add(function(){r.remove(n,[t+"queue",u])})})}});i.fn.extend({queue:function(n,t){var r=2;return"string"!=typeof n&&(t=n,n="fx",r--),arguments.length<r?i.queue(this[0],n):void 0===t?this:this.each(function(){var r=i.queue(this,n,t);i._queueHooks(this,n);"fx"===n&&"inprogress"!==r[0]&&i.dequeue(this,n)})},dequeue:function(n){return this.each(function(){i.dequeue(this,n)})},clearQueue:function(n){return this.queue(n||"fx",[])},promise:function(n,t){var u,e=1,o=i.Deferred(),f=this,s=this.length,h=function(){--e||o.resolveWith(f,[f])};for("string"!=typeof n&&(t=n,n=void 0),n=n||"fx";s--;)u=r.get(f[s],n+"queueHooks"),u&&u.empty&&(e++,u.empty.add(h));return h(),o.promise(t)}});var ar=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ot=new RegExp("^(?:([+-])=|)("+ar+")([a-z%]*)$","i"),w=["Top","Right","Bottom","Left"],st=function(n,t){return n=t||n,"none"===i.css(n,"display")||!i.contains(n.ownerDocument,n)};var yr=/^(?:checkbox|radio)$/i,pr=/<([\w:-]+)/,wr=/^$|\/(?:java|ecma)script/i,c={option:[1,"<select multiple='multiple'>","<\/select>"],thead:[1,"<table>","<\/table>"],col:[2,"<table><colgroup>","<\/colgroup><\/table>"],tr:[2,"<table><tbody>","<\/tbody><\/table>"],td:[3,"<table><tbody><tr>","<\/tr><\/tbody><\/table>"],_default:[0,"",""]};c.optgroup=c.option;c.tbody=c.tfoot=c.colgroup=c.caption=c.thead;c.th=c.td;br=/<|&#?\w+;/;!function(){var i=u.createDocumentFragment(),n=i.appendChild(u.createElement("div")),t=u.createElement("input");t.setAttribute("type","radio");t.setAttribute("checked","checked");t.setAttribute("name","t");n.appendChild(t);f.checkClone=n.cloneNode(!0).cloneNode(!0).lastChild.checked;n.innerHTML="<textarea>x<\/textarea>";f.noCloneChecked=!!n.cloneNode(!0).lastChild.defaultValue}();var gf=/^key/,ne=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,dr=/^([^.]*)(?:\.(.+)|)/;i.event={global:{},add:function(n,t,u,f,e){var v,y,w,p,b,c,s,l,o,k,d,a=r.get(n);if(a)for(u.handler&&(v=u,u=v.handler,e=v.selector),u.guid||(u.guid=i.guid++),(p=a.events)||(p=a.events={}),(y=a.handle)||(y=a.handle=function(t){if("undefined"!=typeof i&&i.event.triggered!==t.type)return i.event.dispatch.apply(n,arguments)}),t=(t||"").match(h)||[""],b=t.length;b--;)w=dr.exec(t[b])||[],o=d=w[1],k=(w[2]||"").split(".").sort(),o&&(s=i.event.special[o]||{},o=(e?s.delegateType:s.bindType)||o,s=i.event.special[o]||{},c=i.extend({type:o,origType:d,data:f,handler:u,guid:u.guid,selector:e,needsContext:e&&i.expr.match.needsContext.test(e),namespace:k.join(".")},v),(l=p[o])||(l=p[o]=[],l.delegateCount=0,s.setup&&s.setup.call(n,f,k,y)!==!1||n.addEventListener&&n.addEventListener(o,y)),s.add&&(s.add.call(n,c),c.handler.guid||(c.handler.guid=u.guid)),e?l.splice(l.delegateCount++,0,c):l.push(c),i.event.global[o]=!0)},remove:function(n,t,u,f,e){var y,k,c,v,p,s,l,a,o,b,d,w=r.hasData(n)&&r.get(n);if(w&&(v=w.events)){for(t=(t||"").match(h)||[""],p=t.length;p--;)if(c=dr.exec(t[p])||[],o=d=c[1],b=(c[2]||"").split(".").sort(),o){for(l=i.event.special[o]||{},o=(f?l.delegateType:l.bindType)||o,a=v[o]||[],c=c[2]&&new RegExp("(^|\\.)"+b.join("\\.(?:.*\\.|)")+"(\\.|$)"),k=y=a.length;y--;)s=a[y],!e&&d!==s.origType||u&&u.guid!==s.guid||c&&!c.test(s.namespace)||f&&f!==s.selector&&("**"!==f||!s.selector)||(a.splice(y,1),s.selector&&a.delegateCount--,l.remove&&l.remove.call(n,s));k&&!a.length&&(l.teardown&&l.teardown.call(n,b,w.handle)!==!1||i.removeEvent(n,o,w.handle),delete v[o])}else for(o in v)i.event.remove(n,o+t[p],u,f,!0);i.isEmptyObject(v)&&r.remove(n,"handle events")}},dispatch:function(n){n=i.event.fix(n);var o,s,e,u,t,h=[],c=v.call(arguments),l=(r.get(this,"events")||{})[n.type]||[],f=i.event.special[n.type]||{};if(c[0]=n,n.delegateTarget=this,!f.preDispatch||f.preDispatch.call(this,n)!==!1){for(h=i.event.handlers.call(this,n,l),o=0;(u=h[o++])&&!n.isPropagationStopped();)for(n.currentTarget=u.elem,s=0;(t=u.handlers[s++])&&!n.isImmediatePropagationStopped();)n.rnamespace&&!n.rnamespace.test(t.namespace)||(n.handleObj=t,n.data=t.data,e=((i.event.special[t.origType]||{}).handle||t.handler).apply(u.elem,c),void 0!==e&&(n.result=e)===!1&&(n.preventDefault(),n.stopPropagation()));return f.postDispatch&&f.postDispatch.call(this,n),n.result}},handlers:function(n,t){var e,u,f,o,h=[],s=t.delegateCount,r=n.target;if(s&&r.nodeType&&("click"!==n.type||isNaN(n.button)||n.button<1))for(;r!==this;r=r.parentNode||this)if(1===r.nodeType&&(r.disabled!==!0||"click"!==n.type)){for(u=[],e=0;s>e;e++)o=t[e],f=o.selector+" ",void 0===u[f]&&(u[f]=o.needsContext?i(f,this).index(r)>-1:i.find(f,this,null,[r]).length),u[f]&&u.push(o);u.length&&h.push({elem:r,handlers:u})}return s<t.length&&h.push({elem:this,handlers:t.slice(s)}),h},props:"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(n,t){return null==n.which&&(n.which=null!=t.charCode?t.charCode:t.keyCode),n}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(n,t){var e,i,r,f=t.button;return null==n.pageX&&null!=t.clientX&&(e=n.target.ownerDocument||u,i=e.documentElement,r=e.body,n.pageX=t.clientX+(i&&i.scrollLeft||r&&r.scrollLeft||0)-(i&&i.clientLeft||r&&r.clientLeft||0),n.pageY=t.clientY+(i&&i.scrollTop||r&&r.scrollTop||0)-(i&&i.clientTop||r&&r.clientTop||0)),n.which||void 0===f||(n.which=1&f?1:2&f?3:4&f?2:0),n}},fix:function(n){if(n[i.expando])return n;var f,e,o,r=n.type,s=n,t=this.fixHooks[r];for(t||(this.fixHooks[r]=t=ne.test(r)?this.mouseHooks:gf.test(r)?this.keyHooks:{}),o=t.props?this.props.concat(t.props):this.props,n=new i.Event(s),f=o.length;f--;)e=o[f],n[e]=s[e];return n.target||(n.target=u),3===n.target.nodeType&&(n.target=n.target.parentNode),t.filter?t.filter(n,s):n},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==gr()&&this.focus)return(this.focus(),!1)},delegateType:"focusin"},blur:{trigger:function(){if(this===gr()&&this.blur)return(this.blur(),!1)},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&i.nodeName(this,"input"))return(this.click(),!1)},_default:function(n){return i.nodeName(n.target,"a")}},beforeunload:{postDispatch:function(n){void 0!==n.result&&n.originalEvent&&(n.originalEvent.returnValue=n.result)}}}};i.removeEvent=function(n,t,i){n.removeEventListener&&n.removeEventListener(t,i)};i.Event=function(n,t){return this instanceof i.Event?(n&&n.type?(this.originalEvent=n,this.type=n.type,this.isDefaultPrevented=n.defaultPrevented||void 0===n.defaultPrevented&&n.returnValue===!1?pt:nt):this.type=n,t&&i.extend(this,t),this.timeStamp=n&&n.timeStamp||i.now(),void(this[i.expando]=!0)):new i.Event(n,t)};i.Event.prototype={constructor:i.Event,isDefaultPrevented:nt,isPropagationStopped:nt,isImmediatePropagationStopped:nt,preventDefault:function(){var n=this.originalEvent;this.isDefaultPrevented=pt;n&&n.preventDefault()},stopPropagation:function(){var n=this.originalEvent;this.isPropagationStopped=pt;n&&n.stopPropagation()},stopImmediatePropagation:function(){var n=this.originalEvent;this.isImmediatePropagationStopped=pt;n&&n.stopImmediatePropagation();this.stopPropagation()}};i.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(n,t){i.event.special[n]={delegateType:t,bindType:t,handle:function(n){var u,f=this,r=n.relatedTarget,e=n.handleObj;return r&&(r===f||i.contains(f,r))||(n.type=e.origType,u=e.handler.apply(this,arguments),n.type=t),u}}});i.fn.extend({on:function(n,t,i,r){return fi(this,n,t,i,r)},one:function(n,t,i,r){return fi(this,n,t,i,r,1)},off:function(n,t,r){var u,f;if(n&&n.preventDefault&&n.handleObj)return u=n.handleObj,i(n.delegateTarget).off(u.namespace?u.origType+"."+u.namespace:u.origType,u.selector,u.handler),this;if("object"==typeof n){for(f in n)this.off(f,t,n[f]);return this}return t!==!1&&"function"!=typeof t||(r=t,t=void 0),r===!1&&(r=nt),this.each(function(){i.event.remove(this,n,r,t)})}});var te=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,ie=/<script|<style|<link/i,re=/checked\s*(?:[^=]|=\s*.checked.)/i,ue=/^true\/(.*)/,fe=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;i.extend({htmlPrefilter:function(n){return n.replace(te,"<$1><\/$2>")},clone:function(n,t,r){var u,c,s,e,h=n.cloneNode(!0),l=i.contains(n.ownerDocument,n);if(!(f.noCloneChecked||1!==n.nodeType&&11!==n.nodeType||i.isXMLDoc(n)))for(e=o(h),s=o(n),u=0,c=s.length;c>u;u++)se(s[u],e[u]);if(t)if(r)for(s=s||o(n),e=e||o(h),u=0,c=s.length;c>u;u++)tu(s[u],e[u]);else tu(n,h);return e=o(h,"script"),e.length>0&&ui(e,!l&&o(n,"script")),h},cleanData:function(n){for(var u,t,f,s=i.event.special,o=0;void 0!==(t=n[o]);o++)if(g(t)){if(u=t[r.expando]){if(u.events)for(f in u.events)s[f]?i.event.remove(t,f):i.removeEvent(t,f,u.handle);t[r.expando]=void 0}t[e.expando]&&(t[e.expando]=void 0)}}});i.fn.extend({domManip:b,detach:function(n){return iu(this,n,!0)},remove:function(n){return iu(this,n)},text:function(n){return a(this,function(n){return void 0===n?i.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=n)})},null,n,arguments.length)},append:function(){return b(this,arguments,function(n){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=nu(this,n);t.appendChild(n)}})},prepend:function(){return b(this,arguments,function(n){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=nu(this,n);t.insertBefore(n,t.firstChild)}})},before:function(){return b(this,arguments,function(n){this.parentNode&&this.parentNode.insertBefore(n,this)})},after:function(){return b(this,arguments,function(n){this.parentNode&&this.parentNode.insertBefore(n,this.nextSibling)})},empty:function(){for(var n,t=0;null!=(n=this[t]);t++)1===n.nodeType&&(i.cleanData(o(n,!1)),n.textContent="");return this},clone:function(n,t){return n=null==n?!1:n,t=null==t?n:t,this.map(function(){return i.clone(this,n,t)})},html:function(n){return a(this,function(n){var t=this[0]||{},r=0,u=this.length;if(void 0===n&&1===t.nodeType)return t.innerHTML;if("string"==typeof n&&!ie.test(n)&&!c[(pr.exec(n)||["",""])[1].toLowerCase()]){n=i.htmlPrefilter(n);try{for(;u>r;r++)t=this[r]||{},1===t.nodeType&&(i.cleanData(o(t,!1)),t.innerHTML=n);t=0}catch(f){}}t&&this.empty().append(n)},null,n,arguments.length)},replaceWith:function(){var n=[];return b(this,arguments,function(t){var r=this.parentNode;i.inArray(this,n)<0&&(i.cleanData(o(this)),r&&r.replaceChild(t,this))},n)}});i.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(n,t){i.fn[n]=function(n){for(var u,f=[],e=i(n),o=e.length-1,r=0;o>=r;r++)u=r===o?this:this.clone(!0),i(e[r])[t](u),ti.apply(f,u.get());return this.pushStack(f)}});ei={HTML:"block",BODY:"block"};var uu=/^margin/,si=new RegExp("^("+ar+")(?!px)[a-z%]+$","i"),bt=function(t){var i=t.ownerDocument.defaultView;return i&&i.opener||(i=n),i.getComputedStyle(t)},hi=function(n,t,i,r){var f,u,e={};for(u in t)e[u]=n.style[u],n.style[u]=t[u];f=i.apply(n,r||[]);for(u in t)n.style[u]=e[u];return f},ht=u.documentElement;!function(){var s,e,h,c,r=u.createElement("div"),t=u.createElement("div");if(t.style){t.style.backgroundClip="content-box";t.cloneNode(!0).style.backgroundClip="";f.clearCloneStyle="content-box"===t.style.backgroundClip;r.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute";r.appendChild(t);function o(){t.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%";t.innerHTML="";ht.appendChild(r);var i=n.getComputedStyle(t);s="1%"!==i.top;c="2px"===i.marginLeft;e="4px"===i.width;t.style.marginRight="50%";h="4px"===i.marginRight;ht.removeChild(r)}i.extend(f,{pixelPosition:function(){return o(),s},boxSizingReliable:function(){return null==e&&o(),e},pixelMarginRight:function(){return null==e&&o(),h},reliableMarginLeft:function(){return null==e&&o(),c},reliableMarginRight:function(){var f,i=t.appendChild(u.createElement("div"));return i.style.cssText=t.style.cssText="-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",t.style.width="1px",ht.appendChild(r),f=!parseFloat(n.getComputedStyle(i).marginRight),ht.removeChild(r),t.removeChild(i),f}})}}();var he=/^(none|table(?!-c[ea]).+)/,ce={position:"absolute",visibility:"hidden",display:"block"},fu={letterSpacing:"0",fontWeight:"400"},eu=["Webkit","O","Moz","ms"],ou=u.createElement("div").style;i.extend({cssHooks:{opacity:{get:function(n,t){if(t){var i=tt(n,"opacity");return""===i?"1":i}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{float:"cssFloat"},style:function(n,t,r,u){if(n&&3!==n.nodeType&&8!==n.nodeType&&n.style){var e,h,o,s=i.camelCase(t),c=n.style;return t=i.cssProps[s]||(i.cssProps[s]=su(s)||s),o=i.cssHooks[t]||i.cssHooks[s],void 0===r?o&&"get"in o&&void 0!==(e=o.get(n,!1,u))?e:c[t]:(h=typeof r,"string"===h&&(e=ot.exec(r))&&e[1]&&(r=vr(n,t,e),h="number"),null!=r&&r===r&&("number"===h&&(r+=e&&e[3]||(i.cssNumber[s]?"":"px")),f.clearCloneStyle||""!==r||0!==t.indexOf("background")||(c[t]="inherit"),o&&"set"in o&&void 0===(r=o.set(n,r,u))||(c[t]=r)),void 0)}},css:function(n,t,r,u){var f,s,o,e=i.camelCase(t);return t=i.cssProps[e]||(i.cssProps[e]=su(e)||e),o=i.cssHooks[t]||i.cssHooks[e],o&&"get"in o&&(f=o.get(n,!0,r)),void 0===f&&(f=tt(n,t,u)),"normal"===f&&t in fu&&(f=fu[t]),""===r||r?(s=parseFloat(f),r===!0||isFinite(s)?s||0:f):f}});i.each(["height","width"],function(n,t){i.cssHooks[t]={get:function(n,r,u){if(r)return he.test(i.css(n,"display"))&&0===n.offsetWidth?hi(n,ce,function(){return lu(n,t,u)}):lu(n,t,u)},set:function(n,r,u){var f,e=u&&bt(n),o=u&&cu(n,t,u,"border-box"===i.css(n,"boxSizing",!1,e),e);return o&&(f=ot.exec(r))&&"px"!==(f[3]||"px")&&(n.style[t]=r,r=i.css(n,t)),hu(n,r,o)}}});i.cssHooks.marginLeft=ci(f.reliableMarginLeft,function(n,t){if(t)return(parseFloat(tt(n,"marginLeft"))||n.getBoundingClientRect().left-hi(n,{marginLeft:0},function(){return n.getBoundingClientRect().left}))+"px"});i.cssHooks.marginRight=ci(f.reliableMarginRight,function(n,t){if(t)return hi(n,{display:"inline-block"},tt,[n,"marginRight"])});i.each({margin:"",padding:"",border:"Width"},function(n,t){i.cssHooks[n+t]={expand:function(i){for(var r=0,f={},u="string"==typeof i?i.split(" "):[i];4>r;r++)f[n+w[r]+t]=u[r]||u[r-2]||u[0];return f}};uu.test(n)||(i.cssHooks[n+t].set=hu)});i.fn.extend({css:function(n,t){return a(this,function(n,t,r){var f,e,o={},u=0;if(i.isArray(t)){for(f=bt(n),e=t.length;e>u;u++)o[t[u]]=i.css(n,t[u],!1,f);return o}return void 0!==r?i.style(n,t,r):i.css(n,t)},n,t,arguments.length>1)},show:function(){return au(this,!0)},hide:function(){return au(this)},toggle:function(n){return"boolean"==typeof n?n?this.show():this.hide():this.each(function(){st(this)?i(this).show():i(this).hide()})}});i.Tween=s;s.prototype={constructor:s,init:function(n,t,r,u,f,e){this.elem=n;this.prop=r;this.easing=f||i.easing._default;this.options=t;this.start=this.now=this.cur();this.end=u;this.unit=e||(i.cssNumber[r]?"":"px")},cur:function(){var n=s.propHooks[this.prop];return n&&n.get?n.get(this):s.propHooks._default.get(this)},run:function(n){var t,r=s.propHooks[this.prop];return this.pos=this.options.duration?t=i.easing[this.easing](n,this.options.duration*n,0,1,this.options.duration):t=n,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),r&&r.set?r.set(this):s.propHooks._default.set(this),this}};s.prototype.init.prototype=s.prototype;s.propHooks={_default:{get:function(n){var t;return 1!==n.elem.nodeType||null!=n.elem[n.prop]&&null==n.elem.style[n.prop]?n.elem[n.prop]:(t=i.css(n.elem,n.prop,""),t&&"auto"!==t?t:0)},set:function(n){i.fx.step[n.prop]?i.fx.step[n.prop](n):1!==n.elem.nodeType||null==n.elem.style[i.cssProps[n.prop]]&&!i.cssHooks[n.prop]?n.elem[n.prop]=n.now:i.style(n.elem,n.prop,n.now+n.unit)}}};s.propHooks.scrollTop=s.propHooks.scrollLeft={set:function(n){n.elem.nodeType&&n.elem.parentNode&&(n.elem[n.prop]=n.now)}};i.easing={linear:function(n){return n},swing:function(n){return.5-Math.cos(n*Math.PI)/2},_default:"swing"};i.fx=s.prototype.init;i.fx.step={};vu=/^(?:toggle|show|hide)$/;yu=/queueHooks$/;i.Animation=i.extend(l,{tweeners:{"*":[function(n,t){var i=this.createTween(n,t);return vr(i.elem,n,ot.exec(t),i),i}]},tweener:function(n,t){i.isFunction(n)?(t=n,n=["*"]):n=n.match(h);for(var r,u=0,f=n.length;f>u;u++)r=n[u],l.tweeners[r]=l.tweeners[r]||[],l.tweeners[r].unshift(t)},prefilters:[le],prefilter:function(n,t){t?l.prefilters.unshift(n):l.prefilters.push(n)}});i.speed=function(n,t,r){var u=n&&"object"==typeof n?i.extend({},n):{complete:r||!r&&t||i.isFunction(n)&&n,duration:n,easing:r&&t||t&&!i.isFunction(t)&&t};return u.duration=i.fx.off?0:"number"==typeof u.duration?u.duration:u.duration in i.fx.speeds?i.fx.speeds[u.duration]:i.fx.speeds._default,null!=u.queue&&u.queue!==!0||(u.queue="fx"),u.old=u.complete,u.complete=function(){i.isFunction(u.old)&&u.old.call(this);u.queue&&i.dequeue(this,u.queue)},u};i.fn.extend({fadeTo:function(n,t,i,r){return this.filter(st).css("opacity",0).show().end().animate({opacity:t},n,i,r)},animate:function(n,t,u,f){var s=i.isEmptyObject(n),o=i.speed(t,u,f),e=function(){var t=l(this,i.extend({},n),o);(s||r.get(this,"finish"))&&t.stop(!0)};return e.finish=e,s||o.queue===!1?this.each(e):this.queue(o.queue,e)},stop:function(n,t,u){var f=function(n){var t=n.stop;delete n.stop;t(u)};return"string"!=typeof n&&(u=t,t=n,n=void 0),t&&n!==!1&&this.queue(n||"fx",[]),this.each(function(){var s=!0,t=null!=n&&n+"queueHooks",o=i.timers,e=r.get(this);if(t)e[t]&&e[t].stop&&f(e[t]);else for(t in e)e[t]&&e[t].stop&&yu.test(t)&&f(e[t]);for(t=o.length;t--;)o[t].elem!==this||null!=n&&o[t].queue!==n||(o[t].anim.stop(u),s=!1,o.splice(t,1));!s&&u||i.dequeue(this,n)})},finish:function(n){return n!==!1&&(n=n||"fx"),this.each(function(){var t,e=r.get(this),u=e[n+"queue"],o=e[n+"queueHooks"],f=i.timers,s=u?u.length:0;for(e.finish=!0,i.queue(this,n,[]),o&&o.stop&&o.stop.call(this,!0),t=f.length;t--;)f[t].elem===this&&f[t].queue===n&&(f[t].anim.stop(!0),f.splice(t,1));for(t=0;s>t;t++)u[t]&&u[t].finish&&u[t].finish.call(this);delete e.finish})}});i.each(["toggle","show","hide"],function(n,t){var r=i.fn[t];i.fn[t]=function(n,i,u){return null==n||"boolean"==typeof n?r.apply(this,arguments):this.animate(dt(t,!0),n,i,u)}});i.each({slideDown:dt("show"),slideUp:dt("hide"),slideToggle:dt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(n,t){i.fn[n]=function(n,i,r){return this.animate(t,n,i,r)}});i.timers=[];i.fx.tick=function(){var r,n=0,t=i.timers;for(it=i.now();n<t.length;n++)r=t[n],r()||t[n]!==r||t.splice(n--,1);t.length||i.fx.stop();it=void 0};i.fx.timer=function(n){i.timers.push(n);n()?i.fx.start():i.timers.pop()};i.fx.interval=13;i.fx.start=function(){kt||(kt=n.setInterval(i.fx.tick,i.fx.interval))};i.fx.stop=function(){n.clearInterval(kt);kt=null};i.fx.speeds={slow:600,fast:200,_default:400};i.fn.delay=function(t,r){return t=i.fx?i.fx.speeds[t]||t:t,r=r||"fx",this.queue(r,function(i,r){var u=n.setTimeout(i,t);r.stop=function(){n.clearTimeout(u)}})},function(){var n=u.createElement("input"),t=u.createElement("select"),i=t.appendChild(u.createElement("option"));n.type="checkbox";f.checkOn=""!==n.value;f.optSelected=i.selected;t.disabled=!0;f.optDisabled=!i.disabled;n=u.createElement("input");n.value="t";n.type="radio";f.radioValue="t"===n.value}();rt=i.expr.attrHandle;i.fn.extend({attr:function(n,t){return a(this,i.attr,n,t,arguments.length>1)},removeAttr:function(n){return this.each(function(){i.removeAttr(this,n)})}});i.extend({attr:function(n,t,r){var u,f,e=n.nodeType;if(3!==e&&8!==e&&2!==e)return"undefined"==typeof n.getAttribute?i.prop(n,t,r):(1===e&&i.isXMLDoc(n)||(t=t.toLowerCase(),f=i.attrHooks[t]||(i.expr.match.bool.test(t)?bu:void 0)),void 0!==r?null===r?void i.removeAttr(n,t):f&&"set"in f&&void 0!==(u=f.set(n,r,t))?u:(n.setAttribute(t,r+""),r):f&&"get"in f&&null!==(u=f.get(n,t))?u:(u=i.find.attr(n,t),null==u?void 0:u))},attrHooks:{type:{set:function(n,t){if(!f.radioValue&&"radio"===t&&i.nodeName(n,"input")){var r=n.value;return n.setAttribute("type",t),r&&(n.value=r),t}}}},removeAttr:function(n,t){var r,u,e=0,f=t&&t.match(h);if(f&&1===n.nodeType)while(r=f[e++])u=i.propFix[r]||r,i.expr.match.bool.test(r)&&(n[u]=!1),n.removeAttribute(r)}});bu={set:function(n,t,r){return t===!1?i.removeAttr(n,r):n.setAttribute(r,r),r}};i.each(i.expr.match.bool.source.match(/\w+/g),function(n,t){var r=rt[t]||i.find.attr;rt[t]=function(n,t,i){var u,f;return i||(f=rt[t],rt[t]=u,u=null!=r(n,t,i)?t.toLowerCase():null,rt[t]=f),u}});ku=/^(?:input|select|textarea|button)$/i;du=/^(?:a|area)$/i;i.fn.extend({prop:function(n,t){return a(this,i.prop,n,t,arguments.length>1)},removeProp:function(n){return this.each(function(){delete this[i.propFix[n]||n]})}});i.extend({prop:function(n,t,r){var f,u,e=n.nodeType;if(3!==e&&8!==e&&2!==e)return 1===e&&i.isXMLDoc(n)||(t=i.propFix[t]||t,u=i.propHooks[t]),void 0!==r?u&&"set"in u&&void 0!==(f=u.set(n,r,t))?f:n[t]=r:u&&"get"in u&&null!==(f=u.get(n,t))?f:n[t]},propHooks:{tabIndex:{get:function(n){var t=i.find.attr(n,"tabindex");return t?parseInt(t,10):ku.test(n.nodeName)||du.test(n.nodeName)&&n.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}});f.optSelected||(i.propHooks.selected={get:function(n){var t=n.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(n){var t=n.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}});i.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){i.propFix[this.toLowerCase()]=this});gt=/[\t\r\n\f]/g;i.fn.extend({addClass:function(n){var o,t,r,u,f,s,e,c=0;if(i.isFunction(n))return this.each(function(t){i(this).addClass(n.call(this,t,k(this)))});if("string"==typeof n&&n)for(o=n.match(h)||[];t=this[c++];)if(u=k(t),r=1===t.nodeType&&(" "+u+" ").replace(gt," ")){for(s=0;f=o[s++];)r.indexOf(" "+f+" ")<0&&(r+=f+" ");e=i.trim(r);u!==e&&t.setAttribute("class",e)}return this},removeClass:function(n){var o,r,t,u,f,s,e,c=0;if(i.isFunction(n))return this.each(function(t){i(this).removeClass(n.call(this,t,k(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof n&&n)for(o=n.match(h)||[];r=this[c++];)if(u=k(r),t=1===r.nodeType&&(" "+u+" ").replace(gt," ")){for(s=0;f=o[s++];)while(t.indexOf(" "+f+" ")>-1)t=t.replace(" "+f+" "," ");e=i.trim(t);u!==e&&r.setAttribute("class",e)}return this},toggleClass:function(n,t){var u=typeof n;return"boolean"==typeof t&&"string"===u?t?this.addClass(n):this.removeClass(n):i.isFunction(n)?this.each(function(r){i(this).toggleClass(n.call(this,r,k(this),t),t)}):this.each(function(){var t,e,f,o;if("string"===u)for(e=0,f=i(this),o=n.match(h)||[];t=o[e++];)f.hasClass(t)?f.removeClass(t):f.addClass(t);else void 0!==n&&"boolean"!==u||(t=k(this),t&&r.set(this,"__className__",t),this.setAttribute&&this.setAttribute("class",t||n===!1?"":r.get(this,"__className__")||""))})},hasClass:function(n){for(var t,r=0,i=" "+n+" ";t=this[r++];)if(1===t.nodeType&&(" "+k(t)+" ").replace(gt," ").indexOf(i)>-1)return!0;return!1}});gu=/\r/g;nf=/[\x20\t\r\n\f]+/g;i.fn.extend({val:function(n){var t,r,f,u=this[0];return arguments.length?(f=i.isFunction(n),this.each(function(r){var u;1===this.nodeType&&(u=f?n.call(this,r,i(this).val()):n,null==u?u="":"number"==typeof u?u+="":i.isArray(u)&&(u=i.map(u,function(n){return null==n?"":n+""})),t=i.valHooks[this.type]||i.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&void 0!==t.set(this,u,"value")||(this.value=u))})):u?(t=i.valHooks[u.type]||i.valHooks[u.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(r=t.get(u,"value"))?r:(r=u.value,"string"==typeof r?r.replace(gu,""):null==r?"":r)):void 0}});i.extend({valHooks:{option:{get:function(n){var t=i.find.attr(n,"value");return null!=t?t:i.trim(i.text(n)).replace(nf," ")}},select:{get:function(n){for(var o,t,s=n.options,r=n.selectedIndex,u="select-one"===n.type||0>r,h=u?null:[],c=u?r+1:s.length,e=0>r?c:u?r:0;c>e;e++)if(t=s[e],(t.selected||e===r)&&(f.optDisabled?!t.disabled:null===t.getAttribute("disabled"))&&(!t.parentNode.disabled||!i.nodeName(t.parentNode,"optgroup"))){if(o=i(t).val(),u)return o;h.push(o)}return h},set:function(n,t){for(var u,r,f=n.options,e=i.makeArray(t),o=f.length;o--;)r=f[o],(r.selected=i.inArray(i.valHooks.option.get(r),e)>-1)&&(u=!0);return u||(n.selectedIndex=-1),e}}}});i.each(["radio","checkbox"],function(){i.valHooks[this]={set:function(n,t){if(i.isArray(t))return n.checked=i.inArray(i(n).val(),t)>-1}};f.checkOn||(i.valHooks[this].get=function(n){return null===n.getAttribute("value")?"on":n.value})});li=/^(?:focusinfocus|focusoutblur)$/;i.extend(i.event,{trigger:function(t,f,e,o){var w,s,c,b,a,v,l,p=[e||u],h=ft.call(t,"type")?t.type:t,y=ft.call(t,"namespace")?t.namespace.split("."):[];if(s=c=e=e||u,3!==e.nodeType&&8!==e.nodeType&&!li.test(h+i.event.triggered)&&(h.indexOf(".")>-1&&(y=h.split("."),h=y.shift(),y.sort()),a=h.indexOf(":")<0&&"on"+h,t=t[i.expando]?t:new i.Event(h,"object"==typeof t&&t),t.isTrigger=o?2:3,t.namespace=y.join("."),t.rnamespace=t.namespace?new RegExp("(^|\\.)"+y.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=e),f=null==f?[t]:i.makeArray(f,[t]),l=i.event.special[h]||{},o||!l.trigger||l.trigger.apply(e,f)!==!1)){if(!o&&!l.noBubble&&!i.isWindow(e)){for(b=l.delegateType||h,li.test(b+h)||(s=s.parentNode);s;s=s.parentNode)p.push(s),c=s;c===(e.ownerDocument||u)&&p.push(c.defaultView||c.parentWindow||n)}for(w=0;(s=p[w++])&&!t.isPropagationStopped();)t.type=w>1?b:l.bindType||h,v=(r.get(s,"events")||{})[t.type]&&r.get(s,"handle"),v&&v.apply(s,f),v=a&&s[a],v&&v.apply&&g(s)&&(t.result=v.apply(s,f),t.result===!1&&t.preventDefault());return t.type=h,o||t.isDefaultPrevented()||l._default&&l._default.apply(p.pop(),f)!==!1||!g(e)||a&&i.isFunction(e[h])&&!i.isWindow(e)&&(c=e[a],c&&(e[a]=null),i.event.triggered=h,e[h](),i.event.triggered=void 0,c&&(e[a]=c)),t.result}},simulate:function(n,t,r){var u=i.extend(new i.Event,r,{type:n,isSimulated:!0});i.event.trigger(u,null,t);u.isDefaultPrevented()&&r.preventDefault()}});i.fn.extend({trigger:function(n,t){return this.each(function(){i.event.trigger(n,t,this)})},triggerHandler:function(n,t){var r=this[0];if(r)return i.event.trigger(n,t,r,!0)}});i.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(n,t){i.fn[t]=function(n,i){return arguments.length>0?this.on(t,null,n,i):this.trigger(t)}});i.fn.extend({hover:function(n,t){return this.mouseenter(n).mouseleave(t||n)}});f.focusin="onfocusin"in n;f.focusin||i.each({focus:"focusin",blur:"focusout"},function(n,t){var u=function(n){i.event.simulate(t,n.target,i.event.fix(n))};i.event.special[t]={setup:function(){var i=this.ownerDocument||this,f=r.access(i,t);f||i.addEventListener(n,u,!0);r.access(i,t,(f||0)+1)},teardown:function(){var i=this.ownerDocument||this,f=r.access(i,t)-1;f?r.access(i,t,f):(i.removeEventListener(n,u,!0),r.remove(i,t))}}});var ct=n.location,ai=i.now(),vi=/\?/;i.parseJSON=function(n){return n?JSON.parse(n+""):null};i.parseXML=function(t){var r;if(!t||"string"!=typeof t)return null;try{r=(new n.DOMParser).parseFromString(t,"text/xml")}catch(u){r=void 0}return r&&!r.getElementsByTagName("parsererror").length||i.error("Invalid XML: "+t),r};var ve=/#.*$/,tf=/([?&])_=[^&]*/,ye=/^(.*?):[ \t]*([^\r\n]*)$/gm,pe=/^(?:GET|HEAD)$/,we=/^\/\//,rf={},yi={},uf="*/".concat("*"),pi=u.createElement("a");pi.href=ct.href;i.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ct.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(ct.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":uf,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":i.parseJSON,"text xml":i.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(n,t){return t?wi(wi(n,i.ajaxSettings),t):wi(i.ajaxSettings,n)},ajaxPrefilter:ff(rf),ajaxTransport:ff(yi),ajax:function(t,r){function b(t,r,u,h){var a,rt,it,p,b,l=r;2!==s&&(s=2,d&&n.clearTimeout(d),v=void 0,k=h||"",e.readyState=t>0?4:0,a=t>=200&&300>t||304===t,u&&(p=be(f,e,u)),p=ke(f,p,e,a),a?(f.ifModified&&(b=e.getResponseHeader("Last-Modified"),b&&(i.lastModified[o]=b),b=e.getResponseHeader("etag"),b&&(i.etag[o]=b)),204===t||"HEAD"===f.type?l="nocontent":304===t?l="notmodified":(l=p.state,rt=p.data,it=p.error,a=!it)):(it=l,!t&&l||(l="error",0>t&&(t=0))),e.status=t,e.statusText=(r||l)+"",a?nt.resolveWith(c,[rt,l,e]):nt.rejectWith(c,[e,l,it]),e.statusCode(w),w=void 0,y&&g.trigger(a?"ajaxSuccess":"ajaxError",[e,f,a?rt:it]),tt.fireWith(c,[e,l]),y&&(g.trigger("ajaxComplete",[e,f]),--i.active||i.event.trigger("ajaxStop")))}"object"==typeof t&&(r=t,t=void 0);r=r||{};var v,o,k,p,d,l,y,a,f=i.ajaxSetup({},r),c=f.context||f,g=f.context&&(c.nodeType||c.jquery)?i(c):i.event,nt=i.Deferred(),tt=i.Callbacks("once memory"),w=f.statusCode||{},it={},rt={},s=0,ut="canceled",e={readyState:0,getResponseHeader:function(n){var t;if(2===s){if(!p)for(p={};t=ye.exec(k);)p[t[1].toLowerCase()]=t[2];t=p[n.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===s?k:null},setRequestHeader:function(n,t){var i=n.toLowerCase();return s||(n=rt[i]=rt[i]||n,it[n]=t),this},overrideMimeType:function(n){return s||(f.mimeType=n),this},statusCode:function(n){var t;if(n)if(2>s)for(t in n)w[t]=[w[t],n[t]];else e.always(n[e.status]);return this},abort:function(n){var t=n||ut;return v&&v.abort(t),b(0,t),this}};if(nt.promise(e).complete=tt.add,e.success=e.done,e.error=e.fail,f.url=((t||f.url||ct.href)+"").replace(ve,"").replace(we,ct.protocol+"//"),f.type=r.method||r.type||f.method||f.type,f.dataTypes=i.trim(f.dataType||"*").toLowerCase().match(h)||[""],null==f.crossDomain){l=u.createElement("a");try{l.href=f.url;l.href=l.href;f.crossDomain=pi.protocol+"//"+pi.host!=l.protocol+"//"+l.host}catch(ft){f.crossDomain=!0}}if(f.data&&f.processData&&"string"!=typeof f.data&&(f.data=i.param(f.data,f.traditional)),ef(rf,f,r,e),2===s)return e;y=i.event&&f.global;y&&0==i.active++&&i.event.trigger("ajaxStart");f.type=f.type.toUpperCase();f.hasContent=!pe.test(f.type);o=f.url;f.hasContent||(f.data&&(o=f.url+=(vi.test(o)?"&":"?")+f.data,delete f.data),f.cache===!1&&(f.url=tf.test(o)?o.replace(tf,"$1_="+ai++):o+(vi.test(o)?"&":"?")+"_="+ai++));f.ifModified&&(i.lastModified[o]&&e.setRequestHeader("If-Modified-Since",i.lastModified[o]),i.etag[o]&&e.setRequestHeader("If-None-Match",i.etag[o]));(f.data&&f.hasContent&&f.contentType!==!1||r.contentType)&&e.setRequestHeader("Content-Type",f.contentType);e.setRequestHeader("Accept",f.dataTypes[0]&&f.accepts[f.dataTypes[0]]?f.accepts[f.dataTypes[0]]+("*"!==f.dataTypes[0]?", "+uf+"; q=0.01":""):f.accepts["*"]);for(a in f.headers)e.setRequestHeader(a,f.headers[a]);if(f.beforeSend&&(f.beforeSend.call(c,e,f)===!1||2===s))return e.abort();ut="abort";for(a in{success:1,error:1,complete:1})e[a](f[a]);if(v=ef(yi,f,r,e)){if(e.readyState=1,y&&g.trigger("ajaxSend",[e,f]),2===s)return e;f.async&&f.timeout>0&&(d=n.setTimeout(function(){e.abort("timeout")},f.timeout));try{s=1;v.send(it,b)}catch(ft){if(!(2>s))throw ft;b(-1,ft)}}else b(-1,"No Transport");return e},getJSON:function(n,t,r){return i.get(n,t,r,"json")},getScript:function(n,t){return i.get(n,void 0,t,"script")}});i.each(["get","post"],function(n,t){i[t]=function(n,r,u,f){return i.isFunction(r)&&(f=f||u,u=r,r=void 0),i.ajax(i.extend({url:n,type:t,dataType:f,data:r,success:u},i.isPlainObject(n)&&n))}});i._evalUrl=function(n){return i.ajax({url:n,type:"GET",dataType:"script",async:!1,global:!1,throws:!0})};i.fn.extend({wrapAll:function(n){var t;return i.isFunction(n)?this.each(function(t){i(this).wrapAll(n.call(this,t))}):(this[0]&&(t=i(n,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var n=this;n.firstElementChild;)n=n.firstElementChild;return n}).append(this)),this)},wrapInner:function(n){return i.isFunction(n)?this.each(function(t){i(this).wrapInner(n.call(this,t))}):this.each(function(){var t=i(this),r=t.contents();r.length?r.wrapAll(n):t.append(n)})},wrap:function(n){var t=i.isFunction(n);return this.each(function(r){i(this).wrapAll(t?n.call(this,r):n)})},unwrap:function(){return this.parent().each(function(){i.nodeName(this,"body")||i(this).replaceWith(this.childNodes)}).end()}});i.expr.filters.hidden=function(n){return!i.expr.filters.visible(n)};i.expr.filters.visible=function(n){return n.offsetWidth>0||n.offsetHeight>0||n.getClientRects().length>0};var de=/%20/g,ge=/\[\]$/,of=/\r?\n/g,no=/^(?:submit|button|image|reset|file)$/i,to=/^(?:input|select|textarea|keygen)/i;return i.param=function(n,t){var r,u=[],f=function(n,t){t=i.isFunction(t)?t():null==t?"":t;u[u.length]=encodeURIComponent(n)+"="+encodeURIComponent(t)};if(void 0===t&&(t=i.ajaxSettings&&i.ajaxSettings.traditional),i.isArray(n)||n.jquery&&!i.isPlainObject(n))i.each(n,function(){f(this.name,this.value)});else for(r in n)bi(r,n[r],t,f);return u.join("&").replace(de,"+")},i.fn.extend({serialize:function(){return i.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var n=i.prop(this,"elements");return n?i.makeArray(n):this}).filter(function(){var n=this.type;return this.name&&!i(this).is(":disabled")&&to.test(this.nodeName)&&!no.test(n)&&(this.checked||!yr.test(n))}).map(function(n,t){var r=i(this).val();return null==r?null:i.isArray(r)?i.map(r,function(n){return{name:t.name,value:n.replace(of,"\r\n")}}):{name:t.name,value:r.replace(of,"\r\n")}}).get()}}),i.ajaxSettings.xhr=function(){try{return new n.XMLHttpRequest}catch(t){}},sf={0:200,1223:204},ut=i.ajaxSettings.xhr(),f.cors=!!ut&&"withCredentials"in ut,f.ajax=ut=!!ut,i.ajaxTransport(function(t){var i,r;if(f.cors||ut&&!t.crossDomain)return{send:function(u,f){var o,e=t.xhr();if(e.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(o in t.xhrFields)e[o]=t.xhrFields[o];t.mimeType&&e.overrideMimeType&&e.overrideMimeType(t.mimeType);t.crossDomain||u["X-Requested-With"]||(u["X-Requested-With"]="XMLHttpRequest");for(o in u)e.setRequestHeader(o,u[o]);i=function(n){return function(){i&&(i=r=e.onload=e.onerror=e.onabort=e.onreadystatechange=null,"abort"===n?e.abort():"error"===n?"number"!=typeof e.status?f(0,"error"):f(e.status,e.statusText):f(sf[e.status]||e.status,e.statusText,"text"!==(e.responseType||"text")||"string"!=typeof e.responseText?{binary:e.response}:{text:e.responseText},e.getAllResponseHeaders()))}};e.onload=i();r=e.onerror=i("error");void 0!==e.onabort?e.onabort=r:e.onreadystatechange=function(){4===e.readyState&&n.setTimeout(function(){i&&r()})};i=i("abort");try{e.send(t.hasContent&&t.data||null)}catch(s){if(i)throw s;}},abort:function(){i&&i()}}}),i.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(n){return i.globalEval(n),n}}}),i.ajaxPrefilter("script",function(n){void 0===n.cache&&(n.cache=!1);n.crossDomain&&(n.type="GET")}),i.ajaxTransport("script",function(n){if(n.crossDomain){var r,t;return{send:function(f,e){r=i("<script>").prop({charset:n.scriptCharset,src:n.url}).on("load error",t=function(n){r.remove();t=null;n&&e("error"===n.type?404:200,n.type)});u.head.appendChild(r[0])},abort:function(){t&&t()}}}}),ki=[],ni=/(=)\?(?=&|$)|\?\?/,i.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var n=ki.pop()||i.expando+"_"+ai++;return this[n]=!0,n}}),i.ajaxPrefilter("json jsonp",function(t,r,u){var f,e,o,s=t.jsonp!==!1&&(ni.test(t.url)?"url":"string"==typeof t.data&&0===(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&ni.test(t.data)&&"data");if(s||"jsonp"===t.dataTypes[0])return(f=t.jsonpCallback=i.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,s?t[s]=t[s].replace(ni,"$1"+f):t.jsonp!==!1&&(t.url+=(vi.test(t.url)?"&":"?")+t.jsonp+"="+f),t.converters["script json"]=function(){return o||i.error(f+" was not called"),o[0]},t.dataTypes[0]="json",e=n[f],n[f]=function(){o=arguments},u.always(function(){void 0===e?i(n).removeProp(f):n[f]=e;t[f]&&(t.jsonpCallback=r.jsonpCallback,ki.push(f));o&&i.isFunction(e)&&e(o[0]);o=e=void 0}),"script")}),i.parseHTML=function(n,t,r){if(!n||"string"!=typeof n)return null;"boolean"==typeof t&&(r=t,t=!1);t=t||u;var f=rr.exec(n),e=!r&&[];return f?[t.createElement(f[1])]:(f=kr([n],t,e),e&&e.length&&i(e).remove(),i.merge([],f.childNodes))},di=i.fn.load,i.fn.load=function(n,t,r){if("string"!=typeof n&&di)return di.apply(this,arguments);var u,o,s,f=this,e=n.indexOf(" ");return e>-1&&(u=i.trim(n.slice(e)),n=n.slice(0,e)),i.isFunction(t)?(r=t,t=void 0):t&&"object"==typeof t&&(o="POST"),f.length>0&&i.ajax({url:n,type:o||"GET",dataType:"html",data:t}).done(function(n){s=arguments;f.html(u?i("<div>").append(i.parseHTML(n)).find(u):n)}).always(r&&function(n,t){f.each(function(){r.apply(this,s||[n.responseText,t,n])})}),this},i.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(n,t){i.fn[t]=function(n){return this.on(t,n)}}),i.expr.filters.animated=function(n){return i.grep(i.timers,function(t){return n===t.elem}).length},i.offset={setOffset:function(n,t,r){var e,o,s,h,u,c,v,l=i.css(n,"position"),a=i(n),f={};"static"===l&&(n.style.position="relative");u=a.offset();s=i.css(n,"top");c=i.css(n,"left");v=("absolute"===l||"fixed"===l)&&(s+c).indexOf("auto")>-1;v?(e=a.position(),h=e.top,o=e.left):(h=parseFloat(s)||0,o=parseFloat(c)||0);i.isFunction(t)&&(t=t.call(n,r,i.extend({},u)));null!=t.top&&(f.top=t.top-u.top+h);null!=t.left&&(f.left=t.left-u.left+o);"using"in t?t.using.call(n,f):a.css(f)}},i.fn.extend({offset:function(n){if(arguments.length)return void 0===n?this:this.each(function(t){i.offset.setOffset(this,n,t)});var t,f,r=this[0],u={top:0,left:0},e=r&&r.ownerDocument;if(e)return t=e.documentElement,i.contains(t,r)?(u=r.getBoundingClientRect(),f=hf(e),{top:u.top+f.pageYOffset-t.clientTop,left:u.left+f.pageXOffset-t.clientLeft}):u},position:function(){if(this[0]){var n,r,u=this[0],t={top:0,left:0};return"fixed"===i.css(u,"position")?r=u.getBoundingClientRect():(n=this.offsetParent(),r=this.offset(),i.nodeName(n[0],"html")||(t=n.offset()),t.top+=i.css(n[0],"borderTopWidth",!0),t.left+=i.css(n[0],"borderLeftWidth",!0)),{top:r.top-t.top-i.css(u,"marginTop",!0),left:r.left-t.left-i.css(u,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var n=this.offsetParent;n&&"static"===i.css(n,"position");)n=n.offsetParent;return n||ht})}}),i.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(n,t){var r="pageYOffset"===t;i.fn[n]=function(i){return a(this,function(n,i,u){var f=hf(n);return void 0===u?f?f[t]:n[i]:void(f?f.scrollTo(r?f.pageXOffset:u,r?u:f.pageYOffset):n[i]=u)},n,i,arguments.length)}}),i.each(["top","left"],function(n,t){i.cssHooks[t]=ci(f.pixelPosition,function(n,r){if(r)return(r=tt(n,t),si.test(r)?i(n).position()[t]+"px":r)})}),i.each({Height:"height",Width:"width"},function(n,t){i.each({padding:"inner"+n,content:t,"":"outer"+n},function(r,u){i.fn[u]=function(u,f){var e=arguments.length&&(r||"boolean"!=typeof u),o=r||(u===!0||f===!0?"margin":"border");return a(this,function(t,r,u){var f;return i.isWindow(t)?t.document.documentElement["client"+n]:9===t.nodeType?(f=t.documentElement,Math.max(t.body["scroll"+n],f["scroll"+n],t.body["offset"+n],f["offset"+n],f["client"+n])):void 0===u?i.css(t,r,o):i.style(t,r,u,o)},t,e?u:void 0,e,null)}})}),i.fn.extend({bind:function(n,t,i){return this.on(n,null,t,i)},unbind:function(n,t){return this.off(n,null,t)},delegate:function(n,t,i,r){return this.on(t,n,i,r)},undelegate:function(n,t,i){return 1===arguments.length?this.off(n,"**"):this.off(t,n||"**",i)},size:function(){return this.length}}),i.fn.andSelf=i.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return i}),cf=n.jQuery,lf=n.$,i.noConflict=function(t){return n.$===i&&(n.$=lf),t&&n.jQuery===i&&(n.jQuery=cf),i},t||(n.jQuery=n.$=i),i});
(function ($, undefined) { $.ui = $.ui || {}; if ($.ui.version) { return } $.extend($.ui, { version: "1.8.22", keyCode: { ALT: 18, BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108, NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91 } }); $.fn.extend({ propAttr: $.fn.prop || $.fn.attr, _focus: $.fn.focus, focus: function (delay, fn) { return typeof delay === "number" ? this.each(function () { var elem = this; setTimeout(function () { $(elem).focus(); if (fn) { fn.call(elem) } }, delay) }) : this._focus.apply(this, arguments) }, scrollParent: function () { var scrollParent; if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) { scrollParent = this.parents().filter(function () { return (/(relative|absolute|fixed)/).test($.curCSS(this, 'position', 1)) && (/(auto|scroll)/).test($.curCSS(this, 'overflow', 1) + $.curCSS(this, 'overflow-y', 1) + $.curCSS(this, 'overflow-x', 1)) }).eq(0) } else { scrollParent = this.parents().filter(function () { return (/(auto|scroll)/).test($.curCSS(this, 'overflow', 1) + $.curCSS(this, 'overflow-y', 1) + $.curCSS(this, 'overflow-x', 1)) }).eq(0) } return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent }, zIndex: function (zIndex) { if (zIndex !== undefined) { return this.css("zIndex", zIndex) } if (this.length) { var elem = $(this[0]), position, value; while (elem.length && elem[0] !== document) { position = elem.css("position"); if (position === "absolute" || position === "relative" || position === "fixed") { value = parseInt(elem.css("zIndex"), 10); if (!isNaN(value) && value !== 0) { return value } } elem = elem.parent() } } return 0 }, disableSelection: function () { return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function (event) { event.preventDefault() }) }, enableSelection: function () { return this.unbind(".ui-disableSelection") } }); if (!$("<a>").outerWidth(1).jquery) { $.each(["Width", "Height"], function (i, name) { var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"], type = name.toLowerCase(), orig = { innerWidth: $.fn.innerWidth, innerHeight: $.fn.innerHeight, outerWidth: $.fn.outerWidth, outerHeight: $.fn.outerHeight }; function reduce(elem, size, border, margin) { $.each(side, function () { size -= parseFloat($.curCSS(elem, "padding" + this, true)) || 0; if (border) { size -= parseFloat($.curCSS(elem, "border" + this + "Width", true)) || 0 } if (margin) { size -= parseFloat($.curCSS(elem, "margin" + this, true)) || 0 } }); return size } $.fn["inner" + name] = function (size) { if (size === undefined) { return orig["inner" + name].call(this) } return this.each(function () { $(this).css(type, reduce(this, size) + "px") }) }; $.fn["outer" + name] = function (size, margin) { if (typeof size !== "number") { return orig["outer" + name].call(this, size) } return this.each(function () { $(this).css(type, reduce(this, size, true, margin) + "px") }) } }) } function focusable(element, isTabIndexNotNaN) { var nodeName = element.nodeName.toLowerCase(); if ("area" === nodeName) { var map = element.parentNode, mapName = map.name, img; if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") { return false } img = $("img[usemap=#" + mapName + "]")[0]; return !!img && visible(img) } return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" == nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element) } function visible(element) { return !$(element).parents().andSelf().filter(function () { return $.curCSS(this, "visibility") === "hidden" || $.expr.filters.hidden(this) }).length } $.extend($.expr[":"], { data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) { return function (elem) { return !!$.data(elem, dataName) } }) : function (elem, i, match) { return !!$.data(elem, match[3]) }, focusable: function (element) { return focusable(element, !isNaN($.attr(element, "tabindex"))) }, tabbable: function (element) { var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex); return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN) } }); $(function () { var body = document.body, div = body.appendChild(div = document.createElement("div")); div.offsetHeight; $.extend(div.style, { minHeight: "100px", height: "auto", padding: 0, borderWidth: 0 }); $.support.minHeight = div.offsetHeight === 100; $.support.selectstart = "onselectstart" in div; body.removeChild(div).style.display = "none" }); if (!$.curCSS) { $.curCSS = $.css } $.extend($.ui, { plugin: { add: function (module, option, set) { var proto = $.ui[module].prototype; for (var i in set) { proto.plugins[i] = proto.plugins[i] || []; proto.plugins[i].push([option, set[i]]) } }, call: function (instance, name, args) { var set = instance.plugins[name]; if (!set || !instance.element[0].parentNode) { return } for (var i = 0; i < set.length; i++) { if (instance.options[set[i][0]]) { set[i][1].apply(instance.element, args) } } } }, contains: function (a, b) { return document.compareDocumentPosition ? a.compareDocumentPosition(b) & 16 : a !== b && a.contains(b) }, hasScroll: function (el, a) { if ($(el).css("overflow") === "hidden") { return false } var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop", has = false; if (el[scroll] > 0) { return true } el[scroll] = 1; has = (el[scroll] > 0); el[scroll] = 0; return has }, isOverAxis: function (x, reference, size) { return (x > reference) && (x < (reference + size)) }, isOver: function (y, x, top, left, height, width) { return $.ui.isOverAxis(y, top, height) && $.ui.isOverAxis(x, left, width) } }) })(jQuery); (function ($, undefined) { if ($.cleanData) { var _cleanData = $.cleanData; $.cleanData = function (elems) { for (var i = 0, elem; (elem = elems[i]) != null; i++) { try { $(elem).triggerHandler("remove") } catch (e) { } } _cleanData(elems) } } else { var _remove = $.fn.remove; $.fn.remove = function (selector, keepData) { return this.each(function () { if (!keepData) { if (!selector || $.filter(selector, [this]).length) { $("*", this).add([this]).each(function () { try { $(this).triggerHandler("remove") } catch (e) { } }) } } return _remove.call($(this), selector, keepData) }) } } $.widget = function (name, base, prototype) { var namespace = name.split(".")[0], fullName; name = name.split(".")[1]; fullName = namespace + "-" + name; if (!prototype) { prototype = base; base = $.Widget } $.expr[":"][fullName] = function (elem) { return !!$.data(elem, name) }; $[namespace] = $[namespace] || {}; $[namespace][name] = function (options, element) { if (arguments.length) { this._createWidget(options, element) } }; var basePrototype = new base(); basePrototype.options = $.extend(true, {}, basePrototype.options); $[namespace][name].prototype = $.extend(true, basePrototype, { namespace: namespace, widgetName: name, widgetEventPrefix: $[namespace][name].prototype.widgetEventPrefix || name, widgetBaseClass: fullName }, prototype); $.widget.bridge(name, $[namespace][name]) }; $.widget.bridge = function (name, object) { $.fn[name] = function (options) { var isMethodCall = typeof options === "string", args = Array.prototype.slice.call(arguments, 1), returnValue = this; options = !isMethodCall && args.length ? $.extend.apply(null, [true, options].concat(args)) : options; if (isMethodCall && options.charAt(0) === "_") { return returnValue } if (isMethodCall) { this.each(function () { var instance = $.data(this, name), methodValue = instance && $.isFunction(instance[options]) ? instance[options].apply(instance, args) : instance; if (methodValue !== instance && methodValue !== undefined) { returnValue = methodValue; return false } }) } else { this.each(function () { var instance = $.data(this, name); if (instance) { instance.option(options || {})._init() } else { $.data(this, name, new object(options, this)) } }) } return returnValue } }; $.Widget = function (options, element) { if (arguments.length) { this._createWidget(options, element) } }; $.Widget.prototype = { widgetName: "widget", widgetEventPrefix: "", options: { disabled: false }, _createWidget: function (options, element) { $.data(element, this.widgetName, this); this.element = $(element); this.options = $.extend(true, {}, this.options, this._getCreateOptions(), options); var self = this; this.element.bind("remove." + this.widgetName, function () { self.destroy() }); this._create(); this._trigger("create"); this._init() }, _getCreateOptions: function () { return $.metadata && $.metadata.get(this.element[0])[this.widgetName] }, _create: function () { }, _init: function () { }, destroy: function () { this.element.unbind("." + this.widgetName).removeData(this.widgetName); this.widget().unbind("." + this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass + "-disabled " + "ui-state-disabled") }, widget: function () { return this.element }, option: function (key, value) { var options = key; if (arguments.length === 0) { return $.extend({}, this.options) } if (typeof key === "string") { if (value === undefined) { return this.options[key] } options = {}; options[key] = value } this._setOptions(options); return this }, _setOptions: function (options) { var self = this; $.each(options, function (key, value) { self._setOption(key, value) }); return this }, _setOption: function (key, value) { this.options[key] = value; if (key === "disabled") { this.widget()[value ? "addClass" : "removeClass"](this.widgetBaseClass + "-disabled" + " " + "ui-state-disabled").attr("aria-disabled", value) } return this }, enable: function () { return this._setOption("disabled", false) }, disable: function () { return this._setOption("disabled", true) }, _trigger: function (type, event, data) { var prop, orig, callback = this.options[type]; data = data || {}; event = $.Event(event); event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(); event.target = this.element[0]; orig = event.originalEvent; if (orig) { for (prop in orig) { if (!(prop in event)) { event[prop] = orig[prop] } } } this.element.trigger(event, data); return !($.isFunction(callback) && callback.call(this.element[0], event, data) === false || event.isDefaultPrevented()) } } })(jQuery); (function ($, undefined) { var mouseHandled = false; $(document).mouseup(function (e) { mouseHandled = false }); $.widget("ui.mouse", { options: { cancel: ':input,option', distance: 1, delay: 0 }, _mouseInit: function () { var self = this; this.element.bind('mousedown.' + this.widgetName, function (event) { return self._mouseDown(event) }).bind('click.' + this.widgetName, function (event) { if (true === $.data(event.target, self.widgetName + '.preventClickEvent')) { $.removeData(event.target, self.widgetName + '.preventClickEvent'); event.stopImmediatePropagation(); return false } }); this.started = false }, _mouseDestroy: function () { this.element.unbind('.' + this.widgetName); $(document).unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate).unbind('mouseup.' + this.widgetName, this._mouseUpDelegate) }, _mouseDown: function (event) { if (mouseHandled) { return }; (this._mouseStarted && this._mouseUp(event)); this._mouseDownEvent = event; var self = this, btnIsLeft = (event.which == 1), elIsCancel = (typeof this.options.cancel == "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false); if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) { return true } this.mouseDelayMet = !this.options.delay; if (!this.mouseDelayMet) { this._mouseDelayTimer = setTimeout(function () { self.mouseDelayMet = true }, this.options.delay) } if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) { this._mouseStarted = (this._mouseStart(event) !== false); if (!this._mouseStarted) { event.preventDefault(); return true } } if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) { $.removeData(event.target, this.widgetName + '.preventClickEvent') } this._mouseMoveDelegate = function (event) { return self._mouseMove(event) }; this._mouseUpDelegate = function (event) { return self._mouseUp(event) }; $(document).bind('mousemove.' + this.widgetName, this._mouseMoveDelegate).bind('mouseup.' + this.widgetName, this._mouseUpDelegate); event.preventDefault(); mouseHandled = true; return true }, _mouseMove: function (event) { if ($.browser.msie && !(document.documentMode >= 9) && !event.button) { return this._mouseUp(event) } if (this._mouseStarted) { this._mouseDrag(event); return event.preventDefault() } if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) { this._mouseStarted = (this._mouseStart(this._mouseDownEvent, event) !== false); (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)) } return !this._mouseStarted }, _mouseUp: function (event) { $(document).unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate).unbind('mouseup.' + this.widgetName, this._mouseUpDelegate); if (this._mouseStarted) { this._mouseStarted = false; if (event.target == this._mouseDownEvent.target) { $.data(event.target, this.widgetName + '.preventClickEvent', true) } this._mouseStop(event) } return false }, _mouseDistanceMet: function (event) { return (Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance) }, _mouseDelayMet: function (event) { return this.mouseDelayMet }, _mouseStart: function (event) { }, _mouseDrag: function (event) { }, _mouseStop: function (event) { }, _mouseCapture: function (event) { return true } }) })(jQuery); (function ($, undefined) { $.widget("ui.draggable", $.ui.mouse, { widgetEventPrefix: "drag", options: { addClasses: true, appendTo: "parent", axis: false, connectToSortable: false, containment: false, cursor: "auto", cursorAt: false, grid: false, handle: false, helper: "original", iframeFix: false, opacity: false, refreshPositions: false, revert: false, revertDuration: 500, scope: "default", scroll: true, scrollSensitivity: 20, scrollSpeed: 20, snap: false, snapMode: "both", snapTolerance: 20, stack: false, zIndex: false }, _create: function () { if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position"))) this.element[0].style.position = 'relative'; (this.options.addClasses && this.element.addClass("ui-draggable")); (this.options.disabled && this.element.addClass("ui-draggable-disabled")); this._mouseInit() }, destroy: function () { if (!this.element.data('draggable')) return; this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable" + " ui-draggable-dragging" + " ui-draggable-disabled"); this._mouseDestroy(); return this }, _mouseCapture: function (event) { var o = this.options; if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle')) return false; this.handle = this._getHandle(event); if (!this.handle) return false; if (o.iframeFix) { $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function () { $('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({ width: this.offsetWidth + "px", height: this.offsetHeight + "px", position: "absolute", opacity: "0.001", zIndex: 1000 }).css($(this).offset()).appendTo("body") }) } return true }, _mouseStart: function (event) { var o = this.options; this.helper = this._createHelper(event); this.helper.addClass("ui-draggable-dragging"); this._cacheHelperProportions(); if ($.ui.ddmanager) $.ui.ddmanager.current = this; this._cacheMargins(); this.cssPosition = this.helper.css("position"); this.scrollParent = this.helper.scrollParent(); this.offset = this.positionAbs = this.element.offset(); this.offset = { top: this.offset.top - this.margins.top, left: this.offset.left - this.margins.left }; $.extend(this.offset, { click: { left: event.pageX - this.offset.left, top: event.pageY - this.offset.top }, parent: this._getParentOffset(), relative: this._getRelativeOffset() }); this.originalPosition = this.position = this._generatePosition(event); this.originalPageX = event.pageX; this.originalPageY = event.pageY; (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt)); if (o.containment) this._setContainment(); if (this._trigger("start", event) === false) { this._clear(); return false } this._cacheHelperProportions(); if ($.ui.ddmanager && !o.dropBehaviour) $.ui.ddmanager.prepareOffsets(this, event); this._mouseDrag(event, true); if ($.ui.ddmanager) $.ui.ddmanager.dragStart(this, event); return true }, _mouseDrag: function (event, noPropagation) { this.position = this._generatePosition(event); this.positionAbs = this._convertPositionTo("absolute"); if (!noPropagation) { var ui = this._uiHash(); if (this._trigger('drag', event, ui) === false) { this._mouseUp({}); return false } this.position = ui.position } if (!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left + 'px'; if (!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top + 'px'; if ($.ui.ddmanager) $.ui.ddmanager.drag(this, event); return false }, _mouseStop: function (event) { var dropped = false; if ($.ui.ddmanager && !this.options.dropBehaviour) dropped = $.ui.ddmanager.drop(this, event); if (this.dropped) { dropped = this.dropped; this.dropped = false } var element = this.element[0], elementInDom = false; while (element && (element = element.parentNode)) { if (element == document) { elementInDom = true } } if (!elementInDom && this.options.helper === "original") return false; if ((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) { var self = this; $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () { if (self._trigger("stop", event) !== false) { self._clear() } }) } else { if (this._trigger("stop", event) !== false) { this._clear() } } return false }, _mouseUp: function (event) { if (this.options.iframeFix === true) { $("div.ui-draggable-iframeFix").each(function () { this.parentNode.removeChild(this) }) } if ($.ui.ddmanager) $.ui.ddmanager.dragStop(this, event); return $.ui.mouse.prototype._mouseUp.call(this, event) }, cancel: function () { if (this.helper.is(".ui-draggable-dragging")) { this._mouseUp({}) } else { this._clear() } return this }, _getHandle: function (event) { var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false; $(this.options.handle, this.element).find("*").andSelf().each(function () { if (this == event.target) handle = true }); return handle }, _createHelper: function (event) { var o = this.options; var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element); if (!helper.parents('body').length) helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo)); if (helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) helper.css("position", "absolute"); return helper }, _adjustOffsetFromHelper: function (obj) { if (typeof obj == 'string') { obj = obj.split(' ') } if ($.isArray(obj)) { obj = { left: +obj[0], top: +obj[1] || 0 } } if ('left' in obj) { this.offset.click.left = obj.left + this.margins.left } if ('right' in obj) { this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left } if ('top' in obj) { this.offset.click.top = obj.top + this.margins.top } if ('bottom' in obj) { this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top } }, _getParentOffset: function () { this.offsetParent = this.helper.offsetParent(); var po = this.offsetParent.offset(); if (this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) { po.left += this.scrollParent.scrollLeft(); po.top += this.scrollParent.scrollTop() } if ((this.offsetParent[0] == document.body) || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) po = { top: 0, left: 0 }; return { top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0), left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0) } }, _getRelativeOffset: function () { if (this.cssPosition == "relative") { var p = this.element.position(); return { top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(), left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft() } } else { return { top: 0, left: 0 } } }, _cacheMargins: function () { this.margins = { left: (parseInt(this.element.css("marginLeft"), 10) || 0), top: (parseInt(this.element.css("marginTop"), 10) || 0), right: (parseInt(this.element.css("marginRight"), 10) || 0), bottom: (parseInt(this.element.css("marginBottom"), 10) || 0) } }, _cacheHelperProportions: function () { this.helperProportions = { width: this.helper.outerWidth(), height: this.helper.outerHeight() } }, _setContainment: function () { var o = this.options; if (o.containment == 'parent') o.containment = this.helper[0].parentNode; if (o.containment == 'document' || o.containment == 'window') this.containment = [o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, (o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left, (o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]; if (!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) { var c = $(o.containment); var ce = c[0]; if (!ce) return; var co = c.offset(); var over = ($(ce).css("overflow") != 'hidden'); this.containment = [(parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0), (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0), (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom]; this.relative_container = c } else if (o.containment.constructor == Array) { this.containment = o.containment } }, _convertPositionTo: function (d, pos) { if (!pos) pos = this.position; var mod = d == "absolute" ? 1 : -1; var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName); return { top: (pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : (this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)), left: (pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : (this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod)) } }, _generatePosition: function (event) { var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName); var pageX = event.pageX; var pageY = event.pageY; if (this.originalPosition) { var containment; if (this.containment) { if (this.relative_container) { var co = this.relative_container.offset(); containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top] } else { containment = this.containment } if (event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left; if (event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top; if (event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left; if (event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top } if (o.grid) { var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY; pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top; var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX; pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left } } return { top: (pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : (this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))), left: (pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : (this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()))) } }, _clear: function () { this.helper.removeClass("ui-draggable-dragging"); if (this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove(); this.helper = null; this.cancelHelperRemoval = false }, _trigger: function (type, event, ui) { ui = ui || this._uiHash(); $.ui.plugin.call(this, type, [event, ui]); if (type == "drag") this.positionAbs = this._convertPositionTo("absolute"); return $.Widget.prototype._trigger.call(this, type, event, ui) }, plugins: {}, _uiHash: function (event) { return { helper: this.helper, position: this.position, originalPosition: this.originalPosition, offset: this.positionAbs } } }); $.extend($.ui.draggable, { version: "1.8.22" }); $.ui.plugin.add("draggable", "connectToSortable", { start: function (event, ui) { var inst = $(this).data("draggable"), o = inst.options, uiSortable = $.extend({}, ui, { item: inst.element }); inst.sortables = []; $(o.connectToSortable).each(function () { var sortable = $.data(this, 'sortable'); if (sortable && !sortable.options.disabled) { inst.sortables.push({ instance: sortable, shouldRevert: sortable.options.revert }); sortable.refreshPositions(); sortable._trigger("activate", event, uiSortable) } }) }, stop: function (event, ui) { var inst = $(this).data("draggable"), uiSortable = $.extend({}, ui, { item: inst.element }); $.each(inst.sortables, function () { if (this.instance.isOver) { this.instance.isOver = 0; inst.cancelHelperRemoval = true; this.instance.cancelHelperRemoval = false; if (this.shouldRevert) this.instance.options.revert = true; this.instance._mouseStop(event); this.instance.options.helper = this.instance.options._helper; if (inst.options.helper == 'original') this.instance.currentItem.css({ top: 'auto', left: 'auto' }) } else { this.instance.cancelHelperRemoval = false; this.instance._trigger("deactivate", event, uiSortable) } }) }, drag: function (event, ui) { var inst = $(this).data("draggable"), self = this; var checkPos = function (o) { var dyClick = this.offset.click.top, dxClick = this.offset.click.left; var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left; var itemHeight = o.height, itemWidth = o.width; var itemTop = o.top, itemLeft = o.left; return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth) }; $.each(inst.sortables, function (i) { this.instance.positionAbs = inst.positionAbs; this.instance.helperProportions = inst.helperProportions; this.instance.offset.click = inst.offset.click; if (this.instance._intersectsWith(this.instance.containerCache)) { if (!this.instance.isOver) { this.instance.isOver = 1; this.instance.currentItem = $(self).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true); this.instance.options._helper = this.instance.options.helper; this.instance.options.helper = function () { return ui.helper[0] }; event.target = this.instance.currentItem[0]; this.instance._mouseCapture(event, true); this.instance._mouseStart(event, true, true); this.instance.offset.click.top = inst.offset.click.top; this.instance.offset.click.left = inst.offset.click.left; this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left; this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top; inst._trigger("toSortable", event); inst.dropped = this.instance.element; inst.currentItem = inst.element; this.instance.fromOutside = inst } if (this.instance.currentItem) this.instance._mouseDrag(event) } else { if (this.instance.isOver) { this.instance.isOver = 0; this.instance.cancelHelperRemoval = true; this.instance.options.revert = false; this.instance._trigger('out', event, this.instance._uiHash(this.instance)); this.instance._mouseStop(event, true); this.instance.options.helper = this.instance.options._helper; this.instance.currentItem.remove(); if (this.instance.placeholder) this.instance.placeholder.remove(); inst._trigger("fromSortable", event); inst.dropped = false } } }) } }); $.ui.plugin.add("draggable", "cursor", { start: function (event, ui) { var t = $('body'), o = $(this).data('draggable').options; if (t.css("cursor")) o._cursor = t.css("cursor"); t.css("cursor", o.cursor) }, stop: function (event, ui) { var o = $(this).data('draggable').options; if (o._cursor) $('body').css("cursor", o._cursor) } }); $.ui.plugin.add("draggable", "opacity", { start: function (event, ui) { var t = $(ui.helper), o = $(this).data('draggable').options; if (t.css("opacity")) o._opacity = t.css("opacity"); t.css('opacity', o.opacity) }, stop: function (event, ui) { var o = $(this).data('draggable').options; if (o._opacity) $(ui.helper).css('opacity', o._opacity) } }); $.ui.plugin.add("draggable", "scroll", { start: function (event, ui) { var i = $(this).data("draggable"); if (i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset() }, drag: function (event, ui) { var i = $(this).data("draggable"), o = i.options, scrolled = false; if (i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') { if (!o.axis || o.axis != 'x') { if ((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed; else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed } if (!o.axis || o.axis != 'y') { if ((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed; else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed } } else { if (!o.axis || o.axis != 'x') { if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed); else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed) } if (!o.axis || o.axis != 'y') { if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed); else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed) } } if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) $.ui.ddmanager.prepareOffsets(i, event) } }); $.ui.plugin.add("draggable", "snap", { start: function (event, ui) { var i = $(this).data("draggable"), o = i.options; i.snapElements = []; $(o.snap.constructor != String ? (o.snap.items || ':data(draggable)') : o.snap).each(function () { var $t = $(this); var $o = $t.offset(); if (this != i.element[0]) i.snapElements.push({ item: this, width: $t.outerWidth(), height: $t.outerHeight(), top: $o.top, left: $o.left }) }) }, drag: function (event, ui) { var inst = $(this).data("draggable"), o = inst.options; var d = o.snapTolerance; var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height; for (var i = inst.snapElements.length - 1; i >= 0; i--) { var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width, t = inst.snapElements[i].top, b = t + inst.snapElements[i].height; if (!((l - d < x1 && x1 < r + d && t - d < y1 && y1 < b + d) || (l - d < x1 && x1 < r + d && t - d < y2 && y2 < b + d) || (l - d < x2 && x2 < r + d && t - d < y1 && y1 < b + d) || (l - d < x2 && x2 < r + d && t - d < y2 && y2 < b + d))) { if (inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }))); inst.snapElements[i].snapping = false; continue } if (o.snapMode != 'inner') { var ts = Math.abs(t - y2) <= d; var bs = Math.abs(b - y1) <= d; var ls = Math.abs(l - x2) <= d; var rs = Math.abs(r - x1) <= d; if (ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top; if (bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top; if (ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left; if (rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left } var first = (ts || bs || ls || rs); if (o.snapMode != 'outer') { var ts = Math.abs(t - y1) <= d; var bs = Math.abs(b - y2) <= d; var ls = Math.abs(l - x1) <= d; var rs = Math.abs(r - x2) <= d; if (ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top; if (bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top; if (ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left; if (rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left } if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }))); inst.snapElements[i].snapping = (ts || bs || ls || rs || first) } } }); $.ui.plugin.add("draggable", "stack", { start: function (event, ui) { var o = $(this).data("draggable").options; var group = $.makeArray($(o.stack)).sort(function (a, b) { return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0) }); if (!group.length) { return } var min = parseInt(group[0].style.zIndex) || 0; $(group).each(function (i) { this.style.zIndex = min + i }); this[0].style.zIndex = min + group.length } }); $.ui.plugin.add("draggable", "zIndex", { start: function (event, ui) { var t = $(ui.helper), o = $(this).data("draggable").options; if (t.css("zIndex")) o._zIndex = t.css("zIndex"); t.css('zIndex', o.zIndex) }, stop: function (event, ui) { var o = $(this).data("draggable").options; if (o._zIndex) $(ui.helper).css('zIndex', o._zIndex) } }) })(jQuery); (function ($, undefined) { $.widget("ui.droppable", { widgetEventPrefix: "drop", options: { accept: '*', activeClass: false, addClasses: true, greedy: false, hoverClass: false, scope: 'default', tolerance: 'intersect' }, _create: function () { var o = this.options, accept = o.accept; this.isover = 0; this.isout = 1; this.accept = $.isFunction(accept) ? accept : function (d) { return d.is(accept) }; this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight }; $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || []; $.ui.ddmanager.droppables[o.scope].push(this); (o.addClasses && this.element.addClass("ui-droppable")) }, destroy: function () { var drop = $.ui.ddmanager.droppables[this.options.scope]; for (var i = 0; i < drop.length; i++) if (drop[i] == this) drop.splice(i, 1); this.element.removeClass("ui-droppable ui-droppable-disabled").removeData("droppable").unbind(".droppable"); return this }, _setOption: function (key, value) { if (key == 'accept') { this.accept = $.isFunction(value) ? value : function (d) { return d.is(value) } } $.Widget.prototype._setOption.apply(this, arguments) }, _activate: function (event) { var draggable = $.ui.ddmanager.current; if (this.options.activeClass) this.element.addClass(this.options.activeClass); (draggable && this._trigger('activate', event, this.ui(draggable))) }, _deactivate: function (event) { var draggable = $.ui.ddmanager.current; if (this.options.activeClass) this.element.removeClass(this.options.activeClass); (draggable && this._trigger('deactivate', event, this.ui(draggable))) }, _over: function (event) { var draggable = $.ui.ddmanager.current; if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) { if (this.options.hoverClass) this.element.addClass(this.options.hoverClass); this._trigger('over', event, this.ui(draggable)) } }, _out: function (event) { var draggable = $.ui.ddmanager.current; if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) { if (this.options.hoverClass) this.element.removeClass(this.options.hoverClass); this._trigger('out', event, this.ui(draggable)) } }, _drop: function (event, custom) { var draggable = custom || $.ui.ddmanager.current; if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; var childrenIntersection = false; this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function () { var inst = $.data(this, 'droppable'); if (inst.options.greedy && !inst.options.disabled && inst.options.scope == draggable.options.scope && inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) && $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)) { childrenIntersection = true; return false } }); if (childrenIntersection) return false; if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) { if (this.options.activeClass) this.element.removeClass(this.options.activeClass); if (this.options.hoverClass) this.element.removeClass(this.options.hoverClass); this._trigger('drop', event, this.ui(draggable)); return this.element } return false }, ui: function (c) { return { draggable: (c.currentItem || c.element), helper: c.helper, position: c.position, offset: c.positionAbs } } }); $.extend($.ui.droppable, { version: "1.8.22" }); $.ui.intersect = function (draggable, droppable, toleranceMode) { if (!droppable.offset) return false; var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width, y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height; var l = droppable.offset.left, r = l + droppable.proportions.width, t = droppable.offset.top, b = t + droppable.proportions.height; switch (toleranceMode) { case 'fit': return (l <= x1 && x2 <= r && t <= y1 && y2 <= b); break; case 'intersect': return (l < x1 + (draggable.helperProportions.width / 2) && x2 - (draggable.helperProportions.width / 2) < r && t < y1 + (draggable.helperProportions.height / 2) && y2 - (draggable.helperProportions.height / 2) < b); break; case 'pointer': var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left), draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top), isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width); return isOver; break; case 'touch': return ((y1 >= t && y1 <= b) || (y2 >= t && y2 <= b) || (y1 < t && y2 > b)) && ((x1 >= l && x1 <= r) || (x2 >= l && x2 <= r) || (x1 < l && x2 > r)); break; default: return false; break } }; $.ui.ddmanager = { current: null, droppables: { 'default': [] }, prepareOffsets: function (t, event) { var m = $.ui.ddmanager.droppables[t.options.scope] || []; var type = event ? event.type : null; var list = (t.currentItem || t.element).find(":data(droppable)").andSelf(); droppablesLoop: for (var i = 0; i < m.length; i++) { if (m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0], (t.currentItem || t.element)))) continue; for (var j = 0; j < list.length; j++) { if (list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop } }; m[i].visible = m[i].element.css("display") != "none"; if (!m[i].visible) continue; if (type == "mousedown") m[i]._activate.call(m[i], event); m[i].offset = m[i].element.offset(); m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight } } }, drop: function (draggable, event) { var dropped = false; $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () { if (!this.options) return; if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) dropped = this._drop.call(this, event) || dropped; if (!this.options.disabled && this.visible && this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) { this.isout = 1; this.isover = 0; this._deactivate.call(this, event) } }); return dropped }, dragStart: function (draggable, event) { draggable.element.parents(":not(body,html)").bind("scroll.droppable", function () { if (!draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event) }) }, drag: function (draggable, event) { if (draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event); $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () { if (this.options.disabled || this.greedyChild || !this.visible) return; var intersects = $.ui.intersect(draggable, this, this.options.tolerance); var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null); if (!c) return; var parentInstance; if (this.options.greedy) { var parent = this.element.parents(':data(droppable):eq(0)'); if (parent.length) { parentInstance = $.data(parent[0], 'droppable'); parentInstance.greedyChild = (c == 'isover' ? 1 : 0) } } if (parentInstance && c == 'isover') { parentInstance['isover'] = 0; parentInstance['isout'] = 1; parentInstance._out.call(parentInstance, event) } this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0; this[c == "isover" ? "_over" : "_out"].call(this, event); if (parentInstance && c == 'isout') { parentInstance['isout'] = 0; parentInstance['isover'] = 1; parentInstance._over.call(parentInstance, event) } }) }, dragStop: function (draggable, event) { draggable.element.parents(":not(body,html)").unbind("scroll.droppable"); if (!draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event) } } })(jQuery); (function ($, undefined) { $.widget("ui.resizable", $.ui.mouse, { widgetEventPrefix: "resize", options: { alsoResize: false, animate: false, animateDuration: "slow", animateEasing: "swing", aspectRatio: false, autoHide: false, containment: false, ghost: false, grid: false, handles: "e,s,se", helper: false, maxHeight: null, maxWidth: null, minHeight: 10, minWidth: 10, zIndex: 1000 }, _create: function () { var self = this, o = this.options; this.element.addClass("ui-resizable"); $.extend(this, { _aspectRatio: !!(o.aspectRatio), aspectRatio: o.aspectRatio, originalElement: this.element, _proportionallyResizeElements: [], _helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null }); if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) { this.element.wrap($('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({ position: this.element.css('position'), width: this.element.outerWidth(), height: this.element.outerHeight(), top: this.element.css('top'), left: this.element.css('left') })); this.element = this.element.parent().data("resizable", this.element.data('resizable')); this.elementIsWrapper = true; this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") }); this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0 }); this.originalResizeStyle = this.originalElement.css('resize'); this.originalElement.css('resize', 'none'); this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' })); this.originalElement.css({ margin: this.originalElement.css('margin') }); this._proportionallyResize() } this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' }); if (this.handles.constructor == String) { if (this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw'; var n = this.handles.split(","); this.handles = {}; for (var i = 0; i < n.length; i++) { var handle = $.trim(n[i]), hname = 'ui-resizable-' + handle; var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>'); axis.css({ zIndex: o.zIndex }); if ('se' == handle) { axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se') }; this.handles[handle] = '.ui-resizable-' + handle; this.element.append(axis) } } this._renderAxis = function (target) { target = target || this.element; for (var i in this.handles) { if (this.handles[i].constructor == String) this.handles[i] = $(this.handles[i], this.element).show(); if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) { var axis = $(this.handles[i], this.element), padWrapper = 0; padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth(); var padPos = ['padding', /ne|nw|n/.test(i) ? 'Top' : /se|sw|s/.test(i) ? 'Bottom' : /^e$/.test(i) ? 'Right' : 'Left'].join(""); target.css(padPos, padWrapper); this._proportionallyResize() } if (!$(this.handles[i]).length) continue } }; this._renderAxis(this.element); this._handles = $('.ui-resizable-handle', this.element).disableSelection(); this._handles.mouseover(function () { if (!self.resizing) { if (this.className) var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i); self.axis = axis && axis[1] ? axis[1] : 'se' } }); if (o.autoHide) { this._handles.hide(); $(this.element).addClass("ui-resizable-autohide").hover(function () { if (o.disabled) return; $(this).removeClass("ui-resizable-autohide"); self._handles.show() }, function () { if (o.disabled) return; if (!self.resizing) { $(this).addClass("ui-resizable-autohide"); self._handles.hide() } }) } this._mouseInit() }, destroy: function () { this._mouseDestroy(); var _destroy = function (exp) { $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find('.ui-resizable-handle').remove() }; if (this.elementIsWrapper) { _destroy(this.element); var wrapper = this.element; wrapper.after(this.originalElement.css({ position: wrapper.css('position'), width: wrapper.outerWidth(), height: wrapper.outerHeight(), top: wrapper.css('top'), left: wrapper.css('left') })).remove() } this.originalElement.css('resize', this.originalResizeStyle); _destroy(this.originalElement); return this }, _mouseCapture: function (event) { var handle = false; for (var i in this.handles) { if ($(this.handles[i])[0] == event.target) { handle = true } } return !this.options.disabled && handle }, _mouseStart: function (event) { var o = this.options, iniPos = this.element.position(), el = this.element; this.resizing = true; this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() }; if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) { el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left }) } this._renderProxy(); var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top')); if (o.containment) { curleft += $(o.containment).scrollLeft() || 0; curtop += $(o.containment).scrollTop() || 0 } this.offset = this.helper.offset(); this.position = { left: curleft, top: curtop }; this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() }; this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() }; this.originalPosition = { left: curleft, top: curtop }; this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() }; this.originalMousePosition = { left: event.pageX, top: event.pageY }; this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1); var cursor = $('.ui-resizable-' + this.axis).css('cursor'); $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor); el.addClass("ui-resizable-resizing"); this._propagate("start", event); return true }, _mouseDrag: function (event) { var el = this.helper, o = this.options, props = {}, self = this, smp = this.originalMousePosition, a = this.axis; var dx = (event.pageX - smp.left) || 0, dy = (event.pageY - smp.top) || 0; var trigger = this._change[a]; if (!trigger) return false; var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff; this._updateVirtualBoundaries(event.shiftKey); if (this._aspectRatio || event.shiftKey) data = this._updateRatio(data, event); data = this._respectSize(data, event); this._propagate("resize", event); el.css({ top: this.position.top + "px", left: this.position.left + "px", width: this.size.width + "px", height: this.size.height + "px" }); if (!this._helper && this._proportionallyResizeElements.length) this._proportionallyResize(); this._updateCache(data); this._trigger('resize', event, this.ui()); return false }, _mouseStop: function (event) { this.resizing = false; var o = this.options, self = this; if (this._helper) { var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], 'left') ? 0 : self.sizeDiff.height, soffsetw = ista ? 0 : self.sizeDiff.width; var s = { width: (self.helper.width() - soffsetw), height: (self.helper.height() - soffseth) }, left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null, top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null; if (!o.animate) this.element.css($.extend(s, { top: top, left: left })); self.helper.height(self.size.height); self.helper.width(self.size.width); if (this._helper && !o.animate) this._proportionallyResize() } $('body').css('cursor', 'auto'); this.element.removeClass("ui-resizable-resizing"); this._propagate("stop", event); if (this._helper) this.helper.remove(); return false }, _updateVirtualBoundaries: function (forceAspectRatio) { var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b; b = { minWidth: isNumber(o.minWidth) ? o.minWidth : 0, maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity, minHeight: isNumber(o.minHeight) ? o.minHeight : 0, maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity }; if (this._aspectRatio || forceAspectRatio) { pMinWidth = b.minHeight * this.aspectRatio; pMinHeight = b.minWidth / this.aspectRatio; pMaxWidth = b.maxHeight * this.aspectRatio; pMaxHeight = b.maxWidth / this.aspectRatio; if (pMinWidth > b.minWidth) b.minWidth = pMinWidth; if (pMinHeight > b.minHeight) b.minHeight = pMinHeight; if (pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth; if (pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight } this._vBoundaries = b }, _updateCache: function (data) { var o = this.options; this.offset = this.helper.offset(); if (isNumber(data.left)) this.position.left = data.left; if (isNumber(data.top)) this.position.top = data.top; if (isNumber(data.height)) this.size.height = data.height; if (isNumber(data.width)) this.size.width = data.width }, _updateRatio: function (data, event) { var o = this.options, cpos = this.position, csize = this.size, a = this.axis; if (isNumber(data.height)) data.width = (data.height * this.aspectRatio); else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio); if (a == 'sw') { data.left = cpos.left + (csize.width - data.width); data.top = null } if (a == 'nw') { data.top = cpos.top + (csize.height - data.height); data.left = cpos.left + (csize.width - data.width) } return data }, _respectSize: function (data, event) { var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis, ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height), isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height); if (isminw) data.width = o.minWidth; if (isminh) data.height = o.minHeight; if (ismaxw) data.width = o.maxWidth; if (ismaxh) data.height = o.maxHeight; var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height; var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a); if (isminw && cw) data.left = dw - o.minWidth; if (ismaxw && cw) data.left = dw - o.maxWidth; if (isminh && ch) data.top = dh - o.minHeight; if (ismaxh && ch) data.top = dh - o.maxHeight; var isNotwh = !data.width && !data.height; if (isNotwh && !data.left && data.top) data.top = null; else if (isNotwh && !data.top && data.left) data.left = null; return data }, _proportionallyResize: function () { var o = this.options; if (!this._proportionallyResizeElements.length) return; var element = this.helper || this.element; for (var i = 0; i < this._proportionallyResizeElements.length; i++) { var prel = this._proportionallyResizeElements[i]; if (!this.borderDif) { var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')], p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')]; this.borderDif = $.map(b, function (v, i) { var border = parseInt(v, 10) || 0, padding = parseInt(p[i], 10) || 0; return border + padding }) } if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length))) continue; prel.css({ height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0, width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0 }) } }, _renderProxy: function () { var el = this.element, o = this.options; this.elementOffset = el.offset(); if (this._helper) { this.helper = this.helper || $('<div style="overflow:hidden;"></div>'); var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0), pxyoffset = (ie6 ? 2 : -1); this.helper.addClass(this._helper).css({ width: this.element.outerWidth() + pxyoffset, height: this.element.outerHeight() + pxyoffset, position: 'absolute', left: this.elementOffset.left - ie6offset + 'px', top: this.elementOffset.top - ie6offset + 'px', zIndex: ++o.zIndex }); this.helper.appendTo("body").disableSelection() } else { this.helper = this.element } }, _change: { e: function (event, dx, dy) { return { width: this.originalSize.width + dx } }, w: function (event, dx, dy) { var o = this.options, cs = this.originalSize, sp = this.originalPosition; return { left: sp.left + dx, width: cs.width - dx } }, n: function (event, dx, dy) { var o = this.options, cs = this.originalSize, sp = this.originalPosition; return { top: sp.top + dy, height: cs.height - dy } }, s: function (event, dx, dy) { return { height: this.originalSize.height + dy } }, se: function (event, dx, dy) { return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy])) }, sw: function (event, dx, dy) { return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy])) }, ne: function (event, dx, dy) { return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy])) }, nw: function (event, dx, dy) { return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy])) } }, _propagate: function (n, event) { $.ui.plugin.call(this, n, [event, this.ui()]); (n != "resize" && this._trigger(n, event, this.ui())) }, plugins: {}, ui: function () { return { originalElement: this.originalElement, element: this.element, helper: this.helper, position: this.position, size: this.size, originalSize: this.originalSize, originalPosition: this.originalPosition } } }); $.extend($.ui.resizable, { version: "1.8.22" }); $.ui.plugin.add("resizable", "alsoResize", { start: function (event, ui) { var self = $(this).data("resizable"), o = self.options; var _store = function (exp) { $(exp).each(function () { var el = $(this); el.data("resizable-alsoresize", { width: parseInt(el.width(), 10), height: parseInt(el.height(), 10), left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10) }) }) }; if (typeof (o.alsoResize) == 'object' && !o.alsoResize.parentNode) { if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize) } else { $.each(o.alsoResize, function (exp) { _store(exp) }) } } else { _store(o.alsoResize) } }, resize: function (event, ui) { var self = $(this).data("resizable"), o = self.options, os = self.originalSize, op = self.originalPosition; var delta = { height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0, top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0 }, _alsoResize = function (exp, c) { $(exp).each(function () { var el = $(this), start = $(this).data("resizable-alsoresize"), style = {}, css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left']; $.each(css, function (i, prop) { var sum = (start[prop] || 0) + (delta[prop] || 0); if (sum && sum >= 0) style[prop] = sum || null }); el.css(style) }) }; if (typeof (o.alsoResize) == 'object' && !o.alsoResize.nodeType) { $.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c) }) } else { _alsoResize(o.alsoResize) } }, stop: function (event, ui) { $(this).removeData("resizable-alsoresize") } }); $.ui.plugin.add("resizable", "animate", { stop: function (event, ui) { var self = $(this).data("resizable"), o = self.options; var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], 'left') ? 0 : self.sizeDiff.height, soffsetw = ista ? 0 : self.sizeDiff.width; var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) }, left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null, top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null; self.element.animate($.extend(style, top && left ? { top: top, left: left } : {}), { duration: o.animateDuration, easing: o.animateEasing, step: function () { var data = { width: parseInt(self.element.css('width'), 10), height: parseInt(self.element.css('height'), 10), top: parseInt(self.element.css('top'), 10), left: parseInt(self.element.css('left'), 10) }; if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height }); self._updateCache(data); self._propagate("resize", event) } }) } }); $.ui.plugin.add("resizable", "containment", { start: function (event, ui) { var self = $(this).data("resizable"), o = self.options, el = self.element; var oc = o.containment, ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc; if (!ce) return; self.containerElement = $(ce); if (/document/.test(oc) || oc == document) { self.containerOffset = { left: 0, top: 0 }; self.containerPosition = { left: 0, top: 0 }; self.parentData = { element: $(document), left: 0, top: 0, width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight } } else { var element = $(ce), p = []; $(["Top", "Right", "Left", "Bottom"]).each(function (i, name) { p[i] = num(element.css("padding" + name)) }); self.containerOffset = element.offset(); self.containerPosition = element.position(); self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) }; var co = self.containerOffset, ch = self.containerSize.height, cw = self.containerSize.width, width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch); self.parentData = { element: ce, left: co.left, top: co.top, width: width, height: height } } }, resize: function (event, ui) { var self = $(this).data("resizable"), o = self.options, ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position, pRatio = self._aspectRatio || event.shiftKey, cop = { top: 0, left: 0 }, ce = self.containerElement; if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co; if (cp.left < (self._helper ? co.left : 0)) { self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left)); if (pRatio) self.size.height = self.size.width / self.aspectRatio; self.position.left = o.helper ? co.left : 0 } if (cp.top < (self._helper ? co.top : 0)) { self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top); if (pRatio) self.size.width = self.size.height * self.aspectRatio; self.position.top = self._helper ? co.top : 0 } self.offset.left = self.parentData.left + self.position.left; self.offset.top = self.parentData.top + self.position.top; var woset = Math.abs((self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width), hoset = Math.abs((self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height); var isParent = self.containerElement.get(0) == self.element.parent().get(0), isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position')); if (isParent && isOffsetRelative) woset -= self.parentData.left; if (woset + self.size.width >= self.parentData.width) { self.size.width = self.parentData.width - woset; if (pRatio) self.size.height = self.size.width / self.aspectRatio } if (hoset + self.size.height >= self.parentData.height) { self.size.height = self.parentData.height - hoset; if (pRatio) self.size.width = self.size.height * self.aspectRatio } }, stop: function (event, ui) { var self = $(this).data("resizable"), o = self.options, cp = self.position, co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement; var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height; if (self._helper && !o.animate && (/relative/).test(ce.css('position'))) $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h }); if (self._helper && !o.animate && (/static/).test(ce.css('position'))) $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h }) } }); $.ui.plugin.add("resizable", "ghost", { start: function (event, ui) { var self = $(this).data("resizable"), o = self.options, cs = self.size; self.ghost = self.originalElement.clone(); self.ghost.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 }).addClass('ui-resizable-ghost').addClass(typeof o.ghost == 'string' ? o.ghost : ''); self.ghost.appendTo(self.helper) }, resize: function (event, ui) { var self = $(this).data("resizable"), o = self.options; if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width }) }, stop: function (event, ui) { var self = $(this).data("resizable"), o = self.options; if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0)) } }); $.ui.plugin.add("resizable", "grid", { resize: function (event, ui) { var self = $(this).data("resizable"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey; o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid; var ox = Math.round((cs.width - os.width) / (o.grid[0] || 1)) * (o.grid[0] || 1), oy = Math.round((cs.height - os.height) / (o.grid[1] || 1)) * (o.grid[1] || 1); if (/^(se|s|e)$/.test(a)) { self.size.width = os.width + ox; self.size.height = os.height + oy } else if (/^(ne)$/.test(a)) { self.size.width = os.width + ox; self.size.height = os.height + oy; self.position.top = op.top - oy } else if (/^(sw)$/.test(a)) { self.size.width = os.width + ox; self.size.height = os.height + oy; self.position.left = op.left - ox } else { self.size.width = os.width + ox; self.size.height = os.height + oy; self.position.top = op.top - oy; self.position.left = op.left - ox } } }); var num = function (v) { return parseInt(v, 10) || 0 }; var isNumber = function (value) { return !isNaN(parseInt(value, 10)) } })(jQuery); (function ($, undefined) { $.widget("ui.selectable", $.ui.mouse, { options: { appendTo: 'body', autoRefresh: true, distance: 0, filter: '*', tolerance: 'touch' }, _create: function () { var self = this; this.element.addClass("ui-selectable"); this.dragged = false; var selectees; this.refresh = function () { selectees = $(self.options.filter, self.element[0]); selectees.addClass("ui-selectee"); selectees.each(function () { var $this = $(this); var pos = $this.offset(); $.data(this, "selectable-item", { element: this, $element: $this, left: pos.left, top: pos.top, right: pos.left + $this.outerWidth(), bottom: pos.top + $this.outerHeight(), startselected: false, selected: $this.hasClass('ui-selected'), selecting: $this.hasClass('ui-selecting'), unselecting: $this.hasClass('ui-unselecting') }) }) }; this.refresh(); this.selectees = selectees.addClass("ui-selectee"); this._mouseInit(); this.helper = $("<div class='ui-selectable-helper'></div>") }, destroy: function () { this.selectees.removeClass("ui-selectee").removeData("selectable-item"); this.element.removeClass("ui-selectable ui-selectable-disabled").removeData("selectable").unbind(".selectable"); this._mouseDestroy(); return this }, _mouseStart: function (event) { var self = this; this.opos = [event.pageX, event.pageY]; if (this.options.disabled) return; var options = this.options; this.selectees = $(options.filter, this.element[0]); this._trigger("start", event); $(options.appendTo).append(this.helper); this.helper.css({ "left": event.clientX, "top": event.clientY, "width": 0, "height": 0 }); if (options.autoRefresh) { this.refresh() } this.selectees.filter('.ui-selected').each(function () { var selectee = $.data(this, "selectable-item"); selectee.startselected = true; if (!event.metaKey && !event.ctrlKey) { selectee.$element.removeClass('ui-selected'); selectee.selected = false; selectee.$element.addClass('ui-unselecting'); selectee.unselecting = true; self._trigger("unselecting", event, { unselecting: selectee.element }) } }); $(event.target).parents().andSelf().each(function () { var selectee = $.data(this, "selectable-item"); if (selectee) { var doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected'); selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected").addClass(doSelect ? "ui-selecting" : "ui-unselecting"); selectee.unselecting = !doSelect; selectee.selecting = doSelect; selectee.selected = doSelect; if (doSelect) { self._trigger("selecting", event, { selecting: selectee.element }) } else { self._trigger("unselecting", event, { unselecting: selectee.element }) } return false } }) }, _mouseDrag: function (event) { var self = this; this.dragged = true; if (this.options.disabled) return; var options = this.options; var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY; if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp } if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp } this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 }); this.selectees.each(function () { var selectee = $.data(this, "selectable-item"); if (!selectee || selectee.element == self.element[0]) return; var hit = false; if (options.tolerance == 'touch') { hit = (!(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1)) } else if (options.tolerance == 'fit') { hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2) } if (hit) { if (selectee.selected) { selectee.$element.removeClass('ui-selected'); selectee.selected = false } if (selectee.unselecting) { selectee.$element.removeClass('ui-unselecting'); selectee.unselecting = false } if (!selectee.selecting) { selectee.$element.addClass('ui-selecting'); selectee.selecting = true; self._trigger("selecting", event, { selecting: selectee.element }) } } else { if (selectee.selecting) { if ((event.metaKey || event.ctrlKey) && selectee.startselected) { selectee.$element.removeClass('ui-selecting'); selectee.selecting = false; selectee.$element.addClass('ui-selected'); selectee.selected = true } else { selectee.$element.removeClass('ui-selecting'); selectee.selecting = false; if (selectee.startselected) { selectee.$element.addClass('ui-unselecting'); selectee.unselecting = true } self._trigger("unselecting", event, { unselecting: selectee.element }) } } if (selectee.selected) { if (!event.metaKey && !event.ctrlKey && !selectee.startselected) { selectee.$element.removeClass('ui-selected'); selectee.selected = false; selectee.$element.addClass('ui-unselecting'); selectee.unselecting = true; self._trigger("unselecting", event, { unselecting: selectee.element }) } } } }); return false }, _mouseStop: function (event) { var self = this; this.dragged = false; var options = this.options; $('.ui-unselecting', this.element[0]).each(function () { var selectee = $.data(this, "selectable-item"); selectee.$element.removeClass('ui-unselecting'); selectee.unselecting = false; selectee.startselected = false; self._trigger("unselected", event, { unselected: selectee.element }) }); $('.ui-selecting', this.element[0]).each(function () { var selectee = $.data(this, "selectable-item"); selectee.$element.removeClass('ui-selecting').addClass('ui-selected'); selectee.selecting = false; selectee.selected = true; selectee.startselected = true; self._trigger("selected", event, { selected: selectee.element }) }); this._trigger("stop", event); this.helper.remove(); return false } }); $.extend($.ui.selectable, { version: "1.8.22" }) })(jQuery); (function ($, undefined) { $.widget("ui.sortable", $.ui.mouse, { widgetEventPrefix: "sort", ready: false, options: { appendTo: "parent", axis: false, connectWith: false, containment: false, cursor: 'auto', cursorAt: false, dropOnEmpty: true, forcePlaceholderSize: false, forceHelperSize: false, grid: false, handle: false, helper: "original", items: '> *', opacity: false, placeholder: false, revert: false, scroll: true, scrollSensitivity: 20, scrollSpeed: 20, scope: "default", tolerance: "intersect", zIndex: 1000 }, _create: function () { var o = this.options; this.containerCache = {}; this.element.addClass("ui-sortable"); this.refresh(); this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false; this.offset = this.element.offset(); this._mouseInit(); this.ready = true }, destroy: function () { $.Widget.prototype.destroy.call(this); this.element.removeClass("ui-sortable ui-sortable-disabled"); this._mouseDestroy(); for (var i = this.items.length - 1; i >= 0; i--) this.items[i].item.removeData(this.widgetName + "-item"); return this }, _setOption: function (key, value) { if (key === "disabled") { this.options[key] = value; this.widget()[value ? "addClass" : "removeClass"]("ui-sortable-disabled") } else { $.Widget.prototype._setOption.apply(this, arguments) } }, _mouseCapture: function (event, overrideHandle) { var that = this; if (this.reverting) { return false } if (this.options.disabled || this.options.type == 'static') return false; this._refreshItems(event); var currentItem = null, self = this, nodes = $(event.target).parents().each(function () { if ($.data(this, that.widgetName + '-item') == self) { currentItem = $(this); return false } }); if ($.data(event.target, that.widgetName + '-item') == self) currentItem = $(event.target); if (!currentItem) return false; if (this.options.handle && !overrideHandle) { var validHandle = false; $(this.options.handle, currentItem).find("*").andSelf().each(function () { if (this == event.target) validHandle = true }); if (!validHandle) return false } this.currentItem = currentItem; this._removeCurrentsFromItems(); return true }, _mouseStart: function (event, overrideHandle, noActivation) { var o = this.options, self = this; this.currentContainer = this; this.refreshPositions(); this.helper = this._createHelper(event); this._cacheHelperProportions(); this._cacheMargins(); this.scrollParent = this.helper.scrollParent(); this.offset = this.currentItem.offset(); this.offset = { top: this.offset.top - this.margins.top, left: this.offset.left - this.margins.left }; $.extend(this.offset, { click: { left: event.pageX - this.offset.left, top: event.pageY - this.offset.top }, parent: this._getParentOffset(), relative: this._getRelativeOffset() }); this.helper.css("position", "absolute"); this.cssPosition = this.helper.css("position"); this.originalPosition = this._generatePosition(event); this.originalPageX = event.pageX; this.originalPageY = event.pageY; (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt)); this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] }; if (this.helper[0] != this.currentItem[0]) { this.currentItem.hide() } this._createPlaceholder(); if (o.containment) this._setContainment(); if (o.cursor) { if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor"); $('body').css("cursor", o.cursor) } if (o.opacity) { if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity"); this.helper.css("opacity", o.opacity) } if (o.zIndex) { if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex"); this.helper.css("zIndex", o.zIndex) } if (this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') this.overflowOffset = this.scrollParent.offset(); this._trigger("start", event, this._uiHash()); if (!this._preserveHelperProportions) this._cacheHelperProportions(); if (!noActivation) { for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, self._uiHash(this)) } } if ($.ui.ddmanager) $.ui.ddmanager.current = this; if ($.ui.ddmanager && !o.dropBehaviour) $.ui.ddmanager.prepareOffsets(this, event); this.dragging = true; this.helper.addClass("ui-sortable-helper"); this._mouseDrag(event); return true }, _mouseDrag: function (event) { this.position = this._generatePosition(event); this.positionAbs = this._convertPositionTo("absolute"); if (!this.lastPositionAbs) { this.lastPositionAbs = this.positionAbs } if (this.options.scroll) { var o = this.options, scrolled = false; if (this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') { if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed; else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed; if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed; else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed } else { if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed); else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed); if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed); else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed) } if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) $.ui.ddmanager.prepareOffsets(this, event) } this.positionAbs = this._convertPositionTo("absolute"); if (!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left + 'px'; if (!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top + 'px'; for (var i = this.items.length - 1; i >= 0; i--) { var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item); if (!intersection) continue; if (itemElement != this.currentItem[0] && this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement && !$.ui.contains(this.placeholder[0], itemElement) && (this.options.type == 'semi-dynamic' ? !$.ui.contains(this.element[0], itemElement) : true)) { this.direction = intersection == 1 ? "down" : "up"; if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) { this._rearrange(event, item) } else { break } this._trigger("change", event, this._uiHash()); break } } this._contactContainers(event); if ($.ui.ddmanager) $.ui.ddmanager.drag(this, event); this._trigger('sort', event, this._uiHash()); this.lastPositionAbs = this.positionAbs; return false }, _mouseStop: function (event, noPropagation) { if (!event) return; if ($.ui.ddmanager && !this.options.dropBehaviour) $.ui.ddmanager.drop(this, event); if (this.options.revert) { var self = this; var cur = self.placeholder.offset(); self.reverting = true; $(this.helper).animate({ left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft), top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop) }, parseInt(this.options.revert, 10) || 500, function () { self._clear(event) }) } else { this._clear(event, noPropagation) } return false }, cancel: function () { var self = this; if (this.dragging) { this._mouseUp({ target: null }); if (this.options.helper == "original") this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"); else this.currentItem.show(); for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("deactivate", null, self._uiHash(this)); if (this.containers[i].containerCache.over) { this.containers[i]._trigger("out", null, self._uiHash(this)); this.containers[i].containerCache.over = 0 } } } if (this.placeholder) { if (this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]); if (this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove(); $.extend(this, { helper: null, dragging: false, reverting: false, _noFinalSort: null }); if (this.domPosition.prev) { $(this.domPosition.prev).after(this.currentItem) } else { $(this.domPosition.parent).prepend(this.currentItem) } } return this }, serialize: function (o) { var items = this._getItemsAsjQuery(o && o.connected); var str = []; o = o || {}; $(items).each(function () { var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/)); if (res) str.push((o.key || res[1] + '[]') + '=' + (o.key && o.expression ? res[1] : res[2])) }); if (!str.length && o.key) { str.push(o.key + '=') } return str.join('&') }, toArray: function (o) { var items = this._getItemsAsjQuery(o && o.connected); var ret = []; o = o || {}; items.each(function () { ret.push($(o.item || this).attr(o.attribute || 'id') || '') }); return ret }, _intersectsWith: function (item) { var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height; var l = item.left, r = l + item.width, t = item.top, b = t + item.height; var dyClick = this.offset.click.top, dxClick = this.offset.click.left; var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r; if (this.options.tolerance == "pointer" || this.options.forcePointerForContainers || (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])) { return isOverElement } else { return (l < x1 + (this.helperProportions.width / 2) && x2 - (this.helperProportions.width / 2) < r && t < y1 + (this.helperProportions.height / 2) && y2 - (this.helperProportions.height / 2) < b); } }, _intersectsWithPointer: function (item) { var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection(); if (!isOverElement) return false; return this.floating ? (((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1) : (verticalDirection && (verticalDirection == "down" ? 2 : 1)) }, _intersectsWithSides: function (item) { var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height / 2), item.height), isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width / 2), item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection(); if (this.floating && horizontalDirection) { return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf)) } else { return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf)) } }, _getDragVerticalDirection: function () { var delta = this.positionAbs.top - this.lastPositionAbs.top; return delta != 0 && (delta > 0 ? "down" : "up") }, _getDragHorizontalDirection: function () { var delta = this.positionAbs.left - this.lastPositionAbs.left; return delta != 0 && (delta > 0 ? "right" : "left") }, refresh: function (event) { this._refreshItems(event); this.refreshPositions(); return this }, _connectWith: function () { var options = this.options; return options.connectWith.constructor == String ? [options.connectWith] : options.connectWith }, _getItemsAsjQuery: function (connected) { var self = this; var items = []; var queries = []; var connectWith = this._connectWith(); if (connectWith && connected) { for (var i = connectWith.length - 1; i >= 0; i--) { var cur = $(connectWith[i]); for (var j = cur.length - 1; j >= 0; j--) { var inst = $.data(cur[j], this.widgetName); if (inst && inst != this && !inst.options.disabled) { queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]) } } } } queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]); for (var i = queries.length - 1; i >= 0; i--) { queries[i][0].each(function () { items.push(this) }) }; return $(items) }, _removeCurrentsFromItems: function () { var list = this.currentItem.find(":data(" + this.widgetName + "-item)"); for (var i = 0; i < this.items.length; i++) { for (var j = 0; j < list.length; j++) { if (list[j] == this.items[i].item[0]) this.items.splice(i, 1) } } }, _refreshItems: function (event) { this.items = []; this.containers = [this]; var items = this.items; var self = this; var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]]; var connectWith = this._connectWith(); if (connectWith && this.ready) { for (var i = connectWith.length - 1; i >= 0; i--) { var cur = $(connectWith[i]); for (var j = cur.length - 1; j >= 0; j--) { var inst = $.data(cur[j], this.widgetName); if (inst && inst != this && !inst.options.disabled) { queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]); this.containers.push(inst) } } } } for (var i = queries.length - 1; i >= 0; i--) { var targetData = queries[i][1]; var _queries = queries[i][0]; for (var j = 0, queriesLength = _queries.length; j < queriesLength; j++) { var item = $(_queries[j]); item.data(this.widgetName + '-item', targetData); items.push({ item: item, instance: targetData, width: 0, height: 0, left: 0, top: 0 }) } } }, refreshPositions: function (fast) { if (this.offsetParent && this.helper) { this.offset.parent = this._getParentOffset() } for (var i = this.items.length - 1; i >= 0; i--) { var item = this.items[i]; if (item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0]) continue; var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item; if (!fast) { item.width = t.outerWidth(); item.height = t.outerHeight() } var p = t.offset(); item.left = p.left; item.top = p.top }; if (this.options.custom && this.options.custom.refreshContainers) { this.options.custom.refreshContainers.call(this) } else { for (var i = this.containers.length - 1; i >= 0; i--) { var p = this.containers[i].element.offset(); this.containers[i].containerCache.left = p.left; this.containers[i].containerCache.top = p.top; this.containers[i].containerCache.width = this.containers[i].element.outerWidth(); this.containers[i].containerCache.height = this.containers[i].element.outerHeight() } } return this }, _createPlaceholder: function (that) { var self = that || this, o = self.options; if (!o.placeholder || o.placeholder.constructor == String) { var className = o.placeholder; o.placeholder = { element: function () { var el = $(document.createElement(self.currentItem[0].nodeName)).addClass(className || self.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper")[0]; if (!className) el.style.visibility = "hidden"; return el }, update: function (container, p) { if (className && !o.forcePlaceholderSize) return; if (!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop') || 0, 10) - parseInt(self.currentItem.css('paddingBottom') || 0, 10)) }; if (!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft') || 0, 10) - parseInt(self.currentItem.css('paddingRight') || 0, 10)) } } } } self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem)); self.currentItem.after(self.placeholder); o.placeholder.update(self, self.placeholder) }, _contactContainers: function (event) { var innermostContainer = null, innermostIndex = null; for (var i = this.containers.length - 1; i >= 0; i--) { if ($.ui.contains(this.currentItem[0], this.containers[i].element[0])) continue; if (this._intersectsWith(this.containers[i].containerCache)) { if (innermostContainer && $.ui.contains(this.containers[i].element[0], innermostContainer.element[0])) continue; innermostContainer = this.containers[i]; innermostIndex = i } else { if (this.containers[i].containerCache.over) { this.containers[i]._trigger("out", event, this._uiHash(this)); this.containers[i].containerCache.over = 0 } } } if (!innermostContainer) return; if (this.containers.length === 1) { this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)); this.containers[innermostIndex].containerCache.over = 1 } else if (this.currentContainer != this.containers[innermostIndex]) { var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top']; for (var j = this.items.length - 1; j >= 0; j--) { if (!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue; var cur = this.containers[innermostIndex].floating ? this.items[j].item.offset().left : this.items[j].item.offset().top; if (Math.abs(cur - base) < dist) { dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j]; this.direction = (cur - base > 0) ? 'down' : 'up' } } if (!itemWithLeastDistance && !this.options.dropOnEmpty) return; this.currentContainer = this.containers[innermostIndex]; itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true); this._trigger("change", event, this._uiHash()); this.containers[innermostIndex]._trigger("change", event, this._uiHash(this)); this.options.placeholder.update(this.currentContainer, this.placeholder); this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)); this.containers[innermostIndex].containerCache.over = 1 } }, _createHelper: function (event) { var o = this.options; var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem); if (!helper.parents('body').length) $(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]); if (helper[0] == this.currentItem[0]) this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") }; if (helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width()); if (helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height()); return helper }, _adjustOffsetFromHelper: function (obj) { if (typeof obj == 'string') { obj = obj.split(' ') } if ($.isArray(obj)) { obj = { left: +obj[0], top: +obj[1] || 0 } } if ('left' in obj) { this.offset.click.left = obj.left + this.margins.left } if ('right' in obj) { this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left } if ('top' in obj) { this.offset.click.top = obj.top + this.margins.top } if ('bottom' in obj) { this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top } }, _getParentOffset: function () { this.offsetParent = this.helper.offsetParent(); var po = this.offsetParent.offset(); if (this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) { po.left += this.scrollParent.scrollLeft(); po.top += this.scrollParent.scrollTop() } if ((this.offsetParent[0] == document.body) || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) po = { top: 0, left: 0 }; return { top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0), left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0) } }, _getRelativeOffset: function () { if (this.cssPosition == "relative") { var p = this.currentItem.position(); return { top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(), left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft() } } else { return { top: 0, left: 0 } } }, _cacheMargins: function () { this.margins = { left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0), top: (parseInt(this.currentItem.css("marginTop"), 10) || 0) } }, _cacheHelperProportions: function () { this.helperProportions = { width: this.helper.outerWidth(), height: this.helper.outerHeight() } }, _setContainment: function () { var o = this.options; if (o.containment == 'parent') o.containment = this.helper[0].parentNode; if (o.containment == 'document' || o.containment == 'window') this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left, ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]; if (!(/^(document|window|parent)$/).test(o.containment)) { var ce = $(o.containment)[0]; var co = $(o.containment).offset(); var over = ($(ce).css("overflow") != 'hidden'); this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top] } }, _convertPositionTo: function (d, pos) { if (!pos) pos = this.position; var mod = d == "absolute" ? 1 : -1; var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName); return { top: (pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ($.browser.safari && this.cssPosition == 'fixed' ? 0 : (this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)), left: (pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ($.browser.safari && this.cssPosition == 'fixed' ? 0 : (this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod)) } }, _generatePosition: function (event) { var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName); if (this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) { this.offset.relative = this._getRelativeOffset() } var pageX = event.pageX; var pageY = event.pageY; if (this.originalPosition) { if (this.containment) { if (event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left; if (event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top; if (event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left; if (event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top } if (o.grid) { var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1]; pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top; var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0]; pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left } } return { top: (pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ($.browser.safari && this.cssPosition == 'fixed' ? 0 : (this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))), left: (pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ($.browser.safari && this.cssPosition == 'fixed' ? 0 : (this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()))) } }, _rearrange: function (event, i, a, hardRefresh) { a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling)); this.counter = this.counter ? ++this.counter : 1; var self = this, counter = this.counter; window.setTimeout(function () { if (counter == self.counter) self.refreshPositions(!hardRefresh) }, 0) }, _clear: function (event, noPropagation) { this.reverting = false; var delayedTriggers = [], self = this; if (!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem); this._noFinalSort = null; if (this.helper[0] == this.currentItem[0]) { for (var i in this._storedCSS) { if (this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '' } this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") } else { this.currentItem.show() } if (this.fromOutside && !noPropagation) delayedTriggers.push(function (event) { this._trigger("receive", event, this._uiHash(this.fromOutside)) }); if ((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function (event) { this._trigger("update", event, this._uiHash()) }); if (!$.ui.contains(this.element[0], this.currentItem[0])) { if (!noPropagation) delayedTriggers.push(function (event) { this._trigger("remove", event, this._uiHash()) }); for (var i = this.containers.length - 1; i >= 0; i--) { if ($.ui.contains(this.containers[i].element[0], this.currentItem[0]) && !noPropagation) { delayedTriggers.push((function (c) { return function (event) { c._trigger("receive", event, this._uiHash(this)) } }).call(this, this.containers[i])); delayedTriggers.push((function (c) { return function (event) { c._trigger("update", event, this._uiHash(this)) } }).call(this, this.containers[i])) } } }; for (var i = this.containers.length - 1; i >= 0; i--) { if (!noPropagation) delayedTriggers.push((function (c) { return function (event) { c._trigger("deactivate", event, this._uiHash(this)) } }).call(this, this.containers[i])); if (this.containers[i].containerCache.over) { delayedTriggers.push((function (c) { return function (event) { c._trigger("out", event, this._uiHash(this)) } }).call(this, this.containers[i])); this.containers[i].containerCache.over = 0 } } if (this._storedCursor) $('body').css("cursor", this._storedCursor); if (this._storedOpacity) this.helper.css("opacity", this._storedOpacity); if (this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); this.dragging = false; if (this.cancelHelperRemoval) { if (!noPropagation) { this._trigger("beforeStop", event, this._uiHash()); for (var i = 0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event) }; this._trigger("stop", event, this._uiHash()) } this.fromOutside = false; return false } if (!noPropagation) this._trigger("beforeStop", event, this._uiHash()); this.placeholder[0].parentNode.removeChild(this.placeholder[0]); if (this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null; if (!noPropagation) { for (var i = 0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event) }; this._trigger("stop", event, this._uiHash()) } this.fromOutside = false; return true }, _trigger: function () { if ($.Widget.prototype._trigger.apply(this, arguments) === false) { this.cancel() } }, _uiHash: function (inst) { var self = inst || this; return { helper: self.helper, placeholder: self.placeholder || $([]), position: self.position, originalPosition: self.originalPosition, offset: self.positionAbs, item: self.currentItem, sender: inst ? inst.element : null } } }); $.extend($.ui.sortable, { version: "1.8.22" }) })(jQuery); jQuery.effects || (function ($, undefined) { $.effects = {}; $.each(['backgroundColor', 'borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'borderColor', 'color', 'outlineColor'], function (i, attr) { $.fx.step[attr] = function (fx) { if (!fx.colorInit) { fx.start = getColor(fx.elem, attr); fx.end = getRGB(fx.end); fx.colorInit = true } fx.elem.style[attr] = 'rgb(' + Math.max(Math.min(parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0], 10), 255), 0) + ',' + Math.max(Math.min(parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1], 10), 255), 0) + ',' + Math.max(Math.min(parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2], 10), 255), 0) + ')' } }); function getRGB(color) { var result; if (color && color.constructor == Array && color.length == 3) return color; if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color)) return [parseInt(result[1], 10), parseInt(result[2], 10), parseInt(result[3], 10)]; if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color)) return [parseFloat(result[1]) * 2.55, parseFloat(result[2]) * 2.55, parseFloat(result[3]) * 2.55]; if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color)) return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)]; if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color)) return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16)]; if (result = /rgba\(0, 0, 0, 0\)/.exec(color)) return colors['transparent']; return colors[$.trim(color).toLowerCase()] } function getColor(elem, attr) { var color; do { color = ($.curCSS || $.css)(elem, attr); if (color != '' && color != 'transparent' || $.nodeName(elem, "body")) break; attr = "backgroundColor" } while (elem = elem.parentNode); return getRGB(color) }; var colors = { aqua: [0, 255, 255], azure: [240, 255, 255], beige: [245, 245, 220], black: [0, 0, 0], blue: [0, 0, 255], brown: [165, 42, 42], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgrey: [169, 169, 169], darkgreen: [0, 100, 0], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkviolet: [148, 0, 211], fuchsia: [255, 0, 255], gold: [255, 215, 0], green: [0, 128, 0], indigo: [75, 0, 130], khaki: [240, 230, 140], lightblue: [173, 216, 230], lightcyan: [224, 255, 255], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightyellow: [255, 255, 224], lime: [0, 255, 0], magenta: [255, 0, 255], maroon: [128, 0, 0], navy: [0, 0, 128], olive: [128, 128, 0], orange: [255, 165, 0], pink: [255, 192, 203], purple: [128, 0, 128], violet: [128, 0, 128], red: [255, 0, 0], silver: [192, 192, 192], white: [255, 255, 255], yellow: [255, 255, 0], transparent: [255, 255, 255] }; var classAnimationActions = ['add', 'remove', 'toggle'], shorthandStyles = { border: 1, borderBottom: 1, borderColor: 1, borderLeft: 1, borderRight: 1, borderTop: 1, borderWidth: 1, margin: 1, padding: 1 }; function getElementStyles() { var style = document.defaultView ? document.defaultView.getComputedStyle(this, null) : this.currentStyle, newStyle = {}, key, camelCase; if (style && style.length && style[0] && style[style[0]]) { var len = style.length; while (len--) { key = style[len]; if (typeof style[key] == 'string') { camelCase = key.replace(/\-(\w)/g, function (all, letter) { return letter.toUpperCase() }); newStyle[camelCase] = style[key] } } } else { for (key in style) { if (typeof style[key] === 'string') { newStyle[key] = style[key] } } } return newStyle } function filterStyles(styles) { var name, value; for (name in styles) { value = styles[name]; if (value == null || $.isFunction(value) || name in shorthandStyles || (/scrollbar/).test(name) || (!(/color/i).test(name) && isNaN(parseFloat(value)))) { delete styles[name] } } return styles } function styleDifference(oldStyle, newStyle) { var diff = { _: 0 }, name; for (name in newStyle) { if (oldStyle[name] != newStyle[name]) { diff[name] = newStyle[name] } } return diff } $.effects.animateClass = function (value, duration, easing, callback) { if ($.isFunction(easing)) { callback = easing; easing = null } return this.queue(function () { var that = $(this), originalStyleAttr = that.attr('style') || ' ', originalStyle = filterStyles(getElementStyles.call(this)), newStyle, className = that.attr('class') || ""; $.each(classAnimationActions, function (i, action) { if (value[action]) { that[action + 'Class'](value[action]) } }); newStyle = filterStyles(getElementStyles.call(this)); that.attr('class', className); that.animate(styleDifference(originalStyle, newStyle), { queue: false, duration: duration, easing: easing, complete: function () { $.each(classAnimationActions, function (i, action) { if (value[action]) { that[action + 'Class'](value[action]) } }); if (typeof that.attr('style') == 'object') { that.attr('style').cssText = ''; that.attr('style').cssText = originalStyleAttr } else { that.attr('style', originalStyleAttr) } if (callback) { callback.apply(this, arguments) } $.dequeue(this) } }) }) }; $.fn.extend({ _addClass: $.fn.addClass, addClass: function (classNames, speed, easing, callback) { return speed ? $.effects.animateClass.apply(this, [{ add: classNames }, speed, easing, callback]) : this._addClass(classNames) }, _removeClass: $.fn.removeClass, removeClass: function (classNames, speed, easing, callback) { return speed ? $.effects.animateClass.apply(this, [{ remove: classNames }, speed, easing, callback]) : this._removeClass(classNames) }, _toggleClass: $.fn.toggleClass, toggleClass: function (classNames, force, speed, easing, callback) { if (typeof force == "boolean" || force === undefined) { if (!speed) { return this._toggleClass(classNames, force) } else { return $.effects.animateClass.apply(this, [(force ? { add: classNames } : { remove: classNames }), speed, easing, callback]) } } else { return $.effects.animateClass.apply(this, [{ toggle: classNames }, force, speed, easing]) } }, switchClass: function (remove, add, speed, easing, callback) { return $.effects.animateClass.apply(this, [{ add: add, remove: remove }, speed, easing, callback]) } }); $.extend($.effects, { version: "1.8.22", save: function (element, set) { for (var i = 0; i < set.length; i++) { if (set[i] !== null) element.data("ec.storage." + set[i], element[0].style[set[i]]) } }, restore: function (element, set) { for (var i = 0; i < set.length; i++) { if (set[i] !== null) element.css(set[i], element.data("ec.storage." + set[i])) } }, setMode: function (el, mode) { if (mode == 'toggle') mode = el.is(':hidden') ? 'show' : 'hide'; return mode }, getBaseline: function (origin, original) { var y, x; switch (origin[0]) { case 'top': y = 0; break; case 'middle': y = 0.5; break; case 'bottom': y = 1; break; default: y = origin[0] / original.height }; switch (origin[1]) { case 'left': x = 0; break; case 'center': x = 0.5; break; case 'right': x = 1; break; default: x = origin[1] / original.width }; return { x: x, y: y } }, createWrapper: function (element) { if (element.parent().is('.ui-effects-wrapper')) { return element.parent() } var props = { width: element.outerWidth(true), height: element.outerHeight(true), 'float': element.css('float') }, wrapper = $('<div></div>').addClass('ui-effects-wrapper').css({ fontSize: '100%', background: 'transparent', border: 'none', margin: 0, padding: 0 }), active = document.activeElement; try { active.id } catch (e) { active = document.body } element.wrap(wrapper); if (element[0] === active || $.contains(element[0], active)) { $(active).focus() } wrapper = element.parent(); if (element.css('position') == 'static') { wrapper.css({ position: 'relative' }); element.css({ position: 'relative' }) } else { $.extend(props, { position: element.css('position'), zIndex: element.css('z-index') }); $.each(['top', 'left', 'bottom', 'right'], function (i, pos) { props[pos] = element.css(pos); if (isNaN(parseInt(props[pos], 10))) { props[pos] = 'auto' } }); element.css({ position: 'relative', top: 0, left: 0, right: 'auto', bottom: 'auto' }) } return wrapper.css(props).show() }, removeWrapper: function (element) { var parent, active = document.activeElement; if (element.parent().is('.ui-effects-wrapper')) { parent = element.parent().replaceWith(element); if (element[0] === active || $.contains(element[0], active)) { $(active).focus() } return parent } return element }, setTransition: function (element, list, factor, value) { value = value || {}; $.each(list, function (i, x) { var unit = element.cssUnit(x); if (unit[0] > 0) value[x] = unit[0] * factor + unit[1] }); return value } }); function _normalizeArguments(effect, options, speed, callback) { if (typeof effect == 'object') { callback = options; speed = null; options = effect; effect = options.effect } if ($.isFunction(options)) { callback = options; speed = null; options = {} } if (typeof options == 'number' || $.fx.speeds[options]) { callback = speed; speed = options; options = {} } if ($.isFunction(speed)) { callback = speed; speed = null } options = options || {}; speed = speed || options.duration; speed = $.fx.off ? 0 : typeof speed == 'number' ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default; callback = callback || options.complete; return [effect, options, speed, callback] } function standardSpeed(speed) { if (!speed || typeof speed === "number" || $.fx.speeds[speed]) { return true } if (typeof speed === "string" && !$.effects[speed]) { return true } return false } $.fn.extend({ effect: function (effect, options, speed, callback) { var args = _normalizeArguments.apply(this, arguments), args2 = { options: args[1], duration: args[2], callback: args[3] }, mode = args2.options.mode, effectMethod = $.effects[effect]; if ($.fx.off || !effectMethod) { if (mode) { return this[mode](args2.duration, args2.callback) } else { return this.each(function () { if (args2.callback) { args2.callback.call(this) } }) } } return effectMethod.call(this, args2) }, _show: $.fn.show, show: function (speed) { if (standardSpeed(speed)) { return this._show.apply(this, arguments) } else { var args = _normalizeArguments.apply(this, arguments); args[1].mode = 'show'; return this.effect.apply(this, args) } }, _hide: $.fn.hide, hide: function (speed) { if (standardSpeed(speed)) { return this._hide.apply(this, arguments) } else { var args = _normalizeArguments.apply(this, arguments); args[1].mode = 'hide'; return this.effect.apply(this, args) } }, __toggle: $.fn.toggle, toggle: function (speed) { if (standardSpeed(speed) || typeof speed === "boolean" || $.isFunction(speed)) { return this.__toggle.apply(this, arguments) } else { var args = _normalizeArguments.apply(this, arguments); args[1].mode = 'toggle'; return this.effect.apply(this, args) } }, cssUnit: function (key) { var style = this.css(key), val = []; $.each(['em', 'px', '%', 'pt'], function (i, unit) { if (style.indexOf(unit) > 0) val = [parseFloat(style), unit] }); return val } }); $.easing.jswing = $.easing.swing; $.extend($.easing, { def: 'easeOutQuad', swing: function (x, t, b, c, d) { return $.easing[$.easing.def](x, t, b, c, d) }, easeInQuad: function (x, t, b, c, d) { return c * (t /= d) * t + b }, easeOutQuad: function (x, t, b, c, d) { return -c * (t /= d) * (t - 2) + b }, easeInOutQuad: function (x, t, b, c, d) { if ((t /= d / 2) < 1) return c / 2 * t * t + b; return -c / 2 * ((--t) * (t - 2) - 1) + b }, easeInCubic: function (x, t, b, c, d) { return c * (t /= d) * t * t + b }, easeOutCubic: function (x, t, b, c, d) { return c * ((t = t / d - 1) * t * t + 1) + b }, easeInOutCubic: function (x, t, b, c, d) { if ((t /= d / 2) < 1) return c / 2 * t * t * t + b; return c / 2 * ((t -= 2) * t * t + 2) + b }, easeInQuart: function (x, t, b, c, d) { return c * (t /= d) * t * t * t + b }, easeOutQuart: function (x, t, b, c, d) { return -c * ((t = t / d - 1) * t * t * t - 1) + b }, easeInOutQuart: function (x, t, b, c, d) { if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b; return -c / 2 * ((t -= 2) * t * t * t - 2) + b }, easeInQuint: function (x, t, b, c, d) { return c * (t /= d) * t * t * t * t + b }, easeOutQuint: function (x, t, b, c, d) { return c * ((t = t / d - 1) * t * t * t * t + 1) + b }, easeInOutQuint: function (x, t, b, c, d) { if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b; return c / 2 * ((t -= 2) * t * t * t * t + 2) + b }, easeInSine: function (x, t, b, c, d) { return -c * Math.cos(t / d * (Math.PI / 2)) + c + b }, easeOutSine: function (x, t, b, c, d) { return c * Math.sin(t / d * (Math.PI / 2)) + b }, easeInOutSine: function (x, t, b, c, d) { return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b }, easeInExpo: function (x, t, b, c, d) { return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b }, easeOutExpo: function (x, t, b, c, d) { return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b }, easeInOutExpo: function (x, t, b, c, d) { if (t == 0) return b; if (t == d) return b + c; if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b; return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b }, easeInCirc: function (x, t, b, c, d) { return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b }, easeOutCirc: function (x, t, b, c, d) { return c * Math.sqrt(1 - (t = t / d - 1) * t) + b }, easeInOutCirc: function (x, t, b, c, d) { if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b; return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b }, easeInElastic: function (x, t, b, c, d) { var s = 1.70158; var p = 0; var a = c; if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3; if (a < Math.abs(c)) { a = c; var s = p / 4 } else var s = p / (2 * Math.PI) * Math.asin(c / a); return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b }, easeOutElastic: function (x, t, b, c, d) { var s = 1.70158; var p = 0; var a = c; if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3; if (a < Math.abs(c)) { a = c; var s = p / 4 } else var s = p / (2 * Math.PI) * Math.asin(c / a); return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b }, easeInOutElastic: function (x, t, b, c, d) { var s = 1.70158; var p = 0; var a = c; if (t == 0) return b; if ((t /= d / 2) == 2) return b + c; if (!p) p = d * (.3 * 1.5); if (a < Math.abs(c)) { a = c; var s = p / 4 } else var s = p / (2 * Math.PI) * Math.asin(c / a); if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b }, easeInBack: function (x, t, b, c, d, s) { if (s == undefined) s = 1.70158; return c * (t /= d) * t * ((s + 1) * t - s) + b }, easeOutBack: function (x, t, b, c, d, s) { if (s == undefined) s = 1.70158; return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b }, easeInOutBack: function (x, t, b, c, d, s) { if (s == undefined) s = 1.70158; if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b; return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b }, easeInBounce: function (x, t, b, c, d) { return c - $.easing.easeOutBounce(x, d - t, 0, c, d) + b }, easeOutBounce: function (x, t, b, c, d) { if ((t /= d) < (1 / 2.75)) { return c * (7.5625 * t * t) + b } else if (t < (2 / 2.75)) { return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b } else if (t < (2.5 / 2.75)) { return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b } else { return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b } }, easeInOutBounce: function (x, t, b, c, d) { if (t < d / 2) return $.easing.easeInBounce(x, t * 2, 0, c, d) * .5 + b; return $.easing.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b } }) })(jQuery); (function ($, undefined) { $.effects.blind = function (o) { return this.queue(function () { var el = $(this), props = ['position', 'top', 'bottom', 'left', 'right']; var mode = $.effects.setMode(el, o.options.mode || 'hide'); var direction = o.options.direction || 'vertical'; $.effects.save(el, props); el.show(); var wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' }); var ref = (direction == 'vertical') ? 'height' : 'width'; var distance = (direction == 'vertical') ? wrapper.height() : wrapper.width(); if (mode == 'show') wrapper.css(ref, 0); var animation = {}; animation[ref] = mode == 'show' ? distance : 0; wrapper.animate(animation, o.duration, o.options.easing, function () { if (mode == 'hide') el.hide(); $.effects.restore(el, props); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(el[0], arguments); el.dequeue() }) }) } })(jQuery); (function ($, undefined) { $.effects.bounce = function (o) { return this.queue(function () { var el = $(this), props = ['position', 'top', 'bottom', 'left', 'right']; var mode = $.effects.setMode(el, o.options.mode || 'effect'); var direction = o.options.direction || 'up'; var distance = o.options.distance || 20; var times = o.options.times || 5; var speed = o.duration || 250; if (/show|hide/.test(mode)) props.push('opacity'); $.effects.save(el, props); el.show(); $.effects.createWrapper(el); var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left'; var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg'; var distance = o.options.distance || (ref == 'top' ? el.outerHeight(true) / 3 : el.outerWidth(true) / 3); if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); if (mode == 'hide') distance = distance / (times * 2); if (mode != 'hide') times--; if (mode == 'show') { var animation = { opacity: 1 }; animation[ref] = (motion == 'pos' ? '+=' : '-=') + distance; el.animate(animation, speed / 2, o.options.easing); distance = distance / 2; times-- }; for (var i = 0; i < times; i++) { var animation1 = {}, animation2 = {}; animation1[ref] = (motion == 'pos' ? '-=' : '+=') + distance; animation2[ref] = (motion == 'pos' ? '+=' : '-=') + distance; el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing); distance = (mode == 'hide') ? distance * 2 : distance / 2 }; if (mode == 'hide') { var animation = { opacity: 0 }; animation[ref] = (motion == 'pos' ? '-=' : '+=') + distance; el.animate(animation, speed / 2, o.options.easing, function () { el.hide(); $.effects.restore(el, props); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(this, arguments) }) } else { var animation1 = {}, animation2 = {}; animation1[ref] = (motion == 'pos' ? '-=' : '+=') + distance; animation2[ref] = (motion == 'pos' ? '+=' : '-=') + distance; el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing, function () { $.effects.restore(el, props); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(this, arguments) }) }; el.queue('fx', function () { el.dequeue() }); el.dequeue() }) } })(jQuery); (function ($, undefined) { $.effects.clip = function (o) { return this.queue(function () { var el = $(this), props = ['position', 'top', 'bottom', 'left', 'right', 'height', 'width']; var mode = $.effects.setMode(el, o.options.mode || 'hide'); var direction = o.options.direction || 'vertical'; $.effects.save(el, props); el.show(); var wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' }); var animate = el[0].tagName == 'IMG' ? wrapper : el; var ref = { size: (direction == 'vertical') ? 'height' : 'width', position: (direction == 'vertical') ? 'top' : 'left' }; var distance = (direction == 'vertical') ? animate.height() : animate.width(); if (mode == 'show') { animate.css(ref.size, 0); animate.css(ref.position, distance / 2) } var animation = {}; animation[ref.size] = mode == 'show' ? distance : 0; animation[ref.position] = mode == 'show' ? 0 : distance / 2; animate.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function () { if (mode == 'hide') el.hide(); $.effects.restore(el, props); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(el[0], arguments); el.dequeue() } }) }) } })(jQuery); (function ($, undefined) { $.effects.drop = function (o) { return this.queue(function () { var el = $(this), props = ['position', 'top', 'bottom', 'left', 'right', 'opacity']; var mode = $.effects.setMode(el, o.options.mode || 'hide'); var direction = o.options.direction || 'left'; $.effects.save(el, props); el.show(); $.effects.createWrapper(el); var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left'; var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg'; var distance = o.options.distance || (ref == 'top' ? el.outerHeight(true) / 2 : el.outerWidth(true) / 2); if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); var animation = { opacity: mode == 'show' ? 1 : 0 }; animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance; el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function () { if (mode == 'hide') el.hide(); $.effects.restore(el, props); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(this, arguments); el.dequeue() } }) }) } })(jQuery); (function ($, undefined) { $.effects.explode = function (o) { return this.queue(function () { var rows = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3; var cells = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3; o.options.mode = o.options.mode == 'toggle' ? ($(this).is(':visible') ? 'hide' : 'show') : o.options.mode; var el = $(this).show().css('visibility', 'hidden'); var offset = el.offset(); offset.top -= parseInt(el.css("marginTop"), 10) || 0; offset.left -= parseInt(el.css("marginLeft"), 10) || 0; var width = el.outerWidth(true); var height = el.outerHeight(true); for (var i = 0; i < rows; i++) { for (var j = 0; j < cells; j++) { el.clone().appendTo('body').wrap('<div></div>').css({ position: 'absolute', visibility: 'visible', left: -j * (width / cells), top: -i * (height / rows) }).parent().addClass('ui-effects-explode').css({ position: 'absolute', overflow: 'hidden', width: width / cells, height: height / rows, left: offset.left + j * (width / cells) + (o.options.mode == 'show' ? (j - Math.floor(cells / 2)) * (width / cells) : 0), top: offset.top + i * (height / rows) + (o.options.mode == 'show' ? (i - Math.floor(rows / 2)) * (height / rows) : 0), opacity: o.options.mode == 'show' ? 0 : 1 }).animate({ left: offset.left + j * (width / cells) + (o.options.mode == 'show' ? 0 : (j - Math.floor(cells / 2)) * (width / cells)), top: offset.top + i * (height / rows) + (o.options.mode == 'show' ? 0 : (i - Math.floor(rows / 2)) * (height / rows)), opacity: o.options.mode == 'show' ? 1 : 0 }, o.duration || 500) } } setTimeout(function () { o.options.mode == 'show' ? el.css({ visibility: 'visible' }) : el.css({ visibility: 'visible' }).hide(); if (o.callback) o.callback.apply(el[0]); el.dequeue(); $('div.ui-effects-explode').remove() }, o.duration || 500) }) } })(jQuery); (function ($, undefined) { $.effects.fade = function (o) { return this.queue(function () { var elem = $(this), mode = $.effects.setMode(elem, o.options.mode || 'hide'); elem.animate({ opacity: mode }, { queue: false, duration: o.duration, easing: o.options.easing, complete: function () { (o.callback && o.callback.apply(this, arguments)); elem.dequeue() } }) }) } })(jQuery); (function ($, undefined) { $.effects.fold = function (o) { return this.queue(function () { var el = $(this), props = ['position', 'top', 'bottom', 'left', 'right']; var mode = $.effects.setMode(el, o.options.mode || 'hide'); var size = o.options.size || 15; var horizFirst = !(!o.options.horizFirst); var duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2; $.effects.save(el, props); el.show(); var wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' }); var widthFirst = ((mode == 'show') != horizFirst); var ref = widthFirst ? ['width', 'height'] : ['height', 'width']; var distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()]; var percent = /([0-9]+)%/.exec(size); if (percent) size = parseInt(percent[1], 10) / 100 * distance[mode == 'hide' ? 0 : 1]; if (mode == 'show') wrapper.css(horizFirst ? { height: 0, width: size } : { height: size, width: 0 }); var animation1 = {}, animation2 = {}; animation1[ref[0]] = mode == 'show' ? distance[0] : size; animation2[ref[1]] = mode == 'show' ? distance[1] : 0; wrapper.animate(animation1, duration, o.options.easing).animate(animation2, duration, o.options.easing, function () { if (mode == 'hide') el.hide(); $.effects.restore(el, props); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(el[0], arguments); el.dequeue() }) }) } })(jQuery); (function ($, undefined) { $.effects.highlight = function (o) { return this.queue(function () { var elem = $(this), props = ['backgroundImage', 'backgroundColor', 'opacity'], mode = $.effects.setMode(elem, o.options.mode || 'show'), animation = { backgroundColor: elem.css('backgroundColor') }; if (mode == 'hide') { animation.opacity = 0 } $.effects.save(elem, props); elem.show().css({ backgroundImage: 'none', backgroundColor: o.options.color || '#ffff99' }).animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function () { (mode == 'hide' && elem.hide()); $.effects.restore(elem, props); (mode == 'show' && !$.support.opacity && this.style.removeAttribute('filter')); (o.callback && o.callback.apply(this, arguments)); elem.dequeue() } }) }) } })(jQuery); (function ($, undefined) { $.effects.pulsate = function (o) { return this.queue(function () { var elem = $(this), mode = $.effects.setMode(elem, o.options.mode || 'show'), times = ((o.options.times || 5) * 2) - 1, duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2, isVisible = elem.is(':visible'), animateTo = 0; if (!isVisible) { elem.css('opacity', 0).show(); animateTo = 1 } if ((mode == 'hide' && isVisible) || (mode == 'show' && !isVisible)) { times-- } for (var i = 0; i < times; i++) { elem.animate({ opacity: animateTo }, duration, o.options.easing); animateTo = (animateTo + 1) % 2 } elem.animate({ opacity: animateTo }, duration, o.options.easing, function () { if (animateTo == 0) { elem.hide() } (o.callback && o.callback.apply(this, arguments)) }); elem.queue('fx', function () { elem.dequeue() }).dequeue() }) } })(jQuery); (function ($, undefined) { $.effects.puff = function (o) { return this.queue(function () { var elem = $(this), mode = $.effects.setMode(elem, o.options.mode || 'hide'), percent = parseInt(o.options.percent, 10) || 150, factor = percent / 100, original = { height: elem.height(), width: elem.width() }; $.extend(o.options, { fade: true, mode: mode, percent: mode == 'hide' ? percent : 100, from: mode == 'hide' ? original : { height: original.height * factor, width: original.width * factor } }); elem.effect('scale', o.options, o.duration, o.callback); elem.dequeue() }) }; $.effects.scale = function (o) { return this.queue(function () { var el = $(this); var options = $.extend(true, {}, o.options); var mode = $.effects.setMode(el, o.options.mode || 'effect'); var percent = parseInt(o.options.percent, 10) || (parseInt(o.options.percent, 10) == 0 ? 0 : (mode == 'hide' ? 0 : 100)); var direction = o.options.direction || 'both'; var origin = o.options.origin; if (mode != 'effect') { options.origin = origin || ['middle', 'center']; options.restore = true } var original = { height: el.height(), width: el.width() }; el.from = o.options.from || (mode == 'show' ? { height: 0, width: 0 } : original); var factor = { y: direction != 'horizontal' ? (percent / 100) : 1, x: direction != 'vertical' ? (percent / 100) : 1 }; el.to = { height: original.height * factor.y, width: original.width * factor.x }; if (o.options.fade) { if (mode == 'show') { el.from.opacity = 0; el.to.opacity = 1 }; if (mode == 'hide') { el.from.opacity = 1; el.to.opacity = 0 } }; options.from = el.from; options.to = el.to; options.mode = mode; el.effect('size', options, o.duration, o.callback); el.dequeue() }) }; $.effects.size = function (o) { return this.queue(function () { var el = $(this), props = ['position', 'top', 'bottom', 'left', 'right', 'width', 'height', 'overflow', 'opacity']; var props1 = ['position', 'top', 'bottom', 'left', 'right', 'overflow', 'opacity']; var props2 = ['width', 'height', 'overflow']; var cProps = ['fontSize']; var vProps = ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom']; var hProps = ['borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight']; var mode = $.effects.setMode(el, o.options.mode || 'effect'); var restore = o.options.restore || false; var scale = o.options.scale || 'both'; var origin = o.options.origin; var original = { height: el.height(), width: el.width() }; el.from = o.options.from || original; el.to = o.options.to || original; if (origin) { var baseline = $.effects.getBaseline(origin, original); el.from.top = (original.height - el.from.height) * baseline.y; el.from.left = (original.width - el.from.width) * baseline.x; el.to.top = (original.height - el.to.height) * baseline.y; el.to.left = (original.width - el.to.width) * baseline.x }; var factor = { from: { y: el.from.height / original.height, x: el.from.width / original.width }, to: { y: el.to.height / original.height, x: el.to.width / original.width } }; if (scale == 'box' || scale == 'both') { if (factor.from.y != factor.to.y) { props = props.concat(vProps); el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from); el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to) }; if (factor.from.x != factor.to.x) { props = props.concat(hProps); el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from); el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to) } }; if (scale == 'content' || scale == 'both') { if (factor.from.y != factor.to.y) { props = props.concat(cProps); el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from); el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to) } }; $.effects.save(el, restore ? props : props1); el.show(); $.effects.createWrapper(el); el.css('overflow', 'hidden').css(el.from); if (scale == 'content' || scale == 'both') { vProps = vProps.concat(['marginTop', 'marginBottom']).concat(cProps); hProps = hProps.concat(['marginLeft', 'marginRight']); props2 = props.concat(vProps).concat(hProps); el.find("*[width]").each(function () { var child = $(this); if (restore) $.effects.save(child, props2); var c_original = { height: child.height(), width: child.width() }; child.from = { height: c_original.height * factor.from.y, width: c_original.width * factor.from.x }; child.to = { height: c_original.height * factor.to.y, width: c_original.width * factor.to.x }; if (factor.from.y != factor.to.y) { child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from); child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to) }; if (factor.from.x != factor.to.x) { child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from); child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to) }; child.css(child.from); child.animate(child.to, o.duration, o.options.easing, function () { if (restore) $.effects.restore(child, props2) }) }) }; el.animate(el.to, { queue: false, duration: o.duration, easing: o.options.easing, complete: function () { if (el.to.opacity === 0) { el.css('opacity', el.from.opacity) } if (mode == 'hide') el.hide(); $.effects.restore(el, restore ? props : props1); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(this, arguments); el.dequeue() } }) }) } })(jQuery); (function ($, undefined) { $.effects.shake = function (o) { return this.queue(function () { var el = $(this), props = ['position', 'top', 'bottom', 'left', 'right']; var mode = $.effects.setMode(el, o.options.mode || 'effect'); var direction = o.options.direction || 'left'; var distance = o.options.distance || 20; var times = o.options.times || 3; var speed = o.duration || o.options.duration || 140; $.effects.save(el, props); el.show(); $.effects.createWrapper(el); var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left'; var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg'; var animation = {}, animation1 = {}, animation2 = {}; animation[ref] = (motion == 'pos' ? '-=' : '+=') + distance; animation1[ref] = (motion == 'pos' ? '+=' : '-=') + distance * 2; animation2[ref] = (motion == 'pos' ? '-=' : '+=') + distance * 2; el.animate(animation, speed, o.options.easing); for (var i = 1; i < times; i++) { el.animate(animation1, speed, o.options.easing).animate(animation2, speed, o.options.easing) }; el.animate(animation1, speed, o.options.easing).animate(animation, speed / 2, o.options.easing, function () { $.effects.restore(el, props); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(this, arguments) }); el.queue('fx', function () { el.dequeue() }); el.dequeue() }) } })(jQuery); (function ($, undefined) { $.effects.slide = function (o) { return this.queue(function () { var el = $(this), props = ['position', 'top', 'bottom', 'left', 'right']; var mode = $.effects.setMode(el, o.options.mode || 'show'); var direction = o.options.direction || 'left'; $.effects.save(el, props); el.show(); $.effects.createWrapper(el).css({ overflow: 'hidden' }); var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left'; var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg'; var distance = o.options.distance || (ref == 'top' ? el.outerHeight(true) : el.outerWidth(true)); if (mode == 'show') el.css(ref, motion == 'pos' ? (isNaN(distance) ? "-" + distance : -distance) : distance); var animation = {}; animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance; el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function () { if (mode == 'hide') el.hide(); $.effects.restore(el, props); $.effects.removeWrapper(el); if (o.callback) o.callback.apply(this, arguments); el.dequeue() } }) }) } })(jQuery); (function ($, undefined) { $.effects.transfer = function (o) { return this.queue(function () { var elem = $(this), target = $(o.options.to), endPosition = target.offset(), animation = { top: endPosition.top, left: endPosition.left, height: target.innerHeight(), width: target.innerWidth() }, startPosition = elem.offset(), transfer = $('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(o.options.className).css({ top: startPosition.top, left: startPosition.left, height: elem.innerHeight(), width: elem.innerWidth(), position: 'absolute' }).animate(animation, o.duration, o.options.easing, function () { transfer.remove(); (o.callback && o.callback.apply(elem[0], arguments)); elem.dequeue() }) }) } })(jQuery); (function ($, undefined) { $.widget("ui.accordion", { options: { active: 0, animated: "slide", autoHeight: true, clearStyle: false, collapsible: false, event: "click", fillSpace: false, header: "> li > :first-child,> :not(li):even", icons: { header: "ui-icon-triangle-1-e", headerSelected: "ui-icon-triangle-1-s" }, navigation: false, navigationFilter: function () { return this.href.toLowerCase() === location.href.toLowerCase() } }, _create: function () { var self = this, options = self.options; self.running = 0; self.element.addClass("ui-accordion ui-widget ui-helper-reset").children("li").addClass("ui-accordion-li-fix"); self.headers = self.element.find(options.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all").bind("mouseenter.accordion", function () { if (options.disabled) { return } $(this).addClass("ui-state-hover") }).bind("mouseleave.accordion", function () { if (options.disabled) { return } $(this).removeClass("ui-state-hover") }).bind("focus.accordion", function () { if (options.disabled) { return } $(this).addClass("ui-state-focus") }).bind("blur.accordion", function () { if (options.disabled) { return } $(this).removeClass("ui-state-focus") }); self.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom"); if (options.navigation) { var current = self.element.find("a").filter(options.navigationFilter).eq(0); if (current.length) { var header = current.closest(".ui-accordion-header"); if (header.length) { self.active = header } else { self.active = current.closest(".ui-accordion-content").prev() } } } self.active = self._findActive(self.active || options.active).addClass("ui-state-default ui-state-active").toggleClass("ui-corner-all").toggleClass("ui-corner-top"); self.active.next().addClass("ui-accordion-content-active"); self._createIcons(); self.resize(); self.element.attr("role", "tablist"); self.headers.attr("role", "tab").bind("keydown.accordion", function (event) { return self._keydown(event) }).next().attr("role", "tabpanel"); self.headers.not(self.active || "").attr({ "aria-expanded": "false", "aria-selected": "false", tabIndex: -1 }).next().hide(); if (!self.active.length) { self.headers.eq(0).attr("tabIndex", 0) } else { self.active.attr({ "aria-expanded": "true", "aria-selected": "true", tabIndex: 0 }) } if (!$.browser.safari) { self.headers.find("a").attr("tabIndex", -1) } if (options.event) { self.headers.bind(options.event.split(" ").join(".accordion ") + ".accordion", function (event) { self._clickHandler.call(self, event, this); event.preventDefault() }) } }, _createIcons: function () { var options = this.options; if (options.icons) { $("<span></span>").addClass("ui-icon " + options.icons.header).prependTo(this.headers); this.active.children(".ui-icon").toggleClass(options.icons.header).toggleClass(options.icons.headerSelected); this.element.addClass("ui-accordion-icons") } }, _destroyIcons: function () { this.headers.children(".ui-icon").remove(); this.element.removeClass("ui-accordion-icons") }, destroy: function () { var options = this.options; this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"); this.headers.unbind(".accordion").removeClass("ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("tabIndex"); this.headers.find("a").removeAttr("tabIndex"); this._destroyIcons(); var contents = this.headers.next().css("display", "").removeAttr("role").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled"); if (options.autoHeight || options.fillHeight) { contents.css("height", "") } return $.Widget.prototype.destroy.call(this) }, _setOption: function (key, value) { $.Widget.prototype._setOption.apply(this, arguments); if (key == "active") { this.activate(value) } if (key == "icons") { this._destroyIcons(); if (value) { this._createIcons() } } if (key == "disabled") { this.headers.add(this.headers.next())[value ? "addClass" : "removeClass"]("ui-accordion-disabled ui-state-disabled") } }, _keydown: function (event) { if (this.options.disabled || event.altKey || event.ctrlKey) { return } var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false; switch (event.keyCode) { case keyCode.RIGHT: case keyCode.DOWN: toFocus = this.headers[(currentIndex + 1) % length]; break; case keyCode.LEFT: case keyCode.UP: toFocus = this.headers[(currentIndex - 1 + length) % length]; break; case keyCode.SPACE: case keyCode.ENTER: this._clickHandler({ target: event.target }, event.target); event.preventDefault() } if (toFocus) { $(event.target).attr("tabIndex", -1); $(toFocus).attr("tabIndex", 0); toFocus.focus(); return false } return true }, resize: function () { var options = this.options, maxHeight; if (options.fillSpace) { if ($.browser.msie) { var defOverflow = this.element.parent().css("overflow"); this.element.parent().css("overflow", "hidden") } maxHeight = this.element.parent().height(); if ($.browser.msie) { this.element.parent().css("overflow", defOverflow) } this.headers.each(function () { maxHeight -= $(this).outerHeight(true) }); this.headers.next().each(function () { $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height())) }).css("overflow", "auto") } else if (options.autoHeight) { maxHeight = 0; this.headers.next().each(function () { maxHeight = Math.max(maxHeight, $(this).height("").height()) }).height(maxHeight) } return this }, activate: function (index) { this.options.active = index; var active = this._findActive(index)[0]; this._clickHandler({ target: active }, active); return this }, _findActive: function (selector) { return selector ? typeof selector === "number" ? this.headers.filter(":eq(" + selector + ")") : this.headers.not(this.headers.not(selector)) : selector === false ? $([]) : this.headers.filter(":eq(0)") }, _clickHandler: function (event, target) { var options = this.options; if (options.disabled) { return } if (!event.target) { if (!options.collapsible) { return } this.active.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(options.icons.headerSelected).addClass(options.icons.header); this.active.next().addClass("ui-accordion-content-active"); var toHide = this.active.next(), data = { options: options, newHeader: $([]), oldHeader: options.active, newContent: $([]), oldContent: toHide }, toShow = (this.active = $([])); this._toggle(toShow, toHide, data); return } var clicked = $(event.currentTarget || target), clickedIsActive = clicked[0] === this.active[0]; options.active = options.collapsible && clickedIsActive ? false : this.headers.index(clicked); if (this.running || (!options.collapsible && clickedIsActive)) { return } var active = this.active, toShow = clicked.next(), toHide = this.active.next(), data = { options: options, newHeader: clickedIsActive && options.collapsible ? $([]) : clicked, oldHeader: this.active, newContent: clickedIsActive && options.collapsible ? $([]) : toShow, oldContent: toHide }, down = this.headers.index(this.active[0]) > this.headers.index(clicked[0]); this.active = clickedIsActive ? $([]) : clicked; this._toggle(toShow, toHide, data, clickedIsActive, down); active.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(options.icons.headerSelected).addClass(options.icons.header); if (!clickedIsActive) { clicked.removeClass("ui-state-default ui-corner-all").addClass("ui-state-active ui-corner-top").children(".ui-icon").removeClass(options.icons.header).addClass(options.icons.headerSelected); clicked.next().addClass("ui-accordion-content-active") } return }, _toggle: function (toShow, toHide, data, clickedIsActive, down) { var self = this, options = self.options; self.toShow = toShow; self.toHide = toHide; self.data = data; var complete = function () { if (!self) { return } return self._completed.apply(self, arguments) }; self._trigger("changestart", null, self.data); self.running = toHide.size() === 0 ? toShow.size() : toHide.size(); if (options.animated) { var animOptions = {}; if (options.collapsible && clickedIsActive) { animOptions = { toShow: $([]), toHide: toHide, complete: complete, down: down, autoHeight: options.autoHeight || options.fillSpace } } else { animOptions = { toShow: toShow, toHide: toHide, complete: complete, down: down, autoHeight: options.autoHeight || options.fillSpace } } if (!options.proxied) { options.proxied = options.animated } if (!options.proxiedDuration) { options.proxiedDuration = options.duration } options.animated = $.isFunction(options.proxied) ? options.proxied(animOptions) : options.proxied; options.duration = $.isFunction(options.proxiedDuration) ? options.proxiedDuration(animOptions) : options.proxiedDuration; var animations = $.ui.accordion.animations, duration = options.duration, easing = options.animated; if (easing && !animations[easing] && !$.easing[easing]) { easing = "slide" } if (!animations[easing]) { animations[easing] = function (options) { this.slide(options, { easing: easing, duration: duration || 700 }) } } animations[easing](animOptions) } else { if (options.collapsible && clickedIsActive) { toShow.toggle() } else { toHide.hide(); toShow.show() } complete(true) } toHide.prev().attr({ "aria-expanded": "false", "aria-selected": "false", tabIndex: -1 }).blur(); toShow.prev().attr({ "aria-expanded": "true", "aria-selected": "true", tabIndex: 0 }).focus() }, _completed: function (cancel) { this.running = cancel ? 0 : --this.running; if (this.running) { return } if (this.options.clearStyle) { this.toShow.add(this.toHide).css({ height: "", overflow: "" }) } this.toHide.removeClass("ui-accordion-content-active"); if (this.toHide.length) { this.toHide.parent()[0].className = this.toHide.parent()[0].className } this._trigger("change", null, this.data) } }); $.extend($.ui.accordion, { version: "1.8.22", animations: { slide: function (options, additions) { options = $.extend({ easing: "swing", duration: 300 }, options, additions); if (!options.toHide.size()) { options.toShow.animate({ height: "show", paddingTop: "show", paddingBottom: "show" }, options); return } if (!options.toShow.size()) { options.toHide.animate({ height: "hide", paddingTop: "hide", paddingBottom: "hide" }, options); return } var overflow = options.toShow.css("overflow"), percentDone = 0, showProps = {}, hideProps = {}, fxAttrs = ["height", "paddingTop", "paddingBottom"], originalWidth; var s = options.toShow; originalWidth = s[0].style.width; s.width(s.parent().width() - parseFloat(s.css("paddingLeft")) - parseFloat(s.css("paddingRight")) - (parseFloat(s.css("borderLeftWidth")) || 0) - (parseFloat(s.css("borderRightWidth")) || 0)); $.each(fxAttrs, function (i, prop) { hideProps[prop] = "hide"; var parts = ("" + $.css(options.toShow[0], prop)).match(/^([\d+-.]+)(.*)$/); showProps[prop] = { value: parts[1], unit: parts[2] || "px" } }); options.toShow.css({ height: 0, overflow: "hidden" }).show(); options.toHide.filter(":hidden").each(options.complete).end().filter(":visible").animate(hideProps, { step: function (now, settings) { if (settings.prop == "height") { percentDone = (settings.end - settings.start === 0) ? 0 : (settings.now - settings.start) / (settings.end - settings.start) } options.toShow[0].style[settings.prop] = (percentDone * showProps[settings.prop].value) + showProps[settings.prop].unit }, duration: options.duration, easing: options.easing, complete: function () { if (!options.autoHeight) { options.toShow.css("height", "") } options.toShow.css({ width: originalWidth, overflow: overflow }); options.complete() } }) }, bounceslide: function (options) { this.slide(options, { easing: options.down ? "easeOutBounce" : "swing", duration: options.down ? 1000 : 200 }) } } }) })(jQuery); (function ($, undefined) { var requestIndex = 0; $.widget("ui.autocomplete", { options: { appendTo: "body", autoFocus: false, delay: 300, minLength: 1, position: { my: "left top", at: "left bottom", collision: "none" }, source: null }, pending: 0, _create: function () { var self = this, doc = this.element[0].ownerDocument, suppressKeyPress; this.isMultiLine = this.element.is("textarea"); this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off").attr({ role: "textbox", "aria-autocomplete": "list", "aria-haspopup": "true" }).bind("keydown.autocomplete", function (event) { if (self.options.disabled || self.element.propAttr("readOnly")) { return } suppressKeyPress = false; var keyCode = $.ui.keyCode; switch (event.keyCode) { case keyCode.PAGE_UP: self._move("previousPage", event); break; case keyCode.PAGE_DOWN: self._move("nextPage", event); break; case keyCode.UP: self._keyEvent("previous", event); break; case keyCode.DOWN: self._keyEvent("next", event); break; case keyCode.ENTER: case keyCode.NUMPAD_ENTER: if (self.menu.active) { suppressKeyPress = true; event.preventDefault() } case keyCode.TAB: if (!self.menu.active) { return } self.menu.select(event); break; case keyCode.ESCAPE: self.element.val(self.term); self.close(event); break; default: clearTimeout(self.searching); self.searching = setTimeout(function () { if (self.term != self.element.val()) { self.selectedItem = null; self.search(null, event) } }, self.options.delay); break } }).bind("keypress.autocomplete", function (event) { if (suppressKeyPress) { suppressKeyPress = false; event.preventDefault() } }).bind("focus.autocomplete", function () { if (self.options.disabled) { return } self.selectedItem = null; self.previous = self.element.val() }).bind("blur.autocomplete", function (event) { if (self.options.disabled) { return } clearTimeout(self.searching); self.closing = setTimeout(function () { self.close(event); self._change(event) }, 150) }); this._initSource(); this.menu = $("<ul></ul>").addClass("ui-autocomplete").appendTo($(this.options.appendTo || "body", doc)[0]).mousedown(function (event) { var menuElement = self.menu.element[0]; if (!$(event.target).closest(".ui-menu-item").length) { setTimeout(function () { $(document).one('mousedown', function (event) { if (event.target !== self.element[0] && event.target !== menuElement && !$.ui.contains(menuElement, event.target)) { self.close() } }) }, 1) } setTimeout(function () { clearTimeout(self.closing) }, 13) }).menu({ focus: function (event, ui) { var item = ui.item.data("item.autocomplete"); if (false !== self._trigger("focus", event, { item: item })) { if (/^key/.test(event.originalEvent.type)) { self.element.val(item.value) } } }, selected: function (event, ui) { var item = ui.item.data("item.autocomplete"), previous = self.previous; if (self.element[0] !== doc.activeElement) { self.element.focus(); self.previous = previous; setTimeout(function () { self.previous = previous; self.selectedItem = item }, 1) } if (false !== self._trigger("select", event, { item: item })) { self.element.val(item.value) } self.term = self.element.val(); self.close(event); self.selectedItem = item }, blur: function (event, ui) { if (self.menu.element.is(":visible") && (self.element.val() !== self.term)) { self.element.val(self.term) } } }).zIndex(this.element.zIndex() + 1).css({ top: 0, left: 0 }).hide().data("menu"); if ($.fn.bgiframe) { this.menu.element.bgiframe() } self.beforeunloadHandler = function () { self.element.removeAttr("autocomplete") }; $(window).bind("beforeunload", self.beforeunloadHandler) }, destroy: function () { this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup"); this.menu.element.remove(); $(window).unbind("beforeunload", this.beforeunloadHandler); $.Widget.prototype.destroy.call(this) }, _setOption: function (key, value) { $.Widget.prototype._setOption.apply(this, arguments); if (key === "source") { this._initSource() } if (key === "appendTo") { this.menu.element.appendTo($(value || "body", this.element[0].ownerDocument)[0]) } if (key === "disabled" && value && this.xhr) { this.xhr.abort() } }, _initSource: function () { var self = this, array, url; if ($.isArray(this.options.source)) { array = this.options.source; this.source = function (request, response) { response($.ui.autocomplete.filter(array, request.term)) } } else if (typeof this.options.source === "string") { url = this.options.source; this.source = function (request, response) { if (self.xhr) { self.xhr.abort() } self.xhr = $.ajax({ url: url, data: request, dataType: "json", success: function (data, status) { response(data) }, error: function () { response([]) } }) } } else { this.source = this.options.source } }, search: function (value, event) { value = value != null ? value : this.element.val(); this.term = this.element.val(); if (value.length < this.options.minLength) { return this.close(event) } clearTimeout(this.closing); if (this._trigger("search", event) === false) { return } return this._search(value) }, _search: function (value) { this.pending++; this.element.addClass("ui-autocomplete-loading"); this.source({ term: value }, this._response()) }, _response: function () { var that = this, index = ++requestIndex; return function (content) { if (index === requestIndex) { that.__response(content) } that.pending--; if (!that.pending) { that.element.removeClass("ui-autocomplete-loading") } } }, __response: function (content) { if (!this.options.disabled && content && content.length) { content = this._normalize(content); this._suggest(content); this._trigger("open") } else { this.close() } }, close: function (event) { clearTimeout(this.closing); if (this.menu.element.is(":visible")) { this.menu.element.hide(); this.menu.deactivate(); this._trigger("close", event) } }, _change: function (event) { if (this.previous !== this.element.val()) { this._trigger("change", event, { item: this.selectedItem }) } }, _normalize: function (items) { if (items.length && items[0].label && items[0].value) { return items } return $.map(items, function (item) { if (typeof item === "string") { return { label: item, value: item } } return $.extend({ label: item.label || item.value, value: item.value || item.label }, item) }) }, _suggest: function (items) { var ul = this.menu.element.empty().zIndex(this.element.zIndex() + 1); this._renderMenu(ul, items); this.menu.deactivate(); this.menu.refresh(); ul.show(); this._resizeMenu(); ul.position($.extend({ of: this.element }, this.options.position)); if (this.options.autoFocus) { this.menu.next(new $.Event("mouseover")) } }, _resizeMenu: function () { var ul = this.menu.element; ul.outerWidth(Math.max(ul.width("").outerWidth() + 1, this.element.outerWidth())) }, _renderMenu: function (ul, items) { var self = this; $.each(items, function (index, item) { self._renderItem(ul, item) }) }, _renderItem: function (ul, item) { return $("<li></li>").data("item.autocomplete", item).append($("<a></a>").text(item.label)).appendTo(ul) }, _move: function (direction, event) { if (!this.menu.element.is(":visible")) { this.search(null, event); return } if (this.menu.first() && /^previous/.test(direction) || this.menu.last() && /^next/.test(direction)) { this.element.val(this.term); this.menu.deactivate(); return } this.menu[direction](event) }, widget: function () { return this.menu.element }, _keyEvent: function (keyEvent, event) { if (!this.isMultiLine || this.menu.element.is(":visible")) { this._move(keyEvent, event); event.preventDefault() } } }); $.extend($.ui.autocomplete, { escapeRegex: function (value) { return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") }, filter: function (array, term) { var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i"); return $.grep(array, function (value) { return matcher.test(value.label || value.value || value) }) } }) }(jQuery)); (function ($) { $.widget("ui.menu", { _create: function () { var self = this; this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({ role: "listbox", "aria-activedescendant": "ui-active-menuitem" }).click(function (event) { if (!$(event.target).closest(".ui-menu-item a").length) { return } event.preventDefault(); self.select(event) }); this.refresh() }, refresh: function () { var self = this; var items = this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role", "menuitem"); items.children("a").addClass("ui-corner-all").attr("tabindex", -1).mouseenter(function (event) { self.activate(event, $(this).parent()) }).mouseleave(function () { self.deactivate() }) }, activate: function (event, item) { this.deactivate(); if (this.hasScroll()) { var offset = item.offset().top - this.element.offset().top, scroll = this.element.scrollTop(), elementHeight = this.element.height(); if (offset < 0) { this.element.scrollTop(scroll + offset) } else if (offset >= elementHeight) { this.element.scrollTop(scroll + offset - elementHeight + item.height()) } } this.active = item.eq(0).children("a").addClass("ui-state-hover").attr("id", "ui-active-menuitem").end(); this._trigger("focus", event, { item: item }) }, deactivate: function () { if (!this.active) { return } this.active.children("a").removeClass("ui-state-hover").removeAttr("id"); this._trigger("blur"); this.active = null }, next: function (event) { this.move("next", ".ui-menu-item:first", event) }, previous: function (event) { this.move("prev", ".ui-menu-item:last", event) }, first: function () { return this.active && !this.active.prevAll(".ui-menu-item").length }, last: function () { return this.active && !this.active.nextAll(".ui-menu-item").length }, move: function (direction, edge, event) { if (!this.active) { this.activate(event, this.element.children(edge)); return } var next = this.active[direction + "All"](".ui-menu-item").eq(0); if (next.length) { this.activate(event, next) } else { this.activate(event, this.element.children(edge)) } }, nextPage: function (event) { if (this.hasScroll()) { if (!this.active || this.last()) { this.activate(event, this.element.children(".ui-menu-item:first")); return } var base = this.active.offset().top, height = this.element.height(), result = this.element.children(".ui-menu-item").filter(function () { var close = $(this).offset().top - base - height + $(this).height(); return close < 10 && close > -10 }); if (!result.length) { result = this.element.children(".ui-menu-item:last") } this.activate(event, result) } else { this.activate(event, this.element.children(".ui-menu-item").filter(!this.active || this.last() ? ":first" : ":last")) } }, previousPage: function (event) { if (this.hasScroll()) { if (!this.active || this.first()) { this.activate(event, this.element.children(".ui-menu-item:last")); return } var base = this.active.offset().top, height = this.element.height(), result = this.element.children(".ui-menu-item").filter(function () { var close = $(this).offset().top - base + height - $(this).height(); return close < 10 && close > -10 }); if (!result.length) { result = this.element.children(".ui-menu-item:first") } this.activate(event, result) } else { this.activate(event, this.element.children(".ui-menu-item").filter(!this.active || this.first() ? ":last" : ":first")) } }, hasScroll: function () { return this.element.height() < this.element[$.fn.prop ? "prop" : "attr"]("scrollHeight") }, select: function (event) { this._trigger("selected", event, { item: this.active }) } }) }(jQuery)); (function ($, undefined) { var lastActive, startXPos, startYPos, clickDragged, baseClasses = "ui-button ui-widget ui-state-default ui-corner-all", stateClasses = "ui-state-hover ui-state-active ", typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only", formResetHandler = function () { var buttons = $(this).find(":ui-button"); setTimeout(function () { buttons.button("refresh") }, 1) }, radioGroup = function (radio) { var name = radio.name, form = radio.form, radios = $([]); if (name) { if (form) { radios = $(form).find("[name='" + name + "']") } else { radios = $("[name='" + name + "']", radio.ownerDocument).filter(function () { return !this.form }) } } return radios }; $.widget("ui.button", { options: { disabled: null, text: true, label: null, icons: { primary: null, secondary: null } }, _create: function () { this.element.closest("form").unbind("reset.button").bind("reset.button", formResetHandler); if (typeof this.options.disabled !== "boolean") { this.options.disabled = !!this.element.propAttr("disabled") } else { this.element.propAttr("disabled", this.options.disabled) } this._determineButtonType(); this.hasTitle = !!this.buttonElement.attr("title"); var self = this, options = this.options, toggleButton = this.type === "checkbox" || this.type === "radio", hoverClass = "ui-state-hover" + (!toggleButton ? " ui-state-active" : ""), focusClass = "ui-state-focus"; if (options.label === null) { options.label = this.buttonElement.html() } this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter.button", function () { if (options.disabled) { return } $(this).addClass("ui-state-hover"); if (this === lastActive) { $(this).addClass("ui-state-active") } }).bind("mouseleave.button", function () { if (options.disabled) { return } $(this).removeClass(hoverClass) }).bind("click.button", function (event) { if (options.disabled) { event.preventDefault(); event.stopImmediatePropagation() } }); this.element.bind("focus.button", function () { self.buttonElement.addClass(focusClass) }).bind("blur.button", function () { self.buttonElement.removeClass(focusClass) }); if (toggleButton) { this.element.bind("change.button", function () { if (clickDragged) { return } self.refresh() }); this.buttonElement.bind("mousedown.button", function (event) { if (options.disabled) { return } clickDragged = false; startXPos = event.pageX; startYPos = event.pageY }).bind("mouseup.button", function (event) { if (options.disabled) { return } if (startXPos !== event.pageX || startYPos !== event.pageY) { clickDragged = true } }) } if (this.type === "checkbox") { this.buttonElement.bind("click.button", function () { if (options.disabled || clickDragged) { return false } $(this).toggleClass("ui-state-active"); self.buttonElement.attr("aria-pressed", self.element[0].checked) }) } else if (this.type === "radio") { this.buttonElement.bind("click.button", function () { if (options.disabled || clickDragged) { return false } $(this).addClass("ui-state-active"); self.buttonElement.attr("aria-pressed", "true"); var radio = self.element[0]; radioGroup(radio).not(radio).map(function () { return $(this).button("widget")[0] }).removeClass("ui-state-active").attr("aria-pressed", "false") }) } else { this.buttonElement.bind("mousedown.button", function () { if (options.disabled) { return false } $(this).addClass("ui-state-active"); lastActive = this; $(document).one("mouseup", function () { lastActive = null }) }).bind("mouseup.button", function () { if (options.disabled) { return false } $(this).removeClass("ui-state-active") }).bind("keydown.button", function (event) { if (options.disabled) { return false } if (event.keyCode == $.ui.keyCode.SPACE || event.keyCode == $.ui.keyCode.ENTER) { $(this).addClass("ui-state-active") } }).bind("keyup.button", function () { $(this).removeClass("ui-state-active") }); if (this.buttonElement.is("a")) { this.buttonElement.keyup(function (event) { if (event.keyCode === $.ui.keyCode.SPACE) { $(this).click() } }) } } this._setOption("disabled", options.disabled); this._resetButton() }, _determineButtonType: function () { if (this.element.is(":checkbox")) { this.type = "checkbox" } else if (this.element.is(":radio")) { this.type = "radio" } else if (this.element.is("input")) { this.type = "input" } else { this.type = "button" } if (this.type === "checkbox" || this.type === "radio") { var ancestor = this.element.parents().filter(":last"), labelSelector = "label[for='" + this.element.attr("id") + "']"; this.buttonElement = ancestor.find(labelSelector); if (!this.buttonElement.length) { ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings(); this.buttonElement = ancestor.filter(labelSelector); if (!this.buttonElement.length) { this.buttonElement = ancestor.find(labelSelector) } } this.element.addClass("ui-helper-hidden-accessible"); var checked = this.element.is(":checked"); if (checked) { this.buttonElement.addClass("ui-state-active") } this.buttonElement.attr("aria-pressed", checked) } else { this.buttonElement = this.element } }, widget: function () { return this.buttonElement }, destroy: function () { this.element.removeClass("ui-helper-hidden-accessible"); this.buttonElement.removeClass(baseClasses + " " + stateClasses + " " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()); if (!this.hasTitle) { this.buttonElement.removeAttr("title") } $.Widget.prototype.destroy.call(this) }, _setOption: function (key, value) { $.Widget.prototype._setOption.apply(this, arguments); if (key === "disabled") { if (value) { this.element.propAttr("disabled", true) } else { this.element.propAttr("disabled", false) } return } this._resetButton() }, refresh: function () { var isDisabled = this.element.is(":disabled"); if (isDisabled !== this.options.disabled) { this._setOption("disabled", isDisabled) } if (this.type === "radio") { radioGroup(this.element[0]).each(function () { if ($(this).is(":checked")) { $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true") } else { $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false") } }) } else if (this.type === "checkbox") { if (this.element.is(":checked")) { this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true") } else { this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false") } } }, _resetButton: function () { if (this.type === "input") { if (this.options.label) { this.element.val(this.options.label) } return } var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $("<span></span>", this.element[0].ownerDocument).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = []; if (icons.primary || icons.secondary) { if (this.options.text) { buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : (icons.primary ? "-primary" : "-secondary"))) } if (icons.primary) { buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>") } if (icons.secondary) { buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>") } if (!this.options.text) { buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only"); if (!this.hasTitle) { buttonElement.attr("title", buttonText) } } } else { buttonClasses.push("ui-button-text-only") } buttonElement.addClass(buttonClasses.join(" ")) } }); $.widget("ui.buttonset", { options: { items: ":button, :submit, :reset, :checkbox, :radio, a, :data(button)" }, _create: function () { this.element.addClass("ui-buttonset") }, _init: function () { this.refresh() }, _setOption: function (key, value) { if (key === "disabled") { this.buttons.button("option", key, value) } $.Widget.prototype._setOption.apply(this, arguments) }, refresh: function () { var rtl = this.element.css("direction") === "rtl"; this.buttons = this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function () { return $(this).button("widget")[0] }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end() }, destroy: function () { this.element.removeClass("ui-buttonset"); this.buttons.map(function () { return $(this).button("widget")[0] }).removeClass("ui-corner-left ui-corner-right").end().button("destroy"); $.Widget.prototype.destroy.call(this) } }) }(jQuery)); (function ($, undefined) { $.extend($.ui, { datepicker: { version: "1.8.22" } }); var PROP_NAME = 'datepicker'; var dpuuid = new Date().getTime(); var instActive; function Datepicker() { this.debug = false; this._curInst = null; this._keyEvent = false; this._disabledInputs = []; this._datepickerShowing = false; this._inDialog = false; this._mainDivId = 'ui-datepicker-div'; this._inlineClass = 'ui-datepicker-inline'; this._appendClass = 'ui-datepicker-append'; this._triggerClass = 'ui-datepicker-trigger'; this._dialogClass = 'ui-datepicker-dialog'; this._disableClass = 'ui-datepicker-disabled'; this._unselectableClass = 'ui-datepicker-unselectable'; this._currentClass = 'ui-datepicker-current-day'; this._dayOverClass = 'ui-datepicker-days-cell-over'; this.regional = []; this.regional[''] = { closeText: 'Done', prevText: 'Prev', nextText: 'Next', currentText: 'Today', monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'], weekHeader: 'Wk', dateFormat: 'mm/dd/yy', firstDay: 0, isRTL: false, showMonthAfterYear: false, yearSuffix: '' }; this._defaults = { showOn: 'focus', showAnim: 'fadeIn', showOptions: {}, defaultDate: null, appendText: '', buttonText: '...', buttonImage: '', buttonImageOnly: false, hideIfNoPrevNext: false, navigationAsDateFormat: false, gotoCurrent: false, changeMonth: false, changeYear: false, yearRange: 'c-10:c+10', showOtherMonths: false, selectOtherMonths: false, showWeek: false, calculateWeek: this.iso8601Week, shortYearCutoff: '+10', minDate: null, maxDate: null, duration: 'fast', beforeShowDay: null, beforeShow: null, onSelect: null, onChangeMonthYear: null, onClose: null, numberOfMonths: 1, showCurrentAtPos: 0, stepMonths: 1, stepBigMonths: 12, altField: '', altFormat: '', constrainInput: true, showButtonPanel: false, autoSize: false, disabled: false }; $.extend(this._defaults, this.regional['']); this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')) } $.extend(Datepicker.prototype, { markerClassName: 'hasDatepicker', maxRows: 4, log: function () { if (this.debug) console.log.apply('', arguments) }, _widgetDatepicker: function () { return this.dpDiv }, setDefaults: function (settings) { extendRemove(this._defaults, settings || {}); return this }, _attachDatepicker: function (target, settings) { var inlineSettings = null; for (var attrName in this._defaults) { var attrValue = target.getAttribute('date:' + attrName); if (attrValue) { inlineSettings = inlineSettings || {}; try { inlineSettings[attrName] = eval(attrValue) } catch (err) { inlineSettings[attrName] = attrValue } } } var nodeName = target.nodeName.toLowerCase(); var inline = (nodeName == 'div' || nodeName == 'span'); if (!target.id) { this.uuid += 1; target.id = 'dp' + this.uuid } var inst = this._newInst($(target), inline); inst.settings = $.extend({}, settings || {}, inlineSettings || {}); if (nodeName == 'input') { this._connectDatepicker(target, inst) } else if (inline) { this._inlineDatepicker(target, inst) } }, _newInst: function (target, inline) { var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); return { id: id, input: target, selectedDay: 0, selectedMonth: 0, selectedYear: 0, drawMonth: 0, drawYear: 0, inline: inline, dpDiv: (!inline ? this.dpDiv : bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))) } }, _connectDatepicker: function (target, inst) { var input = $(target); inst.append = $([]); inst.trigger = $([]); if (input.hasClass(this.markerClassName)) return; this._attachments(input, inst); input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker", function (event, key, value) { inst.settings[key] = value }).bind("getData.datepicker", function (event, key) { return this._get(inst, key) }); this._autoSize(inst); $.data(target, PROP_NAME, inst); if (inst.settings.disabled) { this._disableDatepicker(target) } }, _attachments: function (input, inst) { var appendText = this._get(inst, 'appendText'); var isRTL = this._get(inst, 'isRTL'); if (inst.append) inst.append.remove(); if (appendText) { inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>'); input[isRTL ? 'before' : 'after'](inst.append) } input.unbind('focus', this._showDatepicker); if (inst.trigger) inst.trigger.remove(); var showOn = this._get(inst, 'showOn'); if (showOn == 'focus' || showOn == 'both') input.focus(this._showDatepicker); if (showOn == 'button' || showOn == 'both') { var buttonText = this._get(inst, 'buttonText'); var buttonImage = this._get(inst, 'buttonImage'); inst.trigger = $(this._get(inst, 'buttonImageOnly') ? $('<img/>').addClass(this._triggerClass).attr({ src: buttonImage, alt: buttonText, title: buttonText }) : $('<button type="button"></button>').addClass(this._triggerClass).html(buttonImage == '' ? buttonText : $('<img/>').attr({ src: buttonImage, alt: buttonText, title: buttonText }))); input[isRTL ? 'before' : 'after'](inst.trigger); inst.trigger.click(function () { if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0]) $.datepicker._hideDatepicker(); else if ($.datepicker._datepickerShowing && $.datepicker._lastInput != input[0]) { $.datepicker._hideDatepicker(); $.datepicker._showDatepicker(input[0]) } else $.datepicker._showDatepicker(input[0]); return false }) } }, _autoSize: function (inst) { if (this._get(inst, 'autoSize') && !inst.inline) { var date = new Date(2009, 12 - 1, 20); var dateFormat = this._get(inst, 'dateFormat'); if (dateFormat.match(/[DM]/)) { var findMax = function (names) { var max = 0; var maxI = 0; for (var i = 0; i < names.length; i++) { if (names[i].length > max) { max = names[i].length; maxI = i } } return maxI }; date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ? 'monthNames' : 'monthNamesShort')))); date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ? 'dayNames' : 'dayNamesShort'))) + 20 - date.getDay()) } inst.input.attr('size', this._formatDate(inst, date).length) } }, _inlineDatepicker: function (target, inst) { var divSpan = $(target); if (divSpan.hasClass(this.markerClassName)) return; divSpan.addClass(this.markerClassName).append(inst.dpDiv).bind("setData.datepicker", function (event, key, value) { inst.settings[key] = value }).bind("getData.datepicker", function (event, key) { return this._get(inst, key) }); $.data(target, PROP_NAME, inst); this._setDate(inst, this._getDefaultDate(inst), true); this._updateDatepicker(inst); this._updateAlternate(inst); if (inst.settings.disabled) { this._disableDatepicker(target) } inst.dpDiv.css("display", "block") }, _dialogDatepicker: function (input, date, onSelect, settings, pos) { var inst = this._dialogInst; if (!inst) { this.uuid += 1; var id = 'dp' + this.uuid; this._dialogInput = $('<input type="text" id="' + id + '" style="position: absolute; top: -100px; width: 0px;"/>'); this._dialogInput.keydown(this._doKeyDown); $('body').append(this._dialogInput); inst = this._dialogInst = this._newInst(this._dialogInput, false); inst.settings = {}; $.data(this._dialogInput[0], PROP_NAME, inst) } extendRemove(inst.settings, settings || {}); date = (date && date.constructor == Date ? this._formatDate(inst, date) : date); this._dialogInput.val(date); this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null); if (!this._pos) { var browserWidth = document.documentElement.clientWidth; var browserHeight = document.documentElement.clientHeight; var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft; var scrollY = document.documentElement.scrollTop || document.body.scrollTop; this._pos = [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY] } this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px'); inst.settings.onSelect = onSelect; this._inDialog = true; this.dpDiv.addClass(this._dialogClass); this._showDatepicker(this._dialogInput[0]); if ($.blockUI) $.blockUI(this.dpDiv); $.data(this._dialogInput[0], PROP_NAME, inst); return this }, _destroyDatepicker: function (target) { var $target = $(target); var inst = $.data(target, PROP_NAME); if (!$target.hasClass(this.markerClassName)) { return } var nodeName = target.nodeName.toLowerCase(); $.removeData(target, PROP_NAME); if (nodeName == 'input') { inst.append.remove(); inst.trigger.remove(); $target.removeClass(this.markerClassName).unbind('focus', this._showDatepicker).unbind('keydown', this._doKeyDown).unbind('keypress', this._doKeyPress).unbind('keyup', this._doKeyUp) } else if (nodeName == 'div' || nodeName == 'span') $target.removeClass(this.markerClassName).empty() }, _enableDatepicker: function (target) { var $target = $(target); var inst = $.data(target, PROP_NAME); if (!$target.hasClass(this.markerClassName)) { return } var nodeName = target.nodeName.toLowerCase(); if (nodeName == 'input') { target.disabled = false; inst.trigger.filter('button').each(function () { this.disabled = false }).end().filter('img').css({ opacity: '1.0', cursor: '' }) } else if (nodeName == 'div' || nodeName == 'span') { var inline = $target.children('.' + this._inlineClass); inline.children().removeClass('ui-state-disabled'); inline.find("select.ui-datepicker-month, select.ui-datepicker-year").removeAttr("disabled") } this._disabledInputs = $.map(this._disabledInputs, function (value) { return (value == target ? null : value) }) }, _disableDatepicker: function (target) { var $target = $(target); var inst = $.data(target, PROP_NAME); if (!$target.hasClass(this.markerClassName)) { return } var nodeName = target.nodeName.toLowerCase(); if (nodeName == 'input') { target.disabled = true; inst.trigger.filter('button').each(function () { this.disabled = true }).end().filter('img').css({ opacity: '0.5', cursor: 'default' }) } else if (nodeName == 'div' || nodeName == 'span') { var inline = $target.children('.' + this._inlineClass); inline.children().addClass('ui-state-disabled'); inline.find("select.ui-datepicker-month, select.ui-datepicker-year").attr("disabled", "disabled") } this._disabledInputs = $.map(this._disabledInputs, function (value) { return (value == target ? null : value) }); this._disabledInputs[this._disabledInputs.length] = target }, _isDisabledDatepicker: function (target) { if (!target) { return false } for (var i = 0; i < this._disabledInputs.length; i++) { if (this._disabledInputs[i] == target) return true } return false }, _getInst: function (target) { try { return $.data(target, PROP_NAME) } catch (err) { throw 'Missing instance data for this datepicker' } }, _optionDatepicker: function (target, name, value) { var inst = this._getInst(target); if (arguments.length == 2 && typeof name == 'string') { return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) : (inst ? (name == 'all' ? $.extend({}, inst.settings) : this._get(inst, name)) : null)) } var settings = name || {}; if (typeof name == 'string') { settings = {}; settings[name] = value } if (inst) { if (this._curInst == inst) { this._hideDatepicker() } var date = this._getDateDatepicker(target, true); var minDate = this._getMinMaxDate(inst, 'min'); var maxDate = this._getMinMaxDate(inst, 'max'); extendRemove(inst.settings, settings); if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined) inst.settings.minDate = this._formatDate(inst, minDate); if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined) inst.settings.maxDate = this._formatDate(inst, maxDate); this._attachments($(target), inst); this._autoSize(inst); this._setDate(inst, date); this._updateAlternate(inst); this._updateDatepicker(inst) } }, _changeDatepicker: function (target, name, value) { this._optionDatepicker(target, name, value) }, _refreshDatepicker: function (target) { var inst = this._getInst(target); if (inst) { this._updateDatepicker(inst) } }, _setDateDatepicker: function (target, date) { var inst = this._getInst(target); if (inst) { this._setDate(inst, date); this._updateDatepicker(inst); this._updateAlternate(inst) } }, _getDateDatepicker: function (target, noDefault) { var inst = this._getInst(target); if (inst && !inst.inline) this._setDateFromField(inst, noDefault); return (inst ? this._getDate(inst) : null) }, _doKeyDown: function (event) { var inst = $.datepicker._getInst(event.target); var handled = true; var isRTL = inst.dpDiv.is('.ui-datepicker-rtl'); inst._keyEvent = true; if ($.datepicker._datepickerShowing) switch (event.keyCode) { case 9: $.datepicker._hideDatepicker(); handled = false; break; case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + $.datepicker._currentClass + ')', inst.dpDiv); if (sel[0]) $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]); var onSelect = $.datepicker._get(inst, 'onSelect'); if (onSelect) { var dateStr = $.datepicker._formatDate(inst); onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]) } else $.datepicker._hideDatepicker(); return false; break; case 27: $.datepicker._hideDatepicker(); break; case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths')), 'M'); break; case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths')), 'M'); break; case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target); handled = event.ctrlKey || event.metaKey; break; case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target); handled = event.ctrlKey || event.metaKey; break; case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D'); handled = event.ctrlKey || event.metaKey; if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths')), 'M'); break; case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D'); handled = event.ctrlKey || event.metaKey; break; case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D'); handled = event.ctrlKey || event.metaKey; if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths')), 'M'); break; case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D'); handled = event.ctrlKey || event.metaKey; break; default: handled = false } else if (event.keyCode == 36 && event.ctrlKey) $.datepicker._showDatepicker(this); else { handled = false } if (handled) { event.preventDefault(); event.stopPropagation() } }, _doKeyPress: function (event) { var inst = $.datepicker._getInst(event.target); if ($.datepicker._get(inst, 'constrainInput')) { var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')); var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode); return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1) } }, _doKeyUp: function (event) { var inst = $.datepicker._getInst(event.target); if (inst.input.val() != inst.lastVal) { try { var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), (inst.input ? inst.input.val() : null), $.datepicker._getFormatConfig(inst)); if (date) { $.datepicker._setDateFromField(inst); $.datepicker._updateAlternate(inst); $.datepicker._updateDatepicker(inst) } } catch (err) { $.datepicker.log(err) } } return true }, _showDatepicker: function (input) { input = input.target || input; if (input.nodeName.toLowerCase() != 'input') input = $('input', input.parentNode)[0]; if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) return; var inst = $.datepicker._getInst(input); if ($.datepicker._curInst && $.datepicker._curInst != inst) { $.datepicker._curInst.dpDiv.stop(true, true); if (inst && $.datepicker._datepickerShowing) { $.datepicker._hideDatepicker($.datepicker._curInst.input[0]) } } var beforeShow = $.datepicker._get(inst, 'beforeShow'); var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {}; if (beforeShowSettings === false) { return } extendRemove(inst.settings, beforeShowSettings); inst.lastVal = null; $.datepicker._lastInput = input; $.datepicker._setDateFromField(inst); if ($.datepicker._inDialog) input.value = ''; if (!$.datepicker._pos) { $.datepicker._pos = $.datepicker._findPos(input); $.datepicker._pos[1] += input.offsetHeight } var isFixed = false; $(input).parents().each(function () { isFixed |= $(this).css('position') == 'fixed'; return !isFixed }); if (isFixed && $.browser.opera) { $.datepicker._pos[0] -= document.documentElement.scrollLeft; $.datepicker._pos[1] -= document.documentElement.scrollTop } var offset = { left: $.datepicker._pos[0], top: $.datepicker._pos[1] }; $.datepicker._pos = null; inst.dpDiv.empty(); inst.dpDiv.css({ position: 'absolute', display: 'block', top: '-1000px' }); $.datepicker._updateDatepicker(inst); offset = $.datepicker._checkOffset(inst, offset, isFixed); inst.dpDiv.css({ position: ($.datepicker._inDialog && $.blockUI ? 'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none', left: offset.left + 'px', top: offset.top + 'px' }); if (!inst.inline) { var showAnim = $.datepicker._get(inst, 'showAnim'); var duration = $.datepicker._get(inst, 'duration'); var postProcess = function () { var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); if (!!cover.length) { var borders = $.datepicker._getBorders(inst.dpDiv); cover.css({ left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight() }) } }; inst.dpDiv.zIndex($(input).zIndex() + 1); $.datepicker._datepickerShowing = true; if ($.effects && $.effects[showAnim]) inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess); else inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess); if (!showAnim || !duration) postProcess(); if (inst.input.is(':visible') && !inst.input.is(':disabled')) inst.input.focus(); $.datepicker._curInst = inst } }, _updateDatepicker: function (inst) { var self = this; self.maxRows = 4; var borders = $.datepicker._getBorders(inst.dpDiv); instActive = inst; inst.dpDiv.empty().append(this._generateHTML(inst)); this._attachHandlers(inst); var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); if (!!cover.length) { cover.css({ left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight() }) } inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover(); var numMonths = this._getNumberOfMonths(inst); var cols = numMonths[1]; var width = 17; inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width(''); if (cols > 1) inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em'); inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') + 'Class']('ui-datepicker-multi'); inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') + 'Class']('ui-datepicker-rtl'); if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input && inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement) inst.input.focus(); if (inst.yearshtml) { var origyearshtml = inst.yearshtml; setTimeout(function () { if (origyearshtml === inst.yearshtml && inst.yearshtml) { inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml) } origyearshtml = inst.yearshtml = null }, 0) } }, _getBorders: function (elem) { var convert = function (value) { return { thin: 1, medium: 2, thick: 3 }[value] || value }; return [parseFloat(convert(elem.css('border-left-width'))), parseFloat(convert(elem.css('border-top-width')))] }, _checkOffset: function (inst, offset, isFixed) { var dpWidth = inst.dpDiv.outerWidth(); var dpHeight = inst.dpDiv.outerHeight(); var inputWidth = inst.input ? inst.input.outerWidth() : 0; var inputHeight = inst.input ? inst.input.outerHeight() : 0; var viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()); var viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop()); offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0); offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0; offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0; offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ? Math.abs(offset.left + dpWidth - viewWidth) : 0); offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ? Math.abs(dpHeight + inputHeight) : 0); return offset }, _findPos: function (obj) { var inst = this._getInst(obj); var isRTL = this._get(inst, 'isRTL'); while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) { obj = obj[isRTL ? 'previousSibling' : 'nextSibling'] } var position = $(obj).offset(); return [position.left, position.top] }, _hideDatepicker: function (input) { var inst = this._curInst; if (!inst || (input && inst != $.data(input, PROP_NAME))) return; if (this._datepickerShowing) { var showAnim = this._get(inst, 'showAnim'); var duration = this._get(inst, 'duration'); var postProcess = function () { $.datepicker._tidyDialog(inst) }; if ($.effects && $.effects[showAnim]) inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess); else inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' : (showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess); if (!showAnim) postProcess(); this._datepickerShowing = false; var onClose = this._get(inst, 'onClose'); if (onClose) onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ''), inst]); this._lastInput = null; if (this._inDialog) { this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' }); if ($.blockUI) { $.unblockUI(); $('body').append(this.dpDiv) } } this._inDialog = false } }, _tidyDialog: function (inst) { inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar') }, _checkExternalClick: function (event) { if (!$.datepicker._curInst) return; var $target = $(event.target), inst = $.datepicker._getInst($target[0]); if ((($target[0].id != $.datepicker._mainDivId && $target.parents('#' + $.datepicker._mainDivId).length == 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))) || ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst)) $.datepicker._hideDatepicker() }, _adjustDate: function (id, offset, period) { var target = $(id); var inst = this._getInst(target[0]); if (this._isDisabledDatepicker(target[0])) { return } this._adjustInstDate(inst, offset + (period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), period); this._updateDatepicker(inst) }, _gotoToday: function (id) { var target = $(id); var inst = this._getInst(target[0]); if (this._get(inst, 'gotoCurrent') && inst.currentDay) { inst.selectedDay = inst.currentDay; inst.drawMonth = inst.selectedMonth = inst.currentMonth; inst.drawYear = inst.selectedYear = inst.currentYear } else { var date = new Date(); inst.selectedDay = date.getDate(); inst.drawMonth = inst.selectedMonth = date.getMonth(); inst.drawYear = inst.selectedYear = date.getFullYear() } this._notifyChange(inst); this._adjustDate(target) }, _selectMonthYear: function (id, select, period) { var target = $(id); var inst = this._getInst(target[0]); inst['selected' + (period == 'M' ? 'Month' : 'Year')] = inst['draw' + (period == 'M' ? 'Month' : 'Year')] = parseInt(select.options[select.selectedIndex].value, 10); this._notifyChange(inst); this._adjustDate(target) }, _selectDay: function (id, month, year, td) { var target = $(id); if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) { return } var inst = this._getInst(target[0]); inst.selectedDay = inst.currentDay = $('a', td).html(); inst.selectedMonth = inst.currentMonth = month; inst.selectedYear = inst.currentYear = year; this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear)) }, _clearDate: function (id) { var target = $(id); var inst = this._getInst(target[0]); this._selectDate(target, '') }, _selectDate: function (id, dateStr) { var target = $(id); var inst = this._getInst(target[0]); dateStr = (dateStr != null ? dateStr : this._formatDate(inst)); if (inst.input) inst.input.val(dateStr); this._updateAlternate(inst); var onSelect = this._get(inst, 'onSelect'); if (onSelect) onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]); else if (inst.input) inst.input.trigger('change'); if (inst.inline) this._updateDatepicker(inst); else { this._hideDatepicker(); this._lastInput = inst.input[0]; if (typeof (inst.input[0]) != 'object') inst.input.focus(); this._lastInput = null } }, _updateAlternate: function (inst) { var altField = this._get(inst, 'altField'); if (altField) { var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat'); var date = this._getDate(inst); var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst)); $(altField).each(function () { $(this).val(dateStr) }) } }, noWeekends: function (date) { var day = date.getDay(); return [(day > 0 && day < 6), ''] }, iso8601Week: function (date) { var checkDate = new Date(date.getTime()); checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); var time = checkDate.getTime(); checkDate.setMonth(0); checkDate.setDate(1); return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1 }, parseDate: function (format, value, settings) { if (format == null || value == null) throw 'Invalid arguments'; value = (typeof value == 'object' ? value.toString() : value + ''); if (value == '') return null; var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff; shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10)); var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort; var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames; var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort; var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames; var year = -1; var month = -1; var day = -1; var doy = -1; var literal = false; var lookAhead = function (match) { var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match); if (matches) iFormat++; return matches }; var getNumber = function (match) { var isDoubled = lookAhead(match); var size = (match == '@' ? 14 : (match == '!' ? 20 : (match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2)))); var digits = new RegExp('^\\d{1,' + size + '}'); var num = value.substring(iValue).match(digits); if (!num) throw 'Missing number at position ' + iValue; iValue += num[0].length; return parseInt(num[0], 10) }; var getName = function (match, shortNames, longNames) { var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) { return [[k, v]] }).sort(function (a, b) { return -(a[1].length - b[1].length) }); var index = -1; $.each(names, function (i, pair) { var name = pair[1]; if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) { index = pair[0]; iValue += name.length; return false } }); if (index != -1) return index + 1; else throw 'Unknown name at position ' + iValue }; var checkLiteral = function () { if (value.charAt(iValue) != format.charAt(iFormat)) throw 'Unexpected literal at position ' + iValue; iValue++ }; var iValue = 0; for (var iFormat = 0; iFormat < format.length; iFormat++) { if (literal) if (format.charAt(iFormat) == "'" && !lookAhead("'")) literal = false; else checkLiteral(); else switch (format.charAt(iFormat)) { case 'd': day = getNumber('d'); break; case 'D': getName('D', dayNamesShort, dayNames); break; case 'o': doy = getNumber('o'); break; case 'm': month = getNumber('m'); break; case 'M': month = getName('M', monthNamesShort, monthNames); break; case 'y': year = getNumber('y'); break; case '@': var date = new Date(getNumber('@')); year = date.getFullYear(); month = date.getMonth() + 1; day = date.getDate(); break; case '!': var date = new Date((getNumber('!') - this._ticksTo1970) / 10000); year = date.getFullYear(); month = date.getMonth() + 1; day = date.getDate(); break; case "'": if (lookAhead("'")) checkLiteral(); else literal = true; break; default: checkLiteral() } } if (iValue < value.length) { throw "Extra/unparsed characters found in date: " + value.substring(iValue) } if (year == -1) year = new Date().getFullYear(); else if (year < 100) year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100); if (doy > -1) { month = 1; day = doy; do { var dim = this._getDaysInMonth(year, month - 1); if (day <= dim) break; month++; day -= dim } while (true) } var date = this._daylightSavingAdjust(new Date(year, month - 1, day)); if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day) throw 'Invalid date'; return date }, ATOM: 'yy-mm-dd', COOKIE: 'D, dd M yy', ISO_8601: 'yy-mm-dd', RFC_822: 'D, d M y', RFC_850: 'DD, dd-M-y', RFC_1036: 'D, d M y', RFC_1123: 'D, d M yy', RFC_2822: 'D, d M yy', RSS: 'D, d M y', TICKS: '!', TIMESTAMP: '@', W3C: 'yy-mm-dd', _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000), formatDate: function (format, date, settings) { if (!date) return ''; var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort; var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames; var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort; var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames; var lookAhead = function (match) { var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match); if (matches) iFormat++; return matches }; var formatNumber = function (match, value, len) { var num = '' + value; if (lookAhead(match)) while (num.length < len) num = '0' + num; return num }; var formatName = function (match, value, shortNames, longNames) { return (lookAhead(match) ? longNames[value] : shortNames[value]) }; var output = ''; var literal = false; if (date) for (var iFormat = 0; iFormat < format.length; iFormat++) { if (literal) if (format.charAt(iFormat) == "'" && !lookAhead("'")) literal = false; else output += format.charAt(iFormat); else switch (format.charAt(iFormat)) { case 'd': output += formatNumber('d', date.getDate(), 2); break; case 'D': output += formatName('D', date.getDay(), dayNamesShort, dayNames); break; case 'o': output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3); break; case 'm': output += formatNumber('m', date.getMonth() + 1, 2); break; case 'M': output += formatName('M', date.getMonth(), monthNamesShort, monthNames); break; case 'y': output += (lookAhead('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100); break; case '@': output += date.getTime(); break; case '!': output += date.getTime() * 10000 + this._ticksTo1970; break; case "'": if (lookAhead("'")) output += "'"; else literal = true; break; default: output += format.charAt(iFormat) } } return output }, _possibleChars: function (format) { var chars = ''; var literal = false; var lookAhead = function (match) { var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match); if (matches) iFormat++; return matches }; for (var iFormat = 0; iFormat < format.length; iFormat++) if (literal) if (format.charAt(iFormat) == "'" && !lookAhead("'")) literal = false; else chars += format.charAt(iFormat); else switch (format.charAt(iFormat)) { case 'd': case 'm': case 'y': case '@': chars += '0123456789'; break; case 'D': case 'M': return null; case "'": if (lookAhead("'")) chars += "'"; else literal = true; break; default: chars += format.charAt(iFormat) } return chars }, _get: function (inst, name) { return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name] }, _setDateFromField: function (inst, noDefault) { if (inst.input.val() == inst.lastVal) { return } var dateFormat = this._get(inst, 'dateFormat'); var dates = inst.lastVal = inst.input ? inst.input.val() : null; var date, defaultDate; date = defaultDate = this._getDefaultDate(inst); var settings = this._getFormatConfig(inst); try { date = this.parseDate(dateFormat, dates, settings) || defaultDate } catch (event) { this.log(event); dates = (noDefault ? '' : dates) } inst.selectedDay = date.getDate(); inst.drawMonth = inst.selectedMonth = date.getMonth(); inst.drawYear = inst.selectedYear = date.getFullYear(); inst.currentDay = (dates ? date.getDate() : 0); inst.currentMonth = (dates ? date.getMonth() : 0); inst.currentYear = (dates ? date.getFullYear() : 0); this._adjustInstDate(inst) }, _getDefaultDate: function (inst) { return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, 'defaultDate'), new Date())) }, _determineDate: function (inst, date, defaultDate) { var offsetNumeric = function (offset) { var date = new Date(); date.setDate(date.getDate() + offset); return date }; var offsetString = function (offset) { try { return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), offset, $.datepicker._getFormatConfig(inst)) } catch (e) { } var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(); var year = date.getFullYear(); var month = date.getMonth(); var day = date.getDate(); var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g; var matches = pattern.exec(offset); while (matches) { switch (matches[2] || 'd') { case 'd': case 'D': day += parseInt(matches[1], 10); break; case 'w': case 'W': day += parseInt(matches[1], 10) * 7; break; case 'm': case 'M': month += parseInt(matches[1], 10); day = Math.min(day, $.datepicker._getDaysInMonth(year, month)); break; case 'y': case 'Y': year += parseInt(matches[1], 10); day = Math.min(day, $.datepicker._getDaysInMonth(year, month)); break } matches = pattern.exec(offset) } return new Date(year, month, day) }; var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) : (typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime())))); newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate); if (newDate) { newDate.setHours(0); newDate.setMinutes(0); newDate.setSeconds(0); newDate.setMilliseconds(0) } return this._daylightSavingAdjust(newDate) }, _daylightSavingAdjust: function (date) { if (!date) return null; date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0); return date }, _setDate: function (inst, date, noChange) { var clear = !date; var origMonth = inst.selectedMonth; var origYear = inst.selectedYear; var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date())); inst.selectedDay = inst.currentDay = newDate.getDate(); inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth(); inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear(); if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange) this._notifyChange(inst); this._adjustInstDate(inst); if (inst.input) { inst.input.val(clear ? '' : this._formatDate(inst)) } }, _getDate: function (inst) { var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay))); return startDate }, _attachHandlers: function (inst) { var stepMonths = this._get(inst, 'stepMonths'); var id = '#' + inst.id; inst.dpDiv.find('[data-handler]').map(function () { var handler = { prev: function () { window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, -stepMonths, 'M') }, next: function () { window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, +stepMonths, 'M') }, hide: function () { window['DP_jQuery_' + dpuuid].datepicker._hideDatepicker() }, today: function () { window['DP_jQuery_' + dpuuid].datepicker._gotoToday(id) }, selectDay: function () { window['DP_jQuery_' + dpuuid].datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this); return false }, selectMonth: function () { window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'M'); return false }, selectYear: function () { window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'Y'); return false } }; $(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]) }) }, _generateHTML: function (inst) { var today = new Date(); today = this._daylightSavingAdjust(new Date(today.getFullYear(), today.getMonth(), today.getDate())); var isRTL = this._get(inst, 'isRTL'); var showButtonPanel = this._get(inst, 'showButtonPanel'); var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext'); var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat'); var numMonths = this._getNumberOfMonths(inst); var showCurrentAtPos = this._get(inst, 'showCurrentAtPos'); var stepMonths = this._get(inst, 'stepMonths'); var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1); var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay))); var minDate = this._getMinMaxDate(inst, 'min'); var maxDate = this._getMinMaxDate(inst, 'max'); var drawMonth = inst.drawMonth - showCurrentAtPos; var drawYear = inst.drawYear; if (drawMonth < 0) { drawMonth += 12; drawYear-- } if (maxDate) { var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate())); maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw); while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) { drawMonth--; if (drawMonth < 0) { drawMonth = 11; drawYear-- } } } inst.drawMonth = drawMonth; inst.drawYear = drawYear; var prevText = this._get(inst, 'prevText'); prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst))); var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? '<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click"' + ' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' : (hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>')); var nextText = this._get(inst, 'nextText'); nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst))); var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? '<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click"' + ' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' : (hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>')); var currentText = this._get(inst, 'currentText'); var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today); currentText = (!navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst))); var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">' + this._get(inst, 'closeText') + '</button>' : ''); var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') + (this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click"' + '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : ''; var firstDay = parseInt(this._get(inst, 'firstDay'), 10); firstDay = (isNaN(firstDay) ? 0 : firstDay); var showWeek = this._get(inst, 'showWeek'); var dayNames = this._get(inst, 'dayNames'); var dayNamesShort = this._get(inst, 'dayNamesShort'); var dayNamesMin = this._get(inst, 'dayNamesMin'); var monthNames = this._get(inst, 'monthNames'); var monthNamesShort = this._get(inst, 'monthNamesShort'); var beforeShowDay = this._get(inst, 'beforeShowDay'); var showOtherMonths = this._get(inst, 'showOtherMonths'); var selectOtherMonths = this._get(inst, 'selectOtherMonths'); var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week; var defaultDate = this._getDefaultDate(inst); var html = ''; for (var row = 0; row < numMonths[0]; row++) { var group = ''; this.maxRows = 4; for (var col = 0; col < numMonths[1]; col++) { var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay)); var cornerClass = ' ui-corner-all'; var calender = ''; if (isMultiMonth) { calender += '<div class="ui-datepicker-group'; if (numMonths[1] > 1) switch (col) { case 0: calender += ' ui-datepicker-group-first'; cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break; case numMonths[1] - 1: calender += ' ui-datepicker-group-last'; cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break; default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break } calender += '">' } calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' + (/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') + (/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + '</div><table class="ui-datepicker-calendar"><thead>' + '<tr>'; var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : ''); for (var dow = 0; dow < 7; dow++) { var day = (dow + firstDay) % 7; thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' + '<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>' } calender += thead + '</tr></thead><tbody>'; var daysInMonth = this._getDaysInMonth(drawYear, drawMonth); if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth) inst.selectedDay = Math.min(inst.selectedDay, daysInMonth); var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7; var curRows = Math.ceil((leadDays + daysInMonth) / 7); var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); this.maxRows = numRows; var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays)); for (var dRow = 0; dRow < numRows; dRow++) { calender += '<tr>'; var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' + this._get(inst, 'calculateWeek')(printDate) + '</td>'); for (var dow = 0; dow < 7; dow++) { var daySettings = (beforeShowDay ? beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']); var otherMonth = (printDate.getMonth() != drawMonth); var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] || (minDate && printDate < minDate) || (maxDate && printDate > maxDate); tbody += '<td class="' + ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + (otherMonth ? ' ui-datepicker-other-month' : '') + ((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || (defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ? ' ' + this._dayOverClass : '') + (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled' : '') + (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + (printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + (printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + (unselectable ? '' : ' data-handler="selectDay" data-event="click" data-month="' + printDate.getMonth() + '" data-year="' + printDate.getFullYear() + '"') + '>' + (otherMonth && !showOtherMonths ? '&#xa0;' : (unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' + (printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') + (printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + (otherMonth ? ' ui-priority-secondary' : '') + '" href="#">' + printDate.getDate() + '</a>')) + '</td>'; printDate.setDate(printDate.getDate() + 1); printDate = this._daylightSavingAdjust(printDate) } calender += tbody + '</tr>' } drawMonth++; if (drawMonth > 11) { drawMonth = 0; drawYear++ } calender += '</tbody></table>' + (isMultiMonth ? '</div>' + ((numMonths[0] > 0 && col == numMonths[1] - 1) ? '<div class="ui-datepicker-row-break"></div>' : '') : ''); group += calender } html += group } html += buttonPanel + ($.browser.msie && parseInt($.browser.version, 10) < 7 && !inst.inline ? '<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : ''); inst._keyEvent = false; return html }, _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) { var changeMonth = this._get(inst, 'changeMonth'); var changeYear = this._get(inst, 'changeYear'); var showMonthAfterYear = this._get(inst, 'showMonthAfterYear'); var html = '<div class="ui-datepicker-title">'; var monthHtml = ''; if (secondary || !changeMonth) monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>'; else { var inMinYear = (minDate && minDate.getFullYear() == drawYear); var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear); monthHtml += '<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">'; for (var month = 0; month < 12; month++) { if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) monthHtml += '<option value="' + month + '"' + (month == drawMonth ? ' selected="selected"' : '') + '>' + monthNamesShort[month] + '</option>' } monthHtml += '</select>' } if (!showMonthAfterYear) html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : ''); if (!inst.yearshtml) { inst.yearshtml = ''; if (secondary || !changeYear) html += '<span class="ui-datepicker-year">' + drawYear + '</span>'; else { var years = this._get(inst, 'yearRange').split(':'); var thisYear = new Date().getFullYear(); var determineYear = function (value) { var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) : (value.match(/[+-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10))); return (isNaN(year) ? thisYear : year) }; var year = determineYear(years[0]); var endYear = Math.max(year, determineYear(years[1] || '')); year = (minDate ? Math.max(year, minDate.getFullYear()) : year); endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear); inst.yearshtml += '<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">'; for (; year <= endYear; year++) { inst.yearshtml += '<option value="' + year + '"' + (year == drawYear ? ' selected="selected"' : '') + '>' + year + '</option>' } inst.yearshtml += '</select>'; html += inst.yearshtml; inst.yearshtml = null } } html += this._get(inst, 'yearSuffix'); if (showMonthAfterYear) html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml; html += '</div>'; return html }, _adjustInstDate: function (inst, offset, period) { var year = inst.drawYear + (period == 'Y' ? offset : 0); var month = inst.drawMonth + (period == 'M' ? offset : 0); var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period == 'D' ? offset : 0); var date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day))); inst.selectedDay = date.getDate(); inst.drawMonth = inst.selectedMonth = date.getMonth(); inst.drawYear = inst.selectedYear = date.getFullYear(); if (period == 'M' || period == 'Y') this._notifyChange(inst) }, _restrictMinMax: function (inst, date) { var minDate = this._getMinMaxDate(inst, 'min'); var maxDate = this._getMinMaxDate(inst, 'max'); var newDate = (minDate && date < minDate ? minDate : date); newDate = (maxDate && newDate > maxDate ? maxDate : newDate); return newDate }, _notifyChange: function (inst) { var onChange = this._get(inst, 'onChangeMonthYear'); if (onChange) onChange.apply((inst.input ? inst.input[0] : null), [inst.selectedYear, inst.selectedMonth + 1, inst]) }, _getNumberOfMonths: function (inst) { var numMonths = this._get(inst, 'numberOfMonths'); return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths)) }, _getMinMaxDate: function (inst, minMax) { return this._determineDate(inst, this._get(inst, minMax + 'Date'), null) }, _getDaysInMonth: function (year, month) { return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate() }, _getFirstDayOfMonth: function (year, month) { return new Date(year, month, 1).getDay() }, _canAdjustMonth: function (inst, offset, curYear, curMonth) { var numMonths = this._getNumberOfMonths(inst); var date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1)); if (offset < 0) date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth())); return this._isInRange(inst, date) }, _isInRange: function (inst, date) { var minDate = this._getMinMaxDate(inst, 'min'); var maxDate = this._getMinMaxDate(inst, 'max'); return ((!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime())) }, _getFormatConfig: function (inst) { var shortYearCutoff = this._get(inst, 'shortYearCutoff'); shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10)); return { shortYearCutoff: shortYearCutoff, dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'), monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames') } }, _formatDate: function (inst, day, month, year) { if (!day) { inst.currentDay = inst.selectedDay; inst.currentMonth = inst.selectedMonth; inst.currentYear = inst.selectedYear } var date = (day ? (typeof day == 'object' ? day : this._daylightSavingAdjust(new Date(year, month, day))) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay))); return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst)) } }); function bindHover(dpDiv) { var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a'; return dpDiv.bind('mouseout', function (event) { var elem = $(event.target).closest(selector); if (!elem.length) { return } elem.removeClass("ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover") }).bind('mouseover', function (event) { var elem = $(event.target).closest(selector); if ($.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) || !elem.length) { return } elem.parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover'); elem.addClass('ui-state-hover'); if (elem.hasClass('ui-datepicker-prev')) elem.addClass('ui-datepicker-prev-hover'); if (elem.hasClass('ui-datepicker-next')) elem.addClass('ui-datepicker-next-hover') }) } function extendRemove(target, props) { $.extend(target, props); for (var name in props) if (props[name] == null || props[name] == undefined) target[name] = props[name]; return target }; function isArray(a) { return (a && (($.browser.safari && typeof a == 'object' && a.length) || (a.constructor && a.constructor.toString().match(/\Array\(\)/)))) }; $.fn.datepicker = function (options) { if (!this.length) { return this } if (!$.datepicker.initialized) { $(document).mousedown($.datepicker._checkExternalClick).find('body').append($.datepicker.dpDiv); $.datepicker.initialized = true } var otherArgs = Array.prototype.slice.call(arguments, 1); if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget')) return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs)); if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string') return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs)); return this.each(function () { typeof options == 'string' ? $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options) }) }; $.datepicker = new Datepicker(); $.datepicker.initialized = false; $.datepicker.uuid = new Date().getTime(); $.datepicker.version = "1.8.22"; window['DP_jQuery_' + dpuuid] = $ })(jQuery); (function ($, undefined) { var uiDialogClasses = 'ui-dialog ' + 'ui-widget ' + 'ui-widget-content ' + 'ui-corner-all ', sizeRelatedOptions = { buttons: true, height: true, maxHeight: true, maxWidth: true, minHeight: true, minWidth: true, width: true }, resizableRelatedOptions = { maxHeight: true, maxWidth: true, minHeight: true, minWidth: true }, attrFn = $.attrFn || { val: true, css: true, html: true, text: true, data: true, width: true, height: true, offset: true, click: true }; $.widget("ui.dialog", { options: { autoOpen: true, buttons: {}, closeOnEscape: true, closeText: 'close', dialogClass: '', draggable: true, hide: null, height: 'auto', maxHeight: false, maxWidth: false, minHeight: 150, minWidth: 150, modal: false, position: { my: 'center', at: 'center', collision: 'fit', using: function (pos) { var topOffset = $(this).css(pos).offset().top; if (topOffset < 0) { $(this).css('top', pos.top - topOffset) } } }, resizable: true, show: null, stack: true, title: '', width: 300, zIndex: 1000 }, _create: function () { this.originalTitle = this.element.attr('title'); if (typeof this.originalTitle !== "string") { this.originalTitle = "" } this.options.title = this.options.title || this.originalTitle; var self = this, options = self.options, title = options.title || '&#160;', titleId = $.ui.dialog.getTitleId(self.element), uiDialog = (self.uiDialog = $('<div></div>')).appendTo(document.body).hide().addClass(uiDialogClasses + options.dialogClass).css({ zIndex: options.zIndex }).attr('tabIndex', -1).css('outline', 0).keydown(function (event) { if (options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) { self.close(event); event.preventDefault() } }).attr({ role: 'dialog', 'aria-labelledby': titleId }).mousedown(function (event) { self.moveToTop(false, event) }), uiDialogContent = self.element.show().removeAttr('title').addClass('ui-dialog-content ' + 'ui-widget-content').appendTo(uiDialog), uiDialogTitlebar = (self.uiDialogTitlebar = $('<div></div>')).addClass('ui-dialog-titlebar ' + 'ui-widget-header ' + 'ui-corner-all ' + 'ui-helper-clearfix').prependTo(uiDialog), uiDialogTitlebarClose = $('<a href="#"></a>').addClass('ui-dialog-titlebar-close ' + 'ui-corner-all').attr('role', 'button').hover(function () { uiDialogTitlebarClose.addClass('ui-state-hover') }, function () { uiDialogTitlebarClose.removeClass('ui-state-hover') }).focus(function () { uiDialogTitlebarClose.addClass('ui-state-focus') }).blur(function () { uiDialogTitlebarClose.removeClass('ui-state-focus') }).click(function (event) { self.close(event); return false }).appendTo(uiDialogTitlebar), uiDialogTitlebarCloseText = (self.uiDialogTitlebarCloseText = $('<span></span>')).addClass('ui-icon ' + 'ui-icon-closethick').text(options.closeText).appendTo(uiDialogTitlebarClose), uiDialogTitle = $('<span></span>').addClass('ui-dialog-title').attr('id', titleId).html(title).prependTo(uiDialogTitlebar); if ($.isFunction(options.beforeclose) && !$.isFunction(options.beforeClose)) { options.beforeClose = options.beforeclose } uiDialogTitlebar.find("*").add(uiDialogTitlebar).disableSelection(); if (options.draggable && $.fn.draggable) { self._makeDraggable() } if (options.resizable && $.fn.resizable) { self._makeResizable() } self._createButtons(options.buttons); self._isOpen = false; if ($.fn.bgiframe) { uiDialog.bgiframe() } }, _init: function () { if (this.options.autoOpen) { this.open() } }, destroy: function () { var self = this; if (self.overlay) { self.overlay.destroy() } self.uiDialog.hide(); self.element.unbind('.dialog').removeData('dialog').removeClass('ui-dialog-content ui-widget-content').hide().appendTo('body'); self.uiDialog.remove(); if (self.originalTitle) { self.element.attr('title', self.originalTitle) } return self }, widget: function () { return this.uiDialog }, close: function (event) { var self = this, maxZ, thisZ; if (false === self._trigger('beforeClose', event)) { return } if (self.overlay) { self.overlay.destroy() } self.uiDialog.unbind('keypress.ui-dialog'); self._isOpen = false; if (self.options.hide) { self.uiDialog.hide(self.options.hide, function () { self._trigger('close', event) }) } else { self.uiDialog.hide(); self._trigger('close', event) } $.ui.dialog.overlay.resize(); if (self.options.modal) { maxZ = 0; $('.ui-dialog').each(function () { if (this !== self.uiDialog[0]) { thisZ = $(this).css('z-index'); if (!isNaN(thisZ)) { maxZ = Math.max(maxZ, thisZ) } } }); $.ui.dialog.maxZ = maxZ } return self }, isOpen: function () { return this._isOpen }, moveToTop: function (force, event) { var self = this, options = self.options, saveScroll; if ((options.modal && !force) || (!options.stack && !options.modal)) { return self._trigger('focus', event) } if (options.zIndex > $.ui.dialog.maxZ) { $.ui.dialog.maxZ = options.zIndex } if (self.overlay) { $.ui.dialog.maxZ += 1; self.overlay.$el.css('z-index', $.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ) } saveScroll = { scrollTop: self.element.scrollTop(), scrollLeft: self.element.scrollLeft() }; $.ui.dialog.maxZ += 1; self.uiDialog.css('z-index', $.ui.dialog.maxZ); self.element.attr(saveScroll); self._trigger('focus', event); return self }, open: function () { if (this._isOpen) { return } var self = this, options = self.options, uiDialog = self.uiDialog; self.overlay = options.modal ? new $.ui.dialog.overlay(self) : null; self._size(); self._position(options.position); uiDialog.show(options.show); self.moveToTop(true); if (options.modal) { uiDialog.bind("keydown.ui-dialog", function (event) { if (event.keyCode !== $.ui.keyCode.TAB) { return } var tabbables = $(':tabbable', this), first = tabbables.filter(':first'), last = tabbables.filter(':last'); if (event.target === last[0] && !event.shiftKey) { first.focus(1); return false } else if (event.target === first[0] && event.shiftKey) { last.focus(1); return false } }) } $(self.element.find(':tabbable').get().concat(uiDialog.find('.ui-dialog-buttonpane :tabbable').get().concat(uiDialog.get()))).eq(0).focus(); self._isOpen = true; self._trigger('open'); return self }, _createButtons: function (buttons) { var self = this, hasButtons = false, uiDialogButtonPane = $('<div></div>').addClass('ui-dialog-buttonpane ' + 'ui-widget-content ' + 'ui-helper-clearfix'), uiButtonSet = $("<div></div>").addClass("ui-dialog-buttonset").appendTo(uiDialogButtonPane); self.uiDialog.find('.ui-dialog-buttonpane').remove(); if (typeof buttons === 'object' && buttons !== null) { $.each(buttons, function () { return !(hasButtons = true) }) } if (hasButtons) { $.each(buttons, function (name, props) { props = $.isFunction(props) ? { click: props, text: name } : props; var button = $('<button type="button"></button>').click(function () { props.click.apply(self.element[0], arguments) }).appendTo(uiButtonSet); $.each(props, function (key, value) { if (key === "click") { return } if (key in attrFn) { button[key](value) } else { button.attr(key, value) } }); if ($.fn.button) { button.button() } }); uiDialogButtonPane.appendTo(self.uiDialog) } }, _makeDraggable: function () { var self = this, options = self.options, doc = $(document), heightBeforeDrag; function filteredUi(ui) { return { position: ui.position, offset: ui.offset } } self.uiDialog.draggable({ cancel: '.ui-dialog-content, .ui-dialog-titlebar-close', handle: '.ui-dialog-titlebar', containment: 'document', start: function (event, ui) { heightBeforeDrag = options.height === "auto" ? "auto" : $(this).height(); $(this).height($(this).height()).addClass("ui-dialog-dragging"); self._trigger('dragStart', event, filteredUi(ui)) }, drag: function (event, ui) { self._trigger('drag', event, filteredUi(ui)) }, stop: function (event, ui) { options.position = [ui.position.left - doc.scrollLeft(), ui.position.top - doc.scrollTop()]; $(this).removeClass("ui-dialog-dragging").height(heightBeforeDrag); self._trigger('dragStop', event, filteredUi(ui)); $.ui.dialog.overlay.resize() } }) }, _makeResizable: function (handles) { handles = (handles === undefined ? this.options.resizable : handles); var self = this, options = self.options, position = self.uiDialog.css('position'), resizeHandles = (typeof handles === 'string' ? handles : 'n,e,s,w,se,sw,ne,nw'); function filteredUi(ui) { return { originalPosition: ui.originalPosition, originalSize: ui.originalSize, position: ui.position, size: ui.size } } self.uiDialog.resizable({ cancel: '.ui-dialog-content', containment: 'document', alsoResize: self.element, maxWidth: options.maxWidth, maxHeight: options.maxHeight, minWidth: options.minWidth, minHeight: self._minHeight(), handles: resizeHandles, start: function (event, ui) { $(this).addClass("ui-dialog-resizing"); self._trigger('resizeStart', event, filteredUi(ui)) }, resize: function (event, ui) { self._trigger('resize', event, filteredUi(ui)) }, stop: function (event, ui) { $(this).removeClass("ui-dialog-resizing"); options.height = $(this).height(); options.width = $(this).width(); self._trigger('resizeStop', event, filteredUi(ui)); $.ui.dialog.overlay.resize() } }).css('position', position).find('.ui-resizable-se').addClass('ui-icon ui-icon-grip-diagonal-se') }, _minHeight: function () { var options = this.options; if (options.height === 'auto') { return options.minHeight } else { return Math.min(options.minHeight, options.height) } }, _position: function (position) { var myAt = [], offset = [0, 0], isVisible; if (position) { if (typeof position === 'string' || (typeof position === 'object' && '0' in position)) { myAt = position.split ? position.split(' ') : [position[0], position[1]]; if (myAt.length === 1) { myAt[1] = myAt[0] } $.each(['left', 'top'], function (i, offsetPosition) { if (+myAt[i] === myAt[i]) { offset[i] = myAt[i]; myAt[i] = offsetPosition } }); position = { my: myAt.join(" "), at: myAt.join(" "), offset: offset.join(" ") } } position = $.extend({}, $.ui.dialog.prototype.options.position, position) } else { position = $.ui.dialog.prototype.options.position } isVisible = this.uiDialog.is(':visible'); if (!isVisible) { this.uiDialog.show() } this.uiDialog.css({ top: 0, left: 0 }).position($.extend({ of: window }, position)); if (!isVisible) { this.uiDialog.hide() } }, _setOptions: function (options) { var self = this, resizableOptions = {}, resize = false; $.each(options, function (key, value) { self._setOption(key, value); if (key in sizeRelatedOptions) { resize = true } if (key in resizableRelatedOptions) { resizableOptions[key] = value } }); if (resize) { this._size() } if (this.uiDialog.is(":data(resizable)")) { this.uiDialog.resizable("option", resizableOptions) } }, _setOption: function (key, value) { var self = this, uiDialog = self.uiDialog; switch (key) { case "beforeclose": key = "beforeClose"; break; case "buttons": self._createButtons(value); break; case "closeText": self.uiDialogTitlebarCloseText.text("" + value); break; case "dialogClass": uiDialog.removeClass(self.options.dialogClass).addClass(uiDialogClasses + value); break; case "disabled": if (value) { uiDialog.addClass('ui-dialog-disabled') } else { uiDialog.removeClass('ui-dialog-disabled') } break; case "draggable": var isDraggable = uiDialog.is(":data(draggable)"); if (isDraggable && !value) { uiDialog.draggable("destroy") } if (!isDraggable && value) { self._makeDraggable() } break; case "position": self._position(value); break; case "resizable": var isResizable = uiDialog.is(":data(resizable)"); if (isResizable && !value) { uiDialog.resizable('destroy') } if (isResizable && typeof value === 'string') { uiDialog.resizable('option', 'handles', value) } if (!isResizable && value !== false) { self._makeResizable(value) } break; case "title": $(".ui-dialog-title", self.uiDialogTitlebar).html("" + (value || '&#160;')); break } $.Widget.prototype._setOption.apply(self, arguments) }, _size: function () { var options = this.options, nonContentHeight, minContentHeight, isVisible = this.uiDialog.is(":visible"); this.element.show().css({ width: 'auto', minHeight: 0, height: 0 }); if (options.minWidth > options.width) { options.width = options.minWidth } nonContentHeight = this.uiDialog.css({ height: 'auto', width: options.width }).height(); minContentHeight = Math.max(0, options.minHeight - nonContentHeight); if (options.height === "auto") { if ($.support.minHeight) { this.element.css({ minHeight: minContentHeight, height: "auto" }) } else { this.uiDialog.show(); var autoHeight = this.element.css("height", "auto").height(); if (!isVisible) { this.uiDialog.hide() } this.element.height(Math.max(autoHeight, minContentHeight)) } } else { this.element.height(Math.max(options.height - nonContentHeight, 0)) } if (this.uiDialog.is(':data(resizable)')) { this.uiDialog.resizable('option', 'minHeight', this._minHeight()) } } }); $.extend($.ui.dialog, { version: "1.8.22", uuid: 0, maxZ: 0, getTitleId: function ($el) { var id = $el.attr('id'); if (!id) { this.uuid += 1; id = this.uuid } return 'ui-dialog-title-' + id }, overlay: function (dialog) { this.$el = $.ui.dialog.overlay.create(dialog) } }); $.extend($.ui.dialog.overlay, { instances: [], oldInstances: [], maxZ: 0, events: $.map('focus,mousedown,mouseup,keydown,keypress,click'.split(','), function (event) { return event + '.dialog-overlay' }).join(' '), create: function (dialog) { if (this.instances.length === 0) { setTimeout(function () { if ($.ui.dialog.overlay.instances.length) { $(document).bind($.ui.dialog.overlay.events, function (event) { if ($(event.target).zIndex() < $.ui.dialog.overlay.maxZ) { return false } }) } }, 1); $(document).bind('keydown.dialog-overlay', function (event) { if (dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) { dialog.close(event); event.preventDefault() } }); $(window).bind('resize.dialog-overlay', $.ui.dialog.overlay.resize) } var $el = (this.oldInstances.pop() || $('<div></div>').addClass('ui-widget-overlay')).appendTo(document.body).css({ width: this.width(), height: this.height() }); if ($.fn.bgiframe) { $el.bgiframe() } this.instances.push($el); return $el }, destroy: function ($el) { var indexOf = $.inArray($el, this.instances); if (indexOf != -1) { this.oldInstances.push(this.instances.splice(indexOf, 1)[0]) } if (this.instances.length === 0) { $([document, window]).unbind('.dialog-overlay') } $el.remove(); var maxZ = 0; $.each(this.instances, function () { maxZ = Math.max(maxZ, this.css('z-index')) }); this.maxZ = maxZ }, height: function () { var scrollHeight, offsetHeight; if ($.browser.msie && $.browser.version < 7) { scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight); offsetHeight = Math.max(document.documentElement.offsetHeight, document.body.offsetHeight); if (scrollHeight < offsetHeight) { return $(window).height() + 'px' } else { return scrollHeight + 'px' } } else { return $(document).height() + 'px' } }, width: function () { var scrollWidth, offsetWidth; if ($.browser.msie) { scrollWidth = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth); offsetWidth = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth); if (scrollWidth < offsetWidth) { return $(window).width() + 'px' } else { return scrollWidth + 'px' } } else { return $(document).width() + 'px' } }, resize: function () { var $overlays = $([]); $.each($.ui.dialog.overlay.instances, function () { $overlays = $overlays.add(this) }); $overlays.css({ width: 0, height: 0 }).css({ width: $.ui.dialog.overlay.width(), height: $.ui.dialog.overlay.height() }) } }); $.extend($.ui.dialog.overlay.prototype, { destroy: function () { $.ui.dialog.overlay.destroy(this.$el) } }) }(jQuery)); (function ($, undefined) { $.ui = $.ui || {}; var horizontalPositions = /left|center|right/, verticalPositions = /top|center|bottom/, center = "center", support = {}, _position = $.fn.position, _offset = $.fn.offset; $.fn.position = function (options) { if (!options || !options.of) { return _position.apply(this, arguments) } options = $.extend({}, options); var target = $(options.of), targetElem = target[0], collision = (options.collision || "flip").split(" "), offset = options.offset ? options.offset.split(" ") : [0, 0], targetWidth, targetHeight, basePosition; if (targetElem.nodeType === 9) { targetWidth = target.width(); targetHeight = target.height(); basePosition = { top: 0, left: 0 } } else if (targetElem.setTimeout) { targetWidth = target.width(); targetHeight = target.height(); basePosition = { top: target.scrollTop(), left: target.scrollLeft() } } else if (targetElem.preventDefault) { options.at = "left top"; targetWidth = targetHeight = 0; basePosition = { top: options.of.pageY, left: options.of.pageX } } else { targetWidth = target.outerWidth(); targetHeight = target.outerHeight(); basePosition = target.offset() } $.each(["my", "at"], function () { var pos = (options[this] || "").split(" "); if (pos.length === 1) { pos = horizontalPositions.test(pos[0]) ? pos.concat([center]) : verticalPositions.test(pos[0]) ? [center].concat(pos) : [center, center] } pos[0] = horizontalPositions.test(pos[0]) ? pos[0] : center; pos[1] = verticalPositions.test(pos[1]) ? pos[1] : center; options[this] = pos }); if (collision.length === 1) { collision[1] = collision[0] } offset[0] = parseInt(offset[0], 10) || 0; if (offset.length === 1) { offset[1] = offset[0] } offset[1] = parseInt(offset[1], 10) || 0; if (options.at[0] === "right") { basePosition.left += targetWidth } else if (options.at[0] === center) { basePosition.left += targetWidth / 2 } if (options.at[1] === "bottom") { basePosition.top += targetHeight } else if (options.at[1] === center) { basePosition.top += targetHeight / 2 } basePosition.left += offset[0]; basePosition.top += offset[1]; return this.each(function () { var elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseInt($.curCSS(this, "marginLeft", true)) || 0, marginTop = parseInt($.curCSS(this, "marginTop", true)) || 0, collisionWidth = elemWidth + marginLeft + (parseInt($.curCSS(this, "marginRight", true)) || 0), collisionHeight = elemHeight + marginTop + (parseInt($.curCSS(this, "marginBottom", true)) || 0), position = $.extend({}, basePosition), collisionPosition; if (options.my[0] === "right") { position.left -= elemWidth } else if (options.my[0] === center) { position.left -= elemWidth / 2 } if (options.my[1] === "bottom") { position.top -= elemHeight } else if (options.my[1] === center) { position.top -= elemHeight / 2 } if (!support.fractions) { position.left = Math.round(position.left); position.top = Math.round(position.top) } collisionPosition = { left: position.left - marginLeft, top: position.top - marginTop }; $.each(["left", "top"], function (i, dir) { if ($.ui.position[collision[i]]) { $.ui.position[collision[i]][dir](position, { targetWidth: targetWidth, targetHeight: targetHeight, elemWidth: elemWidth, elemHeight: elemHeight, collisionPosition: collisionPosition, collisionWidth: collisionWidth, collisionHeight: collisionHeight, offset: offset, my: options.my, at: options.at }) } }); if ($.fn.bgiframe) { elem.bgiframe() } var pos = $.extend(position, { using: options.using }); elem.css({ "top": pos.top, "left": pos.left }) }) }; $.ui.position = { fit: { left: function (position, data) { var win = $(window), over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(); position.left = over > 0 ? position.left - over : Math.max(position.left - data.collisionPosition.left, position.left) }, top: function (position, data) { var win = $(window), over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(); position.top = over > 0 ? position.top - over : Math.max(position.top - data.collisionPosition.top, position.top) } }, flip: { left: function (position, data) { if (data.at[0] === center) { return } var win = $(window), over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(), myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0, atOffset = data.at[0] === "left" ? data.targetWidth : -data.targetWidth, offset = -2 * data.offset[0]; position.left += data.collisionPosition.left < 0 ? myOffset + atOffset + offset : over > 0 ? myOffset + atOffset + offset : 0 }, top: function (position, data) { if (data.at[1] === center) { return } var win = $(window), over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(), myOffset = data.my[1] === "top" ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : -data.targetHeight, offset = -2 * data.offset[1]; position.top += data.collisionPosition.top < 0 ? myOffset + atOffset + offset : over > 0 ? myOffset + atOffset + offset : 0 } } }; if (!$.offset.setOffset) { $.offset.setOffset = function (elem, options) { if (/static/.test($.curCSS(elem, "position"))) { elem.style.position = "relative" } var curElem = $(elem), curOffset = curElem.offset(), curTop = parseInt($.curCSS(elem, "top", true), 10) || 0, curLeft = parseInt($.curCSS(elem, "left", true), 10) || 0, props = { top: (options.top - curOffset.top) + curTop, left: (options.left - curOffset.left) + curLeft }; if ('using' in options) { options.using.call(elem, props) } else { curElem.css(props) } }; $.fn.offset = function (options) { var elem = this[0]; if (!elem || !elem.ownerDocument) { return null } if (options) { if ($.isFunction(options)) { return this.each(function (i) { $(this).offset(options.call(this, i, $(this).offset())) }) } return this.each(function () { $.offset.setOffset(this, options) }) } return _offset.call(this) } } (function () { var body = document.getElementsByTagName("body")[0], div = document.createElement("div"), testElement, testElementParent, testElementStyle, offset, offsetTotal; testElement = document.createElement(body ? "div" : "body"); testElementStyle = { visibility: "hidden", width: 0, height: 0, border: 0, margin: 0, background: "none" }; if (body) { $.extend(testElementStyle, { position: "absolute", left: "-1000px", top: "-1000px" }) } for (var i in testElementStyle) { testElement.style[i] = testElementStyle[i] } testElement.appendChild(div); testElementParent = body || document.documentElement; testElementParent.insertBefore(testElement, testElementParent.firstChild); div.style.cssText = "position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;"; offset = $(div).offset(function (_, offset) { return offset }).offset(); testElement.innerHTML = ""; testElementParent.removeChild(testElement); offsetTotal = offset.top + offset.left + (body ? 2000 : 0); support.fractions = offsetTotal > 21 && offsetTotal < 22 })() }(jQuery)); (function ($, undefined) { $.widget("ui.progressbar", { options: { value: 0, max: 100 }, min: 0, _create: function () { this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({ role: "progressbar", "aria-valuemin": this.min, "aria-valuemax": this.options.max, "aria-valuenow": this._value() }); this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element); this.oldValue = this._value(); this._refreshValue() }, destroy: function () { this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"); this.valueDiv.remove(); $.Widget.prototype.destroy.apply(this, arguments) }, value: function (newValue) { if (newValue === undefined) { return this._value() } this._setOption("value", newValue); return this }, _setOption: function (key, value) { if (key === "value") { this.options.value = value; this._refreshValue(); if (this._value() === this.options.max) { this._trigger("complete") } } $.Widget.prototype._setOption.apply(this, arguments) }, _value: function () { var val = this.options.value; if (typeof val !== "number") { val = 0 } return Math.min(this.options.max, Math.max(this.min, val)) }, _percentage: function () { return 100 * this._value() / this.options.max }, _refreshValue: function () { var value = this.value(); var percentage = this._percentage(); if (this.oldValue !== value) { this.oldValue = value; this._trigger("change") } this.valueDiv.toggle(value > this.min).toggleClass("ui-corner-right", value === this.options.max).width(percentage.toFixed(0) + "%"); this.element.attr("aria-valuenow", value) } }); $.extend($.ui.progressbar, { version: "1.8.22" }) })(jQuery); (function ($, undefined) { var numPages = 5; $.widget("ui.slider", $.ui.mouse, { widgetEventPrefix: "slide", options: { animate: false, distance: 0, max: 100, min: 0, orientation: "horizontal", range: false, step: 1, value: 0, values: null }, _create: function () { var self = this, o = this.options, existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"), handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>", handleCount = (o.values && o.values.length) || 1, handles = []; this._keySliding = false; this._mouseSliding = false; this._animateOff = true; this._handleIndex = null; this._detectOrientation(); this._mouseInit(); this.element.addClass("ui-slider" + " ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all" + (o.disabled ? " ui-slider-disabled ui-disabled" : "")); this.range = $([]); if (o.range) { if (o.range === true) { if (!o.values) { o.values = [this._valueMin(), this._valueMin()] } if (o.values.length && o.values.length !== 2) { o.values = [o.values[0], o.values[0]] } } this.range = $("<div></div>").appendTo(this.element).addClass("ui-slider-range" + " ui-widget-header" + ((o.range === "min" || o.range === "max") ? " ui-slider-range-" + o.range : "")) } for (var i = existingHandles.length; i < handleCount; i += 1) { handles.push(handle) } this.handles = existingHandles.add($(handles.join("")).appendTo(self.element)); this.handle = this.handles.eq(0); this.handles.add(this.range).filter("a").click(function (event) { event.preventDefault() }).hover(function () { if (!o.disabled) { $(this).addClass("ui-state-hover") } }, function () { $(this).removeClass("ui-state-hover") }).focus(function () { if (!o.disabled) { $(".ui-slider .ui-state-focus").removeClass("ui-state-focus"); $(this).addClass("ui-state-focus") } else { $(this).blur() } }).blur(function () { $(this).removeClass("ui-state-focus") }); this.handles.each(function (i) { $(this).data("index.ui-slider-handle", i) }); this.handles.keydown(function (event) { var index = $(this).data("index.ui-slider-handle"), allowed, curVal, newVal, step; if (self.options.disabled) { return } switch (event.keyCode) { case $.ui.keyCode.HOME: case $.ui.keyCode.END: case $.ui.keyCode.PAGE_UP: case $.ui.keyCode.PAGE_DOWN: case $.ui.keyCode.UP: case $.ui.keyCode.RIGHT: case $.ui.keyCode.DOWN: case $.ui.keyCode.LEFT: event.preventDefault(); if (!self._keySliding) { self._keySliding = true; $(this).addClass("ui-state-active"); allowed = self._start(event, index); if (allowed === false) { return } } break } step = self.options.step; if (self.options.values && self.options.values.length) { curVal = newVal = self.values(index) } else { curVal = newVal = self.value() } switch (event.keyCode) { case $.ui.keyCode.HOME: newVal = self._valueMin(); break; case $.ui.keyCode.END: newVal = self._valueMax(); break; case $.ui.keyCode.PAGE_UP: newVal = self._trimAlignValue(curVal + ((self._valueMax() - self._valueMin()) / numPages)); break; case $.ui.keyCode.PAGE_DOWN: newVal = self._trimAlignValue(curVal - ((self._valueMax() - self._valueMin()) / numPages)); break; case $.ui.keyCode.UP: case $.ui.keyCode.RIGHT: if (curVal === self._valueMax()) { return } newVal = self._trimAlignValue(curVal + step); break; case $.ui.keyCode.DOWN: case $.ui.keyCode.LEFT: if (curVal === self._valueMin()) { return } newVal = self._trimAlignValue(curVal - step); break } self._slide(event, index, newVal) }).keyup(function (event) { var index = $(this).data("index.ui-slider-handle"); if (self._keySliding) { self._keySliding = false; self._stop(event, index); self._change(event, index); $(this).removeClass("ui-state-active") } }); this._refreshValue(); this._animateOff = false }, destroy: function () { this.handles.remove(); this.range.remove(); this.element.removeClass("ui-slider" + " ui-slider-horizontal" + " ui-slider-vertical" + " ui-slider-disabled" + " ui-widget" + " ui-widget-content" + " ui-corner-all").removeData("slider").unbind(".slider"); this._mouseDestroy(); return this }, _mouseCapture: function (event) { var o = this.options, position, normValue, distance, closestHandle, self, index, allowed, offset, mouseOverHandle; if (o.disabled) { return false } this.elementSize = { width: this.element.outerWidth(), height: this.element.outerHeight() }; this.elementOffset = this.element.offset(); position = { x: event.pageX, y: event.pageY }; normValue = this._normValueFromMouse(position); distance = this._valueMax() - this._valueMin() + 1; self = this; this.handles.each(function (i) { var thisDistance = Math.abs(normValue - self.values(i)); if (distance > thisDistance) { distance = thisDistance; closestHandle = $(this); index = i } }); if (o.range === true && this.values(1) === o.min) { index += 1; closestHandle = $(this.handles[index]) } allowed = this._start(event, index); if (allowed === false) { return false } this._mouseSliding = true; self._handleIndex = index; closestHandle.addClass("ui-state-active").focus(); offset = closestHandle.offset(); mouseOverHandle = !$(event.target).parents().andSelf().is(".ui-slider-handle"); this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : { left: event.pageX - offset.left - (closestHandle.width() / 2), top: event.pageY - offset.top - (closestHandle.height() / 2) - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0) }; if (!this.handles.hasClass("ui-state-hover")) { this._slide(event, index, normValue) } this._animateOff = true; return true }, _mouseStart: function (event) { return true }, _mouseDrag: function (event) { var position = { x: event.pageX, y: event.pageY }, normValue = this._normValueFromMouse(position); this._slide(event, this._handleIndex, normValue); return false }, _mouseStop: function (event) { this.handles.removeClass("ui-state-active"); this._mouseSliding = false; this._stop(event, this._handleIndex); this._change(event, this._handleIndex); this._handleIndex = null; this._clickOffset = null; this._animateOff = false; return false }, _detectOrientation: function () { this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal" }, _normValueFromMouse: function (position) { var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse; if (this.orientation === "horizontal") { pixelTotal = this.elementSize.width; pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0) } else { pixelTotal = this.elementSize.height; pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0) } percentMouse = (pixelMouse / pixelTotal); if (percentMouse > 1) { percentMouse = 1 } if (percentMouse < 0) { percentMouse = 0 } if (this.orientation === "vertical") { percentMouse = 1 - percentMouse } valueTotal = this._valueMax() - this._valueMin(); valueMouse = this._valueMin() + percentMouse * valueTotal; return this._trimAlignValue(valueMouse) }, _start: function (event, index) { var uiHash = { handle: this.handles[index], value: this.value() }; if (this.options.values && this.options.values.length) { uiHash.value = this.values(index); uiHash.values = this.values() } return this._trigger("start", event, uiHash) }, _slide: function (event, index, newVal) { var otherVal, newValues, allowed; if (this.options.values && this.options.values.length) { otherVal = this.values(index ? 0 : 1); if ((this.options.values.length === 2 && this.options.range === true) && ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))) { newVal = otherVal } if (newVal !== this.values(index)) { newValues = this.values(); newValues[index] = newVal; allowed = this._trigger("slide", event, { handle: this.handles[index], value: newVal, values: newValues }); otherVal = this.values(index ? 0 : 1); if (allowed !== false) { this.values(index, newVal, true) } } } else { if (newVal !== this.value()) { allowed = this._trigger("slide", event, { handle: this.handles[index], value: newVal }); if (allowed !== false) { this.value(newVal) } } } }, _stop: function (event, index) { var uiHash = { handle: this.handles[index], value: this.value() }; if (this.options.values && this.options.values.length) { uiHash.value = this.values(index); uiHash.values = this.values() } this._trigger("stop", event, uiHash) }, _change: function (event, index) { if (!this._keySliding && !this._mouseSliding) { var uiHash = { handle: this.handles[index], value: this.value() }; if (this.options.values && this.options.values.length) { uiHash.value = this.values(index); uiHash.values = this.values() } this._trigger("change", event, uiHash) } }, value: function (newValue) { if (arguments.length) { this.options.value = this._trimAlignValue(newValue); this._refreshValue(); this._change(null, 0); return } return this._value() }, values: function (index, newValue) { var vals, newValues, i; if (arguments.length > 1) { this.options.values[index] = this._trimAlignValue(newValue); this._refreshValue(); this._change(null, index); return } if (arguments.length) { if ($.isArray(arguments[0])) { vals = this.options.values; newValues = arguments[0]; for (i = 0; i < vals.length; i += 1) { vals[i] = this._trimAlignValue(newValues[i]); this._change(null, i) } this._refreshValue() } else { if (this.options.values && this.options.values.length) { return this._values(index) } else { return this.value() } } } else { return this._values() } }, _setOption: function (key, value) { var i, valsLength = 0; if ($.isArray(this.options.values)) { valsLength = this.options.values.length } $.Widget.prototype._setOption.apply(this, arguments); switch (key) { case "disabled": if (value) { this.handles.filter(".ui-state-focus").blur(); this.handles.removeClass("ui-state-hover"); this.handles.propAttr("disabled", true); this.element.addClass("ui-disabled") } else { this.handles.propAttr("disabled", false); this.element.removeClass("ui-disabled") } break; case "orientation": this._detectOrientation(); this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation); this._refreshValue(); break; case "value": this._animateOff = true; this._refreshValue(); this._change(null, 0); this._animateOff = false; break; case "values": this._animateOff = true; this._refreshValue(); for (i = 0; i < valsLength; i += 1) { this._change(null, i) } this._animateOff = false; break } }, _value: function () { var val = this.options.value; val = this._trimAlignValue(val); return val }, _values: function (index) { var val, vals, i; if (arguments.length) { val = this.options.values[index]; val = this._trimAlignValue(val); return val } else { vals = this.options.values.slice(); for (i = 0; i < vals.length; i += 1) { vals[i] = this._trimAlignValue(vals[i]) } return vals } }, _trimAlignValue: function (val) { if (val <= this._valueMin()) { return this._valueMin() } if (val >= this._valueMax()) { return this._valueMax() } var step = (this.options.step > 0) ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep; if (Math.abs(valModStep) * 2 >= step) { alignValue += (valModStep > 0) ? step : (-step) } return parseFloat(alignValue.toFixed(5)) }, _valueMin: function () { return this.options.min }, _valueMax: function () { return this.options.max }, _refreshValue: function () { var oRange = this.options.range, o = this.options, self = this, animate = (!this._animateOff) ? o.animate : false, valPercent, _set = {}, lastValPercent, value, valueMin, valueMax; if (this.options.values && this.options.values.length) { this.handles.each(function (i, j) { valPercent = (self.values(i) - self._valueMin()) / (self._valueMax() - self._valueMin()) * 100; _set[self.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%"; $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate); if (self.options.range === true) { if (self.orientation === "horizontal") { if (i === 0) { self.range.stop(1, 1)[animate ? "animate" : "css"]({ left: valPercent + "%" }, o.animate) } if (i === 1) { self.range[animate ? "animate" : "css"]({ width: (valPercent - lastValPercent) + "%" }, { queue: false, duration: o.animate }) } } else { if (i === 0) { self.range.stop(1, 1)[animate ? "animate" : "css"]({ bottom: (valPercent) + "%" }, o.animate) } if (i === 1) { self.range[animate ? "animate" : "css"]({ height: (valPercent - lastValPercent) + "%" }, { queue: false, duration: o.animate }) } } } lastValPercent = valPercent }) } else { value = this.value(); valueMin = this._valueMin(); valueMax = this._valueMax(); valPercent = (valueMax !== valueMin) ? (value - valueMin) / (valueMax - valueMin) * 100 : 0; _set[self.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%"; this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate); if (oRange === "min" && this.orientation === "horizontal") { this.range.stop(1, 1)[animate ? "animate" : "css"]({ width: valPercent + "%" }, o.animate) } if (oRange === "max" && this.orientation === "horizontal") { this.range[animate ? "animate" : "css"]({ width: (100 - valPercent) + "%" }, { queue: false, duration: o.animate }) } if (oRange === "min" && this.orientation === "vertical") { this.range.stop(1, 1)[animate ? "animate" : "css"]({ height: valPercent + "%" }, o.animate) } if (oRange === "max" && this.orientation === "vertical") { this.range[animate ? "animate" : "css"]({ height: (100 - valPercent) + "%" }, { queue: false, duration: o.animate }) } } } }); $.extend($.ui.slider, { version: "1.8.22" }) }(jQuery)); (function ($, undefined) { var tabId = 0, listId = 0; function getNextTabId() { return ++tabId } function getNextListId() { return ++listId } $.widget("ui.tabs", { options: { add: null, ajaxOptions: null, cache: false, cookie: null, collapsible: false, disable: null, disabled: [], enable: null, event: "click", fx: null, idPrefix: "ui-tabs-", load: null, panelTemplate: "<div></div>", remove: null, select: null, show: null, spinner: "<em>Loading&#8230;</em>", tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>" }, _create: function () { this._tabify(true) }, _setOption: function (key, value) { if (key == "selected") { if (this.options.collapsible && value == this.options.selected) { return } this.select(value) } else { this.options[key] = value; this._tabify() } }, _tabId: function (a) { return a.title && a.title.replace(/\s/g, "_").replace(/[^\w\u00c0-\uFFFF-]/g, "") || this.options.idPrefix + getNextTabId() }, _sanitizeSelector: function (hash) { return hash.replace(/:/g, "\\:") }, _cookie: function () { var cookie = this.cookie || (this.cookie = this.options.cookie.name || "ui-tabs-" + getNextListId()); return $.cookie.apply(null, [cookie].concat($.makeArray(arguments))) }, _ui: function (tab, panel) { return { tab: tab, panel: panel, index: this.anchors.index(tab) } }, _cleanup: function () { this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function () { var el = $(this); el.html(el.data("label.tabs")).removeData("label.tabs") }) }, _tabify: function (init) { var self = this, o = this.options, fragmentId = /^#.+/; this.list = this.element.find("ol,ul").eq(0); this.lis = $(" > li:has(a[href])", this.list); this.anchors = this.lis.map(function () { return $("a", this)[0] }); this.panels = $([]); this.anchors.each(function (i, a) { var href = $(a).attr("href"); var hrefBase = href.split("#")[0], baseEl; if (hrefBase && (hrefBase === location.toString().split("#")[0] || (baseEl = $("base")[0]) && hrefBase === baseEl.href)) { href = a.hash; a.href = href } if (fragmentId.test(href)) { self.panels = self.panels.add(self.element.find(self._sanitizeSelector(href))) } else if (href && href !== "#") { $.data(a, "href.tabs", href); $.data(a, "load.tabs", href.replace(/#.*$/, "")); var id = self._tabId(a); a.href = "#" + id; var $panel = self.element.find("#" + id); if (!$panel.length) { $panel = $(o.panelTemplate).attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(self.panels[i - 1] || self.list); $panel.data("destroy.tabs", true) } self.panels = self.panels.add($panel) } else { o.disabled.push(i) } }); if (init) { this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all"); this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all"); this.lis.addClass("ui-state-default ui-corner-top"); this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom"); if (o.selected === undefined) { if (location.hash) { this.anchors.each(function (i, a) { if (a.hash == location.hash) { o.selected = i; return false } }) } if (typeof o.selected !== "number" && o.cookie) { o.selected = parseInt(self._cookie(), 10) } if (typeof o.selected !== "number" && this.lis.filter(".ui-tabs-selected").length) { o.selected = this.lis.index(this.lis.filter(".ui-tabs-selected")) } o.selected = o.selected || (this.lis.length ? 0 : -1) } else if (o.selected === null) { o.selected = -1 } o.selected = ((o.selected >= 0 && this.anchors[o.selected]) || o.selected < 0) ? o.selected : 0; o.disabled = $.unique(o.disabled.concat($.map(this.lis.filter(".ui-state-disabled"), function (n, i) { return self.lis.index(n) }))).sort(); if ($.inArray(o.selected, o.disabled) != -1) { o.disabled.splice($.inArray(o.selected, o.disabled), 1) } this.panels.addClass("ui-tabs-hide"); this.lis.removeClass("ui-tabs-selected ui-state-active"); if (o.selected >= 0 && this.anchors.length) { self.element.find(self._sanitizeSelector(self.anchors[o.selected].hash)).removeClass("ui-tabs-hide"); this.lis.eq(o.selected).addClass("ui-tabs-selected ui-state-active"); self.element.queue("tabs", function () { self._trigger("show", null, self._ui(self.anchors[o.selected], self.element.find(self._sanitizeSelector(self.anchors[o.selected].hash))[0])) }); this.load(o.selected) } $(window).bind("unload", function () { self.lis.add(self.anchors).unbind(".tabs"); self.lis = self.anchors = self.panels = null }) } else { o.selected = this.lis.index(this.lis.filter(".ui-tabs-selected")) } this.element[o.collapsible ? "addClass" : "removeClass"]("ui-tabs-collapsible"); if (o.cookie) { this._cookie(o.selected, o.cookie) } for (var i = 0, li; (li = this.lis[i]) ; i++) { $(li)[$.inArray(i, o.disabled) != -1 && !$(li).hasClass("ui-tabs-selected") ? "addClass" : "removeClass"]("ui-state-disabled") } if (o.cache === false) { this.anchors.removeData("cache.tabs") } this.lis.add(this.anchors).unbind(".tabs"); if (o.event !== "mouseover") { var addState = function (state, el) { if (el.is(":not(.ui-state-disabled)")) { el.addClass("ui-state-" + state) } }; var removeState = function (state, el) { el.removeClass("ui-state-" + state) }; this.lis.bind("mouseover.tabs", function () { addState("hover", $(this)) }); this.lis.bind("mouseout.tabs", function () { removeState("hover", $(this)) }); this.anchors.bind("focus.tabs", function () { addState("focus", $(this).closest("li")) }); this.anchors.bind("blur.tabs", function () { removeState("focus", $(this).closest("li")) }) } var hideFx, showFx; if (o.fx) { if ($.isArray(o.fx)) { hideFx = o.fx[0]; showFx = o.fx[1] } else { hideFx = showFx = o.fx } } function resetStyle($el, fx) { $el.css("display", ""); if (!$.support.opacity && fx.opacity) { $el[0].style.removeAttribute("filter") } } var showTab = showFx ? function (clicked, $show) { $(clicked).closest("li").addClass("ui-tabs-selected ui-state-active"); $show.hide().removeClass("ui-tabs-hide").animate(showFx, showFx.duration || "normal", function () { resetStyle($show, showFx); self._trigger("show", null, self._ui(clicked, $show[0])) }) } : function (clicked, $show) { $(clicked).closest("li").addClass("ui-tabs-selected ui-state-active"); $show.removeClass("ui-tabs-hide"); self._trigger("show", null, self._ui(clicked, $show[0])) }; var hideTab = hideFx ? function (clicked, $hide) { $hide.animate(hideFx, hideFx.duration || "normal", function () { self.lis.removeClass("ui-tabs-selected ui-state-active"); $hide.addClass("ui-tabs-hide"); resetStyle($hide, hideFx); self.element.dequeue("tabs") }) } : function (clicked, $hide, $show) { self.lis.removeClass("ui-tabs-selected ui-state-active"); $hide.addClass("ui-tabs-hide"); self.element.dequeue("tabs") }; this.anchors.bind(o.event + ".tabs", function () { var el = this, $li = $(el).closest("li"), $hide = self.panels.filter(":not(.ui-tabs-hide)"), $show = self.element.find(self._sanitizeSelector(el.hash)); if (($li.hasClass("ui-tabs-selected") && !o.collapsible) || $li.hasClass("ui-state-disabled") || $li.hasClass("ui-state-processing") || self.panels.filter(":animated").length || self._trigger("select", null, self._ui(this, $show[0])) === false) { this.blur(); return false } o.selected = self.anchors.index(this); self.abort(); if (o.collapsible) { if ($li.hasClass("ui-tabs-selected")) { o.selected = -1; if (o.cookie) { self._cookie(o.selected, o.cookie) } self.element.queue("tabs", function () { hideTab(el, $hide) }).dequeue("tabs"); this.blur(); return false } else if (!$hide.length) { if (o.cookie) { self._cookie(o.selected, o.cookie) } self.element.queue("tabs", function () { showTab(el, $show) }); self.load(self.anchors.index(this)); this.blur(); return false } } if (o.cookie) { self._cookie(o.selected, o.cookie) } if ($show.length) { if ($hide.length) { self.element.queue("tabs", function () { hideTab(el, $hide) }) } self.element.queue("tabs", function () { showTab(el, $show) }); self.load(self.anchors.index(this)) } else { throw "jQuery UI Tabs: Mismatching fragment identifier." } if ($.browser.msie) { this.blur() } }); this.anchors.bind("click.tabs", function () { return false }) }, _getIndex: function (index) { if (typeof index == "string") { index = this.anchors.index(this.anchors.filter("[href$='" + index + "']")) } return index }, destroy: function () { var o = this.options; this.abort(); this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs"); this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all"); this.anchors.each(function () { var href = $.data(this, "href.tabs"); if (href) { this.href = href } var $this = $(this).unbind(".tabs"); $.each(["href", "load", "cache"], function (i, prefix) { $this.removeData(prefix + ".tabs") }) }); this.lis.unbind(".tabs").add(this.panels).each(function () { if ($.data(this, "destroy.tabs")) { $(this).remove() } else { $(this).removeClass(["ui-state-default", "ui-corner-top", "ui-tabs-selected", "ui-state-active", "ui-state-hover", "ui-state-focus", "ui-state-disabled", "ui-tabs-panel", "ui-widget-content", "ui-corner-bottom", "ui-tabs-hide"].join(" ")) } }); if (o.cookie) { this._cookie(null, o.cookie) } return this }, add: function (url, label, index) { if (index === undefined) { index = this.anchors.length } var self = this, o = this.options, $li = $(o.tabTemplate.replace(/#\{href\}/g, url).replace(/#\{label\}/g, label)), id = !url.indexOf("#") ? url.replace("#", "") : this._tabId($("a", $li)[0]); $li.addClass("ui-state-default ui-corner-top").data("destroy.tabs", true); var $panel = self.element.find("#" + id); if (!$panel.length) { $panel = $(o.panelTemplate).attr("id", id).data("destroy.tabs", true) } $panel.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide"); if (index >= this.lis.length) { $li.appendTo(this.list); $panel.appendTo(this.list[0].parentNode) } else { $li.insertBefore(this.lis[index]); $panel.insertBefore(this.panels[index]) } o.disabled = $.map(o.disabled, function (n, i) { return n >= index ? ++n : n }); this._tabify(); if (this.anchors.length == 1) { o.selected = 0; $li.addClass("ui-tabs-selected ui-state-active"); $panel.removeClass("ui-tabs-hide"); this.element.queue("tabs", function () { self._trigger("show", null, self._ui(self.anchors[0], self.panels[0])) }); this.load(0) } this._trigger("add", null, this._ui(this.anchors[index], this.panels[index])); return this }, remove: function (index) { index = this._getIndex(index); var o = this.options, $li = this.lis.eq(index).remove(), $panel = this.panels.eq(index).remove(); if ($li.hasClass("ui-tabs-selected") && this.anchors.length > 1) { this.select(index + (index + 1 < this.anchors.length ? 1 : -1)) } o.disabled = $.map($.grep(o.disabled, function (n, i) { return n != index }), function (n, i) { return n >= index ? --n : n }); this._tabify(); this._trigger("remove", null, this._ui($li.find("a")[0], $panel[0])); return this }, enable: function (index) { index = this._getIndex(index); var o = this.options; if ($.inArray(index, o.disabled) == -1) { return } this.lis.eq(index).removeClass("ui-state-disabled"); o.disabled = $.grep(o.disabled, function (n, i) { return n != index }); this._trigger("enable", null, this._ui(this.anchors[index], this.panels[index])); return this }, disable: function (index) { index = this._getIndex(index); var self = this, o = this.options; if (index != o.selected) { this.lis.eq(index).addClass("ui-state-disabled"); o.disabled.push(index); o.disabled.sort(); this._trigger("disable", null, this._ui(this.anchors[index], this.panels[index])) } return this }, select: function (index) { index = this._getIndex(index); if (index == -1) { if (this.options.collapsible && this.options.selected != -1) { index = this.options.selected } else { return this } } this.anchors.eq(index).trigger(this.options.event + ".tabs"); return this }, load: function (index) { index = this._getIndex(index); var self = this, o = this.options, a = this.anchors.eq(index)[0], url = $.data(a, "load.tabs"); this.abort(); if (!url || this.element.queue("tabs").length !== 0 && $.data(a, "cache.tabs")) { this.element.dequeue("tabs"); return } this.lis.eq(index).addClass("ui-state-processing"); if (o.spinner) { var span = $("span", a); span.data("label.tabs", span.html()).html(o.spinner) } this.xhr = $.ajax($.extend({}, o.ajaxOptions, { url: url, success: function (r, s) { self.element.find(self._sanitizeSelector(a.hash)).html(r); self._cleanup(); if (o.cache) { $.data(a, "cache.tabs", true) } self._trigger("load", null, self._ui(self.anchors[index], self.panels[index])); try { o.ajaxOptions.success(r, s) } catch (e) { } }, error: function (xhr, s, e) { self._cleanup(); self._trigger("load", null, self._ui(self.anchors[index], self.panels[index])); try { o.ajaxOptions.error(xhr, s, index, a) } catch (e) { } } })); self.element.dequeue("tabs"); return this }, abort: function () { this.element.queue([]); this.panels.stop(false, true); this.element.queue("tabs", this.element.queue("tabs").splice(-2, 2)); if (this.xhr) { this.xhr.abort(); delete this.xhr } this._cleanup(); return this }, url: function (index, url) { this.anchors.eq(index).removeData("cache.tabs").data("load.tabs", url); return this }, length: function () { return this.anchors.length } }); $.extend($.ui.tabs, { version: "1.8.22" }); $.extend($.ui.tabs.prototype, { rotation: null, rotate: function (ms, continuing) { var self = this, o = this.options; var rotate = self._rotate || (self._rotate = function (e) { clearTimeout(self.rotation); self.rotation = setTimeout(function () { var t = o.selected; self.select(++t < self.anchors.length ? t : 0) }, ms); if (e) { e.stopPropagation() } }); var stop = self._unrotate || (self._unrotate = !continuing ? function (e) { if (e.clientX) { self.rotate(null) } } : function (e) { rotate() }); if (ms) { this.element.bind("tabsshow", rotate); this.anchors.bind(o.event + ".tabs", stop); rotate() } else { clearTimeout(self.rotation); this.element.unbind("tabsshow", rotate); this.anchors.unbind(o.event + ".tabs", stop); delete this._rotate; delete this._unrotate } return this } }) })(jQuery);
/*
* jQuery Mobile v1.4.5
* http://jquerymobile.com
*
* Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
* Released under the MIT license.
* http://jquery.org/license
*
*/

(function (root, doc, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(["jquery"], function ($) {
            factory($, root, doc);
            return $.mobile;
        });
    } else {
        // Browser globals
        factory(root.jQuery, root, doc);
    }
}(this, document, function (jQuery, window, document, undefined) {
    (function ($, undefined) {
        $.extend($.support, {
            orientation: "orientation" in window && "onorientationchange" in window
        });
    }(jQuery));


    // throttled resize event
    (function ($) {
        $.event.special.throttledresize = {
            setup: function () {
                $(this).bind("resize", handler);
            },
            teardown: function () {
                $(this).unbind("resize", handler);
            }
        };

        var throttle = 250,
			handler = function () {
			    curr = (new Date()).getTime();
			    diff = curr - lastCall;

			    if (diff >= throttle) {

			        lastCall = curr;
			        $(this).trigger("throttledresize");

			    } else {

			        if (heldCall) {
			            clearTimeout(heldCall);
			        }

			        // Promise a held call will still execute
			        heldCall = setTimeout(handler, throttle - diff);
			    }
			},
			lastCall = 0,
			heldCall,
			curr,
			diff;
    })(jQuery);


    (function ($, window) {
        var win = $(window),
            event_name = "orientationchange",
            get_orientation,
            last_orientation,
            initial_orientation_is_landscape,
            initial_orientation_is_default,
            portrait_map = { "0": true, "180": true },
            ww, wh, landscape_threshold;

        // It seems that some device/browser vendors use window.orientation values 0 and 180 to
        // denote the "default" orientation. For iOS devices, and most other smart-phones tested,
        // the default orientation is always "portrait", but in some Android and RIM based tablets,
        // the default orientation is "landscape". The following code attempts to use the window
        // dimensions to figure out what the current orientation is, and then makes adjustments
        // to the to the portrait_map if necessary, so that we can properly decode the
        // window.orientation value whenever get_orientation() is called.
        //
        // Note that we used to use a media query to figure out what the orientation the browser
        // thinks it is in:
        //
        //     initial_orientation_is_landscape = $.mobile.media("all and (orientation: landscape)");
        //
        // but there was an iPhone/iPod Touch bug beginning with iOS 4.2, up through iOS 5.1,
        // where the browser *ALWAYS* applied the landscape media query. This bug does not
        // happen on iPad.

        if ($.support.orientation) {

            // Check the window width and height to figure out what the current orientation
            // of the device is at this moment. Note that we've initialized the portrait map
            // values to 0 and 180, *AND* we purposely check for landscape so that if we guess
            // wrong, , we default to the assumption that portrait is the default orientation.
            // We use a threshold check below because on some platforms like iOS, the iPhone
            // form-factor can report a larger width than height if the user turns on the
            // developer console. The actual threshold value is somewhat arbitrary, we just
            // need to make sure it is large enough to exclude the developer console case.

            ww = window.innerWidth || win.width();
            wh = window.innerHeight || win.height();
            landscape_threshold = 50;

            initial_orientation_is_landscape = ww > wh && (ww - wh) > landscape_threshold;

            // Now check to see if the current window.orientation is 0 or 180.
            initial_orientation_is_default = portrait_map[window.orientation];

            // If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*
            // if the initial orientation is portrait, but window.orientation reports 90 or -90, we
            // need to flip our portrait_map values because landscape is the default orientation for
            // this device/browser.
            if ((initial_orientation_is_landscape && initial_orientation_is_default) || (!initial_orientation_is_landscape && !initial_orientation_is_default)) {
                portrait_map = { "-90": true, "90": true };
            }
        }

        $.event.special.orientationchange = $.extend({}, $.event.special.orientationchange, {
            setup: function () {
                // If the event is supported natively, return false so that jQuery
                // will bind to the event using DOM methods.
                if ($.support.orientation && !$.event.special.orientationchange.disabled) {
                    return false;
                }

                // Get the current orientation to avoid initial double-triggering.
                last_orientation = get_orientation();

                // Because the orientationchange event doesn't exist, simulate the
                // event by testing window dimensions on resize.
                win.bind("throttledresize", handler);
            },
            teardown: function () {
                // If the event is not supported natively, return false so that
                // jQuery will unbind the event using DOM methods.
                if ($.support.orientation && !$.event.special.orientationchange.disabled) {
                    return false;
                }

                // Because the orientationchange event doesn't exist, unbind the
                // resize event handler.
                win.unbind("throttledresize", handler);
            },
            add: function (handleObj) {
                // Save a reference to the bound event handler.
                var old_handler = handleObj.handler;

                handleObj.handler = function (event) {
                    // Modify event object, adding the .orientation property.
                    event.orientation = get_orientation();

                    // Call the originally-bound event handler and return its result.
                    return old_handler.apply(this, arguments);
                };
            }
        });

        // If the event is not supported natively, this handler will be bound to
        // the window resize event to simulate the orientationchange event.
        function handler() {
            // Get the current orientation.
            var orientation = get_orientation();

            if (orientation !== last_orientation) {
                // The orientation has changed, so trigger the orientationchange event.
                last_orientation = orientation;
                win.trigger(event_name);
            }
        }

        // Get the current page orientation. This method is exposed publicly, should it
        // be needed, as jQuery.event.special.orientationchange.orientation()
        $.event.special.orientationchange.orientation = get_orientation = function () {
            var isPortrait = true, elem = document.documentElement;

            // prefer window orientation to the calculation based on screensize as
            // the actual screen resize takes place before or after the orientation change event
            // has been fired depending on implementation (eg android 2.3 is before, iphone after).
            // More testing is required to determine if a more reliable method of determining the new screensize
            // is possible when orientationchange is fired. (eg, use media queries + element + opacity)
            if ($.support.orientation) {
                // if the window orientation registers as 0 or 180 degrees report
                // portrait, otherwise landscape
                isPortrait = portrait_map[window.orientation];
            } else {
                isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
            }

            return isPortrait ? "portrait" : "landscape";
        };

        $.fn[event_name] = function (fn) {
            return fn ? this.bind(event_name, fn) : this.trigger(event_name);
        };

        // jQuery < 1.8
        if ($.attrFn) {
            $.attrFn[event_name] = true;
        }

    }(jQuery, this));


    // This plugin is an experiment for abstracting away the touch and mouse
    // events so that developers don't have to worry about which method of input
    // the device their document is loaded on supports.
    //
    // The idea here is to allow the developer to register listeners for the
    // basic mouse events, such as mousedown, mousemove, mouseup, and click,
    // and the plugin will take care of registering the correct listeners
    // behind the scenes to invoke the listener at the fastest possible time
    // for that device, while still retaining the order of event firing in
    // the traditional mouse environment, should multiple handlers be registered
    // on the same element for different events.
    //
    // The current version exposes the following virtual events to jQuery bind methods:
    // "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"

    (function ($, window, document, undefined) {

        var dataPropertyName = "virtualMouseBindings",
            touchTargetPropertyName = "virtualTouchID",
            virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split(" "),
            touchEventProps = "clientX clientY pageX pageY screenX screenY".split(" "),
            mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
            mouseEventProps = $.event.props.concat(mouseHookProps),
            activeDocHandlers = {},
            resetTimerID = 0,
            startX = 0,
            startY = 0,
            didScroll = false,
            clickBlockList = [],
            blockMouseTriggers = false,
            blockTouchTriggers = false,
            eventCaptureSupported = "addEventListener" in document,
            $document = $(document),
            nextTouchID = 1,
            lastTouchID = 0, threshold,
            i;

        $.vmouse = {
            moveDistanceThreshold: 10,
            clickDistanceThreshold: 10,
            resetTimerDuration: 1500
        };

        function getNativeEvent(event) {

            while (event && typeof event.originalEvent !== "undefined") {
                event = event.originalEvent;
            }
            return event;
        }

        function createVirtualEvent(event, eventType) {

            var t = event.type,
                oe, props, ne, prop, ct, touch, i, j, len;

            event = $.Event(event);
            event.type = eventType;

            oe = event.originalEvent;
            props = $.event.props;

            // addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
            // https://github.com/jquery/jquery-mobile/issues/3280
            if (t.search(/^(mouse|click)/) > -1) {
                props = mouseEventProps;
            }

            // copy original event properties over to the new event
            // this would happen if we could call $.event.fix instead of $.Event
            // but we don't have a way to force an event to be fixed multiple times
            if (oe) {
                for (i = props.length, prop; i;) {
                    prop = props[--i];
                    event[prop] = oe[prop];
                }
            }

            // make sure that if the mouse and click virtual events are generated
            // without a .which one is defined
            if (t.search(/mouse(down|up)|click/) > -1 && !event.which) {
                event.which = 1;
            }

            if (t.search(/^touch/) !== -1) {
                ne = getNativeEvent(oe);
                t = ne.touches;
                ct = ne.changedTouches;
                touch = (t && t.length) ? t[0] : ((ct && ct.length) ? ct[0] : undefined);

                if (touch) {
                    for (j = 0, len = touchEventProps.length; j < len; j++) {
                        prop = touchEventProps[j];
                        event[prop] = touch[prop];
                    }
                }
            }

            return event;
        }

        function getVirtualBindingFlags(element) {

            var flags = {},
                b, k;

            while (element) {

                b = $.data(element, dataPropertyName);

                for (k in b) {
                    if (b[k]) {
                        flags[k] = flags.hasVirtualBinding = true;
                    }
                }
                element = element.parentNode;
            }
            return flags;
        }

        function getClosestElementWithVirtualBinding(element, eventType) {
            var b;
            while (element) {

                b = $.data(element, dataPropertyName);

                if (b && (!eventType || b[eventType])) {
                    return element;
                }
                element = element.parentNode;
            }
            return null;
        }

        function enableTouchBindings() {
            blockTouchTriggers = false;
        }

        function disableTouchBindings() {
            blockTouchTriggers = true;
        }

        function enableMouseBindings() {
            lastTouchID = 0;
            clickBlockList.length = 0;
            blockMouseTriggers = false;

            // When mouse bindings are enabled, our
            // touch bindings are disabled.
            disableTouchBindings();
        }

        function disableMouseBindings() {
            // When mouse bindings are disabled, our
            // touch bindings are enabled.
            enableTouchBindings();
        }

        function startResetTimer() {
            clearResetTimer();
            resetTimerID = setTimeout(function () {
                resetTimerID = 0;
                enableMouseBindings();
            }, $.vmouse.resetTimerDuration);
        }

        function clearResetTimer() {
            if (resetTimerID) {
                clearTimeout(resetTimerID);
                resetTimerID = 0;
            }
        }

        function triggerVirtualEvent(eventType, event, flags) {
            var ve;

            if ((flags && flags[eventType]) ||
                        (!flags && getClosestElementWithVirtualBinding(event.target, eventType))) {

                ve = createVirtualEvent(event, eventType);

                $(event.target).trigger(ve);
            }

            return ve;
        }

        function mouseEventCallback(event) {
            var touchID = $.data(event.target, touchTargetPropertyName),
                ve;

            if (!blockMouseTriggers && (!lastTouchID || lastTouchID !== touchID)) {
                ve = triggerVirtualEvent("v" + event.type, event);
                if (ve) {
                    if (ve.isDefaultPrevented()) {
                        event.preventDefault();
                    }
                    if (ve.isPropagationStopped()) {
                        event.stopPropagation();
                    }
                    if (ve.isImmediatePropagationStopped()) {
                        event.stopImmediatePropagation();
                    }
                }
            }
        }

        function handleTouchStart(event) {

            var touches = getNativeEvent(event).touches,
                target, flags, t;

            if (touches && touches.length === 1) {

                target = event.target;
                flags = getVirtualBindingFlags(target);

                if (flags.hasVirtualBinding) {

                    lastTouchID = nextTouchID++;
                    $.data(target, touchTargetPropertyName, lastTouchID);

                    clearResetTimer();

                    disableMouseBindings();
                    didScroll = false;

                    t = getNativeEvent(event).touches[0];
                    startX = t.pageX;
                    startY = t.pageY;

                    triggerVirtualEvent("vmouseover", event, flags);
                    triggerVirtualEvent("vmousedown", event, flags);
                }
            }
        }

        function handleScroll(event) {
            if (blockTouchTriggers) {
                return;
            }

            if (!didScroll) {
                triggerVirtualEvent("vmousecancel", event, getVirtualBindingFlags(event.target));
            }

            didScroll = true;
            startResetTimer();
        }

        function handleTouchMove(event) {
            if (blockTouchTriggers) {
                return;
            }

            var t = getNativeEvent(event).touches[0],
                didCancel = didScroll,
                moveThreshold = $.vmouse.moveDistanceThreshold,
                flags = getVirtualBindingFlags(event.target);

            didScroll = didScroll ||
                (Math.abs(t.pageX - startX) > moveThreshold ||
                    Math.abs(t.pageY - startY) > moveThreshold);

            if (didScroll && !didCancel) {
                triggerVirtualEvent("vmousecancel", event, flags);
            }

            triggerVirtualEvent("vmousemove", event, flags);
            startResetTimer();
        }

        function handleTouchEnd(event) {
            if (blockTouchTriggers) {
                return;
            }

            disableTouchBindings();

            var flags = getVirtualBindingFlags(event.target),
                ve, t;
            triggerVirtualEvent("vmouseup", event, flags);

            if (!didScroll) {
                ve = triggerVirtualEvent("vclick", event, flags);
                if (ve && ve.isDefaultPrevented()) {
                    // The target of the mouse events that follow the touchend
                    // event don't necessarily match the target used during the
                    // touch. This means we need to rely on coordinates for blocking
                    // any click that is generated.
                    t = getNativeEvent(event).changedTouches[0];
                    clickBlockList.push({
                        touchID: lastTouchID,
                        x: t.clientX,
                        y: t.clientY
                    });

                    // Prevent any mouse events that follow from triggering
                    // virtual event notifications.
                    blockMouseTriggers = true;
                }
            }
            triggerVirtualEvent("vmouseout", event, flags);
            didScroll = false;

            startResetTimer();
        }

        function hasVirtualBindings(ele) {
            var bindings = $.data(ele, dataPropertyName),
                k;

            if (bindings) {
                for (k in bindings) {
                    if (bindings[k]) {
                        return true;
                    }
                }
            }
            return false;
        }

        function dummyMouseHandler() { }

        function getSpecialEventObject(eventType) {
            var realType = eventType.substr(1);

            return {
                setup: function (/* data, namespace */) {
                    // If this is the first virtual mouse binding for this element,
                    // add a bindings object to its data.

                    if (!hasVirtualBindings(this)) {
                        $.data(this, dataPropertyName, {});
                    }

                    // If setup is called, we know it is the first binding for this
                    // eventType, so initialize the count for the eventType to zero.
                    var bindings = $.data(this, dataPropertyName);
                    bindings[eventType] = true;

                    // If this is the first virtual mouse event for this type,
                    // register a global handler on the document.

                    activeDocHandlers[eventType] = (activeDocHandlers[eventType] || 0) + 1;

                    if (activeDocHandlers[eventType] === 1) {
                        $document.bind(realType, mouseEventCallback);
                    }

                    // Some browsers, like Opera Mini, won't dispatch mouse/click events
                    // for elements unless they actually have handlers registered on them.
                    // To get around this, we register dummy handlers on the elements.

                    $(this).bind(realType, dummyMouseHandler);

                    // For now, if event capture is not supported, we rely on mouse handlers.
                    if (eventCaptureSupported) {
                        // If this is the first virtual mouse binding for the document,
                        // register our touchstart handler on the document.

                        activeDocHandlers["touchstart"] = (activeDocHandlers["touchstart"] || 0) + 1;

                        if (activeDocHandlers["touchstart"] === 1) {
                            $document.bind("touchstart", handleTouchStart)
                                .bind("touchend", handleTouchEnd)

                                // On touch platforms, touching the screen and then dragging your finger
                                // causes the window content to scroll after some distance threshold is
                                // exceeded. On these platforms, a scroll prevents a click event from being
                                // dispatched, and on some platforms, even the touchend is suppressed. To
                                // mimic the suppression of the click event, we need to watch for a scroll
                                // event. Unfortunately, some platforms like iOS don't dispatch scroll
                                // events until *AFTER* the user lifts their finger (touchend). This means
                                // we need to watch both scroll and touchmove events to figure out whether
                                // or not a scroll happenens before the touchend event is fired.

                                .bind("touchmove", handleTouchMove)
                                .bind("scroll", handleScroll);
                        }
                    }
                },

                teardown: function (/* data, namespace */) {
                    // If this is the last virtual binding for this eventType,
                    // remove its global handler from the document.

                    --activeDocHandlers[eventType];

                    if (!activeDocHandlers[eventType]) {
                        $document.unbind(realType, mouseEventCallback);
                    }

                    if (eventCaptureSupported) {
                        // If this is the last virtual mouse binding in existence,
                        // remove our document touchstart listener.

                        --activeDocHandlers["touchstart"];

                        if (!activeDocHandlers["touchstart"]) {
                            $document.unbind("touchstart", handleTouchStart)
                                .unbind("touchmove", handleTouchMove)
                                .unbind("touchend", handleTouchEnd)
                                .unbind("scroll", handleScroll);
                        }
                    }

                    var $this = $(this),
                        bindings = $.data(this, dataPropertyName);

                    // teardown may be called when an element was
                    // removed from the DOM. If this is the case,
                    // jQuery core may have already stripped the element
                    // of any data bindings so we need to check it before
                    // using it.
                    if (bindings) {
                        bindings[eventType] = false;
                    }

                    // Unregister the dummy event handler.

                    $this.unbind(realType, dummyMouseHandler);

                    // If this is the last virtual mouse binding on the
                    // element, remove the binding data from the element.

                    if (!hasVirtualBindings(this)) {
                        $this.removeData(dataPropertyName);
                    }
                }
            };
        }

        // Expose our custom events to the jQuery bind/unbind mechanism.

        for (i = 0; i < virtualEventNames.length; i++) {
            $.event.special[virtualEventNames[i]] = getSpecialEventObject(virtualEventNames[i]);
        }

        // Add a capture click handler to block clicks.
        // Note that we require event capture support for this so if the device
        // doesn't support it, we punt for now and rely solely on mouse events.
        if (eventCaptureSupported) {
            document.addEventListener("click", function (e) {
                var cnt = clickBlockList.length,
                    target = e.target,
                    x, y, ele, i, o, touchID;

                if (cnt) {
                    x = e.clientX;
                    y = e.clientY;
                    threshold = $.vmouse.clickDistanceThreshold;

                    // The idea here is to run through the clickBlockList to see if
                    // the current click event is in the proximity of one of our
                    // vclick events that had preventDefault() called on it. If we find
                    // one, then we block the click.
                    //
                    // Why do we have to rely on proximity?
                    //
                    // Because the target of the touch event that triggered the vclick
                    // can be different from the target of the click event synthesized
                    // by the browser. The target of a mouse/click event that is synthesized
                    // from a touch event seems to be implementation specific. For example,
                    // some browsers will fire mouse/click events for a link that is near
                    // a touch event, even though the target of the touchstart/touchend event
                    // says the user touched outside the link. Also, it seems that with most
                    // browsers, the target of the mouse/click event is not calculated until the
                    // time it is dispatched, so if you replace an element that you touched
                    // with another element, the target of the mouse/click will be the new
                    // element underneath that point.
                    //
                    // Aside from proximity, we also check to see if the target and any
                    // of its ancestors were the ones that blocked a click. This is necessary
                    // because of the strange mouse/click target calculation done in the
                    // Android 2.1 browser, where if you click on an element, and there is a
                    // mouse/click handler on one of its ancestors, the target will be the
                    // innermost child of the touched element, even if that child is no where
                    // near the point of touch.

                    ele = target;

                    while (ele) {
                        for (i = 0; i < cnt; i++) {
                            o = clickBlockList[i];
                            touchID = 0;

                            if ((ele === target && Math.abs(o.x - x) < threshold && Math.abs(o.y - y) < threshold) ||
                                        $.data(ele, touchTargetPropertyName) === o.touchID) {
                                // XXX: We may want to consider removing matches from the block list
                                //      instead of waiting for the reset timer to fire.
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                        }
                        ele = ele.parentNode;
                    }
                }
            }, true);
        }
    })(jQuery, window, document);

    (function ($) {
        $.mobile = {};
    }(jQuery));

    (function ($, undefined) {
        var support = {
            touch: "ontouchend" in document
        };

        $.mobile.support = $.mobile.support || {};
        $.extend($.support, support);
        $.extend($.mobile.support, support);
    }(jQuery));


    (function ($, window, undefined) {
        var $document = $(document),
            supportTouch = $.mobile.support.touch,
            scrollEvent = "touchmove scroll",
            touchStartEvent = supportTouch ? "touchstart" : "mousedown",
            touchStopEvent = supportTouch ? "touchend" : "mouseup",
            touchMoveEvent = supportTouch ? "touchmove" : "mousemove";

        // setup new event shortcuts
        $.each(("touchstart touchmove touchend " +
            "tap taphold " +
            "swipe swipeleft swiperight swipeup swipedown " +
            "scrollstart scrollstop").split(" "), function (i, name) {

                $.fn[name] = function (fn) {
                    return fn ? this.bind(name, fn) : this.trigger(name);
                };

                // jQuery < 1.8
                if ($.attrFn) {
                    $.attrFn[name] = true;
                }
            });

        function triggerCustomEvent(obj, eventType, event, bubble) {
            var originalType = event.type;
            event.type = eventType;
            if (bubble) {
                $.event.trigger(event, undefined, obj);
            } else {
                $.event.dispatch.call(obj, event);
            }
            event.type = originalType;
        }

        // also handles scrollstop
        $.event.special.scrollstart = {

            enabled: true,
            setup: function () {

                var thisObject = this,
                    $this = $(thisObject),
                    scrolling,
                    timer;

                function trigger(event, state) {
                    scrolling = state;
                    triggerCustomEvent(thisObject, scrolling ? "scrollstart" : "scrollstop", event);
                }

                // iPhone triggers scroll after a small delay; use touchmove instead
                $this.bind(scrollEvent, function (event) {

                    if (!$.event.special.scrollstart.enabled) {
                        return;
                    }

                    if (!scrolling) {
                        trigger(event, true);
                    }

                    clearTimeout(timer);
                    timer = setTimeout(function () {
                        trigger(event, false);
                    }, 50);
                });
            },
            teardown: function () {
                $(this).unbind(scrollEvent);
            }
        };

        // also handles taphold
        $.event.special.tap = {
            tapholdThreshold: 750,
            emitTapOnTaphold: true,
            setup: function () {
                var thisObject = this,
                    $this = $(thisObject),
                    isTaphold = false;

                $this.bind("vmousedown", function (event) {
                    isTaphold = false;
                    if (event.which && event.which !== 1) {
                        return false;
                    }

                    var origTarget = event.target,
                        timer;

                    function clearTapTimer() {
                        clearTimeout(timer);
                    }

                    function clearTapHandlers() {
                        clearTapTimer();

                        $this.unbind("vclick", clickHandler)
                            .unbind("vmouseup", clearTapTimer);
                        $document.unbind("vmousecancel", clearTapHandlers);
                    }

                    function clickHandler(event) {
                        clearTapHandlers();

                        // ONLY trigger a 'tap' event if the start target is
                        // the same as the stop target.
                        if (!isTaphold && origTarget === event.target) {
                            triggerCustomEvent(thisObject, "tap", event);
                        } else if (isTaphold) {
                            event.preventDefault();
                        }
                    }

                    $this.bind("vmouseup", clearTapTimer)
                        .bind("vclick", clickHandler);
                    $document.bind("vmousecancel", clearTapHandlers);

                    timer = setTimeout(function () {
                        if (!$.event.special.tap.emitTapOnTaphold) {
                            isTaphold = true;
                        }
                        triggerCustomEvent(thisObject, "taphold", $.Event("taphold", { target: origTarget }));
                    }, $.event.special.tap.tapholdThreshold);
                });
            },
            teardown: function () {
                $(this).unbind("vmousedown").unbind("vclick").unbind("vmouseup");
                $document.unbind("vmousecancel");
            }
        };

        // Also handles swipeleft, swiperight
        $.event.special.swipe = {

            // More than this horizontal displacement, and we will suppress scrolling.
            scrollSupressionThreshold: 30,

            // More time than this, and it isn't a swipe.
            durationThreshold: 1000,

            // Swipe horizontal displacement must be more than this.
            horizontalDistanceThreshold: 30,

            // Swipe vertical displacement must be less than this.
            verticalDistanceThreshold: 30,

            getLocation: function (event) {
                var winPageX = window.pageXOffset,
                    winPageY = window.pageYOffset,
                    x = event.clientX,
                    y = event.clientY;

                if (event.pageY === 0 && Math.floor(y) > Math.floor(event.pageY) ||
                    event.pageX === 0 && Math.floor(x) > Math.floor(event.pageX)) {

                    // iOS4 clientX/clientY have the value that should have been
                    // in pageX/pageY. While pageX/page/ have the value 0
                    x = x - winPageX;
                    y = y - winPageY;
                } else if (y < (event.pageY - winPageY) || x < (event.pageX - winPageX)) {

                    // Some Android browsers have totally bogus values for clientX/Y
                    // when scrolling/zooming a page. Detectable since clientX/clientY
                    // should never be smaller than pageX/pageY minus page scroll
                    x = event.pageX - winPageX;
                    y = event.pageY - winPageY;
                }

                return {
                    x: x,
                    y: y
                };
            },

            start: function (event) {
                var data = event.originalEvent.touches ?
                        event.originalEvent.touches[0] : event,
                    location = $.event.special.swipe.getLocation(data);
                return {
                    time: (new Date()).getTime(),
                    coords: [location.x, location.y],
                    origin: $(event.target)
                };
            },

            stop: function (event) {
                var data = event.originalEvent.touches ?
                        event.originalEvent.touches[0] : event,
                    location = $.event.special.swipe.getLocation(data);
                return {
                    time: (new Date()).getTime(),
                    coords: [location.x, location.y]
                };
            },

            handleSwipe: function (start, stop, thisObject, origTarget) {
                //TrinhNVd: Thm s kin vut ln, xung
                if (stop.time - start.time < $.event.special.swipe.durationThreshold) {
                    var direction = "";
                    if (Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.swipe.horizontalDistanceThreshold &&
                        Math.abs(start.coords[1] - stop.coords[1]) < $.event.special.swipe.verticalDistanceThreshold) {
                        direction = start.coords[0] > stop.coords[0] ? "swipeleft" : "swiperight";
                    }
                    else if (Math.abs(start.coords[0] - stop.coords[0]) < $.event.special.swipe.horizontalDistanceThreshold &&
                        Math.abs(start.coords[1] - stop.coords[1]) > $.event.special.swipe.verticalDistanceThreshold) {
                        direction = start.coords[1] > stop.coords[1] ? "swipeup" : "swipedown";
                    }
                    triggerCustomEvent(thisObject, "swipe", $.Event("swipe", { target: origTarget, swipestart: start, swipestop: stop }), true);
                    triggerCustomEvent(thisObject, direction, $.Event(direction, { target: origTarget, swipestart: start, swipestop: stop }), true);
                    return true;
                }
                return false;
            },

            // This serves as a flag to ensure that at most one swipe event event is
            // in work at any given time
            eventInProgress: false,

            setup: function () {
                var events,
                    thisObject = this,
                    $this = $(thisObject),
                    context = {};

                // Retrieve the events data for this element and add the swipe context
                events = $.data(this, "mobile-events");
                if (!events) {
                    events = { length: 0 };
                    $.data(this, "mobile-events", events);
                }
                events.length++;
                events.swipe = context;

                context.start = function (event) {

                    // Bail if we're already working on a swipe event
                    if ($.event.special.swipe.eventInProgress) {
                        return;
                    }
                    $.event.special.swipe.eventInProgress = true;

                    var stop,
                        start = $.event.special.swipe.start(event),
                        origTarget = event.target,
                        emitted = false;

                    context.move = function (event) {
                        if (!start || event.isDefaultPrevented()) {
                            return;
                        }

                        stop = $.event.special.swipe.stop(event);
                        if (!emitted) {
                            emitted = $.event.special.swipe.handleSwipe(start, stop, thisObject, origTarget);
                            if (emitted) {

                                // Reset the context to make way for the next swipe event
                                $.event.special.swipe.eventInProgress = false;
                            }
                        }
                        // prevent scrolling
                        if (Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.swipe.scrollSupressionThreshold) {
                            event.preventDefault();
                        }
                    };

                    context.stop = function () {
                        emitted = true;

                        // Reset the context to make way for the next swipe event
                        $.event.special.swipe.eventInProgress = false;
                        $document.off(touchMoveEvent, context.move);
                        context.move = null;
                    };

                    $document.on(touchMoveEvent, context.move)
                        .one(touchStopEvent, context.stop);
                };
                $this.on(touchStartEvent, context.start);
            },

            teardown: function () {
                var events, context;

                events = $.data(this, "mobile-events");
                if (events) {
                    context = events.swipe;
                    delete events.swipe;
                    events.length--;
                    if (events.length === 0) {
                        $.removeData(this, "mobile-events");
                    }
                }

                if (context) {
                    if (context.start) {
                        $(this).off(touchStartEvent, context.start);
                    }
                    if (context.move) {
                        $document.off(touchMoveEvent, context.move);
                    }
                    if (context.stop) {
                        $document.off(touchStopEvent, context.stop);
                    }
                }
            }
        };
        $.each({
            scrollstop: "scrollstart",
            taphold: "tap",
            swipeleft: "swipe.left",
            swiperight: "swipe.right",
            swipeup: "swipe.up",
            swipedown: "swipe.down"
        }, function (event, sourceEvent) {

            $.event.special[event] = {
                setup: function () {
                    $(this).bind(sourceEvent, $.noop);
                },
                teardown: function () {
                    $(this).unbind(sourceEvent);
                }
            };
        });

    })(jQuery, this);

    (function ($, undefined) {
        var props = {
            "animation": {},
            "transition": {}
        },
            testElement = document.createElement("a"),
            vendorPrefixes = ["", "webkit-", "moz-", "o-"];

        $.each(["animation", "transition"], function (i, test) {

            // Get correct name for test
            var testName = (i === 0) ? test + "-" + "name" : test;

            $.each(vendorPrefixes, function (j, prefix) {
                if (testElement.style[$.camelCase(prefix + testName)] !== undefined) {
                    props[test]["prefix"] = prefix;
                    return false;
                }
            });

            // Set event and duration names for later use
            props[test]["duration"] =
                $.camelCase(props[test]["prefix"] + test + "-" + "duration");
            props[test]["event"] =
                $.camelCase(props[test]["prefix"] + test + "-" + "end");

            // All lower case if not a vendor prop
            if (props[test]["prefix"] === "") {
                props[test]["event"] = props[test]["event"].toLowerCase();
            }
        });

        // If a valid prefix was found then the it is supported by the browser
        $.support.cssTransitions = (props["transition"]["prefix"] !== undefined);
        $.support.cssAnimations = (props["animation"]["prefix"] !== undefined);

        // Remove the testElement
        $(testElement).remove();

        // Animation complete callback
        $.fn.animationComplete = function (callback, type, fallbackTime) {
            var timer, duration,
                that = this,
                eventBinding = function () {

                    // Clear the timer so we don't call callback twice
                    clearTimeout(timer);
                    callback.apply(this, arguments);
                },
                animationType = (!type || type === "animation") ? "animation" : "transition";

            // Make sure selected type is supported by browser
            if (($.support.cssTransitions && animationType === "transition") ||
                ($.support.cssAnimations && animationType === "animation")) {

                // If a fallback time was not passed set one
                if (fallbackTime === undefined) {

                    // Make sure the was not bound to document before checking .css
                    if ($(this).context !== document) {

                        // Parse the durration since its in second multiple by 1000 for milliseconds
                        // Multiply by 3 to make sure we give the animation plenty of time.
                        duration = parseFloat(
                            $(this).css(props[animationType].duration)
                        ) * 3000;
                    }

                    // If we could not read a duration use the default
                    if (duration === 0 || duration === undefined || isNaN(duration)) {
                        duration = $.fn.animationComplete.defaultDuration;
                    }
                }

                // Sets up the fallback if event never comes
                timer = setTimeout(function () {
                    $(that).off(props[animationType].event, eventBinding);
                    callback.apply(that);
                }, duration);

                // Bind the event
                return $(this).one(props[animationType].event, eventBinding);
            } else {

                // CSS animation / transitions not supported
                // Defer execution for consistency between webkit/non webkit
                setTimeout($.proxy(callback, this), 0);
                return $(this);
            }
        };

        // Allow default callback to be configured on mobileInit
        $.fn.animationComplete.defaultDuration = 1000;
    })(jQuery);

    (function ($, window, undefined) {
        var nsNormalizeDict = {},
            oldFind = $.find,
            rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
            jqmDataRE = /:jqmData\(([^)]*)\)/g;

        $.extend($.mobile, {

            // Namespace used framework-wide for data-attrs. Default is no namespace

            ns: "",

            // Retrieve an attribute from an element and perform some massaging of the value

            getAttribute: function (element, key) {
                var data;

                element = element.jquery ? element[0] : element;

                if (element && element.getAttribute) {
                    data = element.getAttribute("data-" + $.mobile.ns + key);
                }

                // Copied from core's src/data.js:dataAttr()
                // Convert from a string to a proper data type
                try {
                    data = data === "true" ? true :
                        data === "false" ? false :
                        data === "null" ? null :
                        // Only convert to a number if it doesn't change the string
                        +data + "" === data ? +data :
                        rbrace.test(data) ? JSON.parse(data) :
                        data;
                } catch (err) { }

                return data;
            },

            // Expose our cache for testing purposes.
            nsNormalizeDict: nsNormalizeDict,

            // Take a data attribute property, prepend the namespace
            // and then camel case the attribute string. Add the result
            // to our nsNormalizeDict so we don't have to do this again.
            nsNormalize: function (prop) {
                return nsNormalizeDict[prop] ||
                    (nsNormalizeDict[prop] = $.camelCase($.mobile.ns + prop));
            },

            // Find the closest javascript page element to gather settings data jsperf test
            // http://jsperf.com/single-complex-selector-vs-many-complex-selectors/edit
            // possibly naive, but it shows that the parsing overhead for *just* the page selector vs
            // the page and dialog selector is negligable. This could probably be speed up by
            // doing a similar parent node traversal to the one found in the inherited theme code above
            closestPageData: function ($target) {
                return $target
                    .closest(":jqmData(role='page'), :jqmData(role='dialog')")
                    .data("mobile-page");
            }

        });

        // Mobile version of data and removeData and hasData methods
        // ensures all data is set and retrieved using jQuery Mobile's data namespace
        $.fn.jqmData = function (prop, value) {
            var result;
            if (typeof prop !== "undefined") {
                if (prop) {
                    prop = $.mobile.nsNormalize(prop);
                }

                // undefined is permitted as an explicit input for the second param
                // in this case it returns the value and does not set it to undefined
                if (arguments.length < 2 || value === undefined) {
                    result = this.data(prop);
                } else {
                    result = this.data(prop, value);
                }
            }
            return result;
        };

        $.jqmData = function (elem, prop, value) {
            var result;
            if (typeof prop !== "undefined") {
                result = $.data(elem, prop ? $.mobile.nsNormalize(prop) : prop, value);
            }
            return result;
        };

        $.fn.jqmRemoveData = function (prop) {
            return this.removeData($.mobile.nsNormalize(prop));
        };

        $.jqmRemoveData = function (elem, prop) {
            return $.removeData(elem, $.mobile.nsNormalize(prop));
        };

        $.find = function (selector, context, ret, extra) {
            if (selector.indexOf(":jqmData") > -1) {
                selector = selector.replace(jqmDataRE, "[data-" + ($.mobile.ns || "") + "$1]");
            }

            return oldFind.call(this, selector, context, ret, extra);
        };

        $.extend($.find, oldFind);

    })(jQuery, this);

    (function ($, window, undefined) {
        $.extend($.mobile, {

            // Version of the jQuery Mobile Framework
            version: "1.4.5",

            // Deprecated and no longer used in 1.4 remove in 1.5
            // Define the url parameter used for referencing widget-generated sub-pages.
            // Translates to example.html&ui-page=subpageIdentifier
            // hash segment before &ui-page= is used to make Ajax request
            subPageUrlKey: "ui-page",

            hideUrlBar: true,

            // Keepnative Selector
            keepNative: ":jqmData(role='none'), :jqmData(role='nojs')",

            // Deprecated in 1.4 remove in 1.5
            // Class assigned to page currently in view, and during transitions
            activePageClass: "ui-page-active",

            // Deprecated in 1.4 remove in 1.5
            // Class used for "active" button state, from CSS framework
            activeBtnClass: "ui-btn-active",

            // Deprecated in 1.4 remove in 1.5
            // Class used for "focus" form element state, from CSS framework
            focusClass: "ui-focus",

            // Automatically handle clicks and form submissions through Ajax, when same-domain
            ajaxEnabled: true,

            // Automatically load and show pages based on location.hash
            hashListeningEnabled: true,

            // disable to prevent jquery from bothering with links
            linkBindingEnabled: true,

            // Set default page transition - 'none' for no transitions
            defaultPageTransition: "fade",

            // Set maximum window width for transitions to apply - 'false' for no limit
            maxTransitionWidth: false,

            // Minimum scroll distance that will be remembered when returning to a page
            // Deprecated remove in 1.5
            minScrollBack: 0,

            // Set default dialog transition - 'none' for no transitions
            defaultDialogTransition: "pop",

            // Error response message - appears when an Ajax page request fails
            pageLoadErrorMessage: "Error Loading Page",

            // For error messages, which theme does the box use?
            pageLoadErrorMessageTheme: "a",

            // replace calls to window.history.back with phonegaps navigation helper
            // where it is provided on the window object
            phonegapNavigationEnabled: false,

            //automatically initialize the DOM when it's ready
            autoInitializePage: true,

            pushStateEnabled: true,

            // allows users to opt in to ignoring content by marking a parent element as
            // data-ignored
            ignoreContentEnabled: false,

            buttonMarkup: {
                hoverDelay: 200
            },

            // disable the alteration of the dynamic base tag or links in the case
            // that a dynamic base tag isn't supported
            dynamicBaseEnabled: true,

            // default the property to remove dependency on assignment in init module
            pageContainer: $(),

            //enable cross-domain page support
            allowCrossDomainPages: false,

            dialogHashKey: "&ui-state=dialog"
        });
    })(jQuery, this);

    /*!
     * jQuery UI Core c0ab71056b936627e8a7821f03c044aec6280a40
     * http://jqueryui.com
     *
     * Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/category/ui-core/
     */
    (function ($, undefined) {

        var uuid = 0,
            runiqueId = /^ui-id-\d+$/;

        // $.ui might exist from components with no dependencies, e.g., $.ui.position
        $.ui = $.ui || {};

        $.extend($.ui, {
            version: "c0ab71056b936627e8a7821f03c044aec6280a40",

            keyCode: {
                BACKSPACE: 8,
                COMMA: 188,
                DELETE: 46,
                DOWN: 40,
                END: 35,
                ENTER: 13,
                ESCAPE: 27,
                HOME: 36,
                LEFT: 37,
                PAGE_DOWN: 34,
                PAGE_UP: 33,
                PERIOD: 190,
                RIGHT: 39,
                SPACE: 32,
                TAB: 9,
                UP: 38
            }
        });

        // plugins
        $.fn.extend({
            focus: (function (orig) {
                return function (delay, fn) {
                    return typeof delay === "number" ?
                        this.each(function () {
                            var elem = this;
                            setTimeout(function () {
                                $(elem).focus();
                                if (fn) {
                                    fn.call(elem);
                                }
                            }, delay);
                        }) :
                        orig.apply(this, arguments);
                };
            })($.fn.focus),

            scrollParent: function () {
                var scrollParent;
                if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
                    scrollParent = this.parents().filter(function () {
                        return (/(relative|absolute|fixed)/).test($.css(this, "position")) && (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                    }).eq(0);
                } else {
                    scrollParent = this.parents().filter(function () {
                        return (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                    }).eq(0);
                }

                return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
            },

            uniqueId: function () {
                return this.each(function () {
                    if (!this.id) {
                        this.id = "ui-id-" + (++uuid);
                    }
                });
            },

            removeUniqueId: function () {
                return this.each(function () {
                    if (runiqueId.test(this.id)) {
                        $(this).removeAttr("id");
                    }
                });
            }
        });

        // selectors
        function focusable(element, isTabIndexNotNaN) {
            var map, mapName, img,
                nodeName = element.nodeName.toLowerCase();
            if ("area" === nodeName) {
                map = element.parentNode;
                mapName = map.name;
                if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                    return false;
                }
                img = $("img[usemap=#" + mapName + "]")[0];
                return !!img && visible(img);
            }
            return (/input|select|textarea|button|object/.test(nodeName) ?
                !element.disabled :
                "a" === nodeName ?
                    element.href || isTabIndexNotNaN :
                    isTabIndexNotNaN) &&
                // the element and all of its ancestors must be visible
                visible(element);
        }

        function visible(element) {
            return $.expr.filters.visible(element) &&
                !$(element).parents().addBack().filter(function () {
                    return $.css(this, "visibility") === "hidden";
                }).length;
        }

        $.extend($.expr[":"], {
            data: $.expr.createPseudo ?
                $.expr.createPseudo(function (dataName) {
                    return function (elem) {
                        return !!$.data(elem, dataName);
                    };
                }) :
                // support: jQuery <1.8
                function (elem, i, match) {
                    return !!$.data(elem, match[3]);
                },

            focusable: function (element) {
                return focusable(element, !isNaN($.attr(element, "tabindex")));
            },

            tabbable: function (element) {
                var tabIndex = $.attr(element, "tabindex"),
                    isTabIndexNaN = isNaN(tabIndex);
                return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
            }
        });

        // support: jQuery <1.8
        if (!$("<a>").outerWidth(1).jquery) {
            $.each(["Width", "Height"], function (i, name) {
                var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                    type = name.toLowerCase(),
                    orig = {
                        innerWidth: $.fn.innerWidth,
                        innerHeight: $.fn.innerHeight,
                        outerWidth: $.fn.outerWidth,
                        outerHeight: $.fn.outerHeight
                    };

                function reduce(elem, size, border, margin) {
                    $.each(side, function () {
                        size -= parseFloat($.css(elem, "padding" + this)) || 0;
                        if (border) {
                            size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                        }
                        if (margin) {
                            size -= parseFloat($.css(elem, "margin" + this)) || 0;
                        }
                    });
                    return size;
                }

                $.fn["inner" + name] = function (size) {
                    if (size === undefined) {
                        return orig["inner" + name].call(this);
                    }

                    return this.each(function () {
                        $(this).css(type, reduce(this, size) + "px");
                    });
                };

                $.fn["outer" + name] = function (size, margin) {
                    if (typeof size !== "number") {
                        return orig["outer" + name].call(this, size);
                    }

                    return this.each(function () {
                        $(this).css(type, reduce(this, size, true, margin) + "px");
                    });
                };
            });
        }

        // support: jQuery <1.8
        if (!$.fn.addBack) {
            $.fn.addBack = function (selector) {
                return this.add(selector == null ?
                    this.prevObject : this.prevObject.filter(selector)
                );
            };
        }

        // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
        if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
            $.fn.removeData = (function (removeData) {
                return function (key) {
                    if (arguments.length) {
                        return removeData.call(this, $.camelCase(key));
                    } else {
                        return removeData.call(this);
                    }
                };
            })($.fn.removeData);
        }





        // deprecated
        $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

        $.support.selectstart = "onselectstart" in document.createElement("div");
        $.fn.extend({
            disableSelection: function () {
                return this.bind(($.support.selectstart ? "selectstart" : "mousedown") +
                    ".ui-disableSelection", function (event) {
                        event.preventDefault();
                    });
            },

            enableSelection: function () {
                return this.unbind(".ui-disableSelection");
            },

            zIndex: function (zIndex) {
                if (zIndex !== undefined) {
                    return this.css("zIndex", zIndex);
                }

                if (this.length) {
                    var elem = $(this[0]), position, value;
                    while (elem.length && elem[0] !== document) {
                        // Ignore z-index if position is set to a value where z-index is ignored by the browser
                        // This makes behavior of this function consistent across browsers
                        // WebKit always returns auto if the element is positioned
                        position = elem.css("position");
                        if (position === "absolute" || position === "relative" || position === "fixed") {
                            // IE returns 0 when zIndex is not specified
                            // other browsers return a string
                            // we ignore the case of nested elements with an explicit value of 0
                            // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                            value = parseInt(elem.css("zIndex"), 10);
                            if (!isNaN(value) && value !== 0) {
                                return value;
                            }
                        }
                        elem = elem.parent();
                    }
                }

                return 0;
            }
        });

        // $.ui.plugin is deprecated. Use $.widget() extensions instead.
        $.ui.plugin = {
            add: function (module, option, set) {
                var i,
                    proto = $.ui[module].prototype;
                for (i in set) {
                    proto.plugins[i] = proto.plugins[i] || [];
                    proto.plugins[i].push([option, set[i]]);
                }
            },
            call: function (instance, name, args, allowDisconnected) {
                var i,
                    set = instance.plugins[name];

                if (!set) {
                    return;
                }

                if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
                    return;
                }

                for (i = 0; i < set.length; i++) {
                    if (instance.options[set[i][0]]) {
                        set[i][1].apply(instance.element, args);
                    }
                }
            }
        };

    })(jQuery);

    (function ($, window, undefined) {

        // Subtract the height of external toolbars from the page height, if the page does not have
        // internal toolbars of the same type. We take care to use the widget options if we find a
        // widget instance and the element's data-attributes otherwise.
        var compensateToolbars = function (page, desiredHeight) {
            var pageParent = page.parent(),
                toolbarsAffectingHeight = [],

                // We use this function to filter fixed toolbars with option updatePagePadding set to
                // true (which is the default) from our height subtraction, because fixed toolbars with
                // option updatePagePadding set to true compensate for their presence by adding padding
                // to the active page. We want to avoid double-counting by also subtracting their
                // height from the desired page height.
                noPadders = function () {
                    var theElement = $(this),
                        widgetOptions = $.mobile.toolbar && theElement.data("mobile-toolbar") ?
                            theElement.toolbar("option") : {
                                position: theElement.attr("data-" + $.mobile.ns + "position"),
                                updatePagePadding: (theElement.attr("data-" + $.mobile.ns +
                                    "update-page-padding") !== false)
                            };

                    return !(widgetOptions.position === "fixed" &&
                        widgetOptions.updatePagePadding === true);
                },
                externalHeaders = pageParent.children(":jqmData(role='header')").filter(noPadders),
                internalHeaders = page.children(":jqmData(role='header')"),
                externalFooters = pageParent.children(":jqmData(role='footer')").filter(noPadders),
                internalFooters = page.children(":jqmData(role='footer')");

            // If we have no internal headers, but we do have external headers, then their height
            // reduces the page height
            if (internalHeaders.length === 0 && externalHeaders.length > 0) {
                toolbarsAffectingHeight = toolbarsAffectingHeight.concat(externalHeaders.toArray());
            }

            // If we have no internal footers, but we do have external footers, then their height
            // reduces the page height
            if (internalFooters.length === 0 && externalFooters.length > 0) {
                toolbarsAffectingHeight = toolbarsAffectingHeight.concat(externalFooters.toArray());
            }

            $.each(toolbarsAffectingHeight, function (index, value) {
                desiredHeight -= $(value).outerHeight();
            });

            // Height must be at least zero
            return Math.max(0, desiredHeight);
        };

        $.extend($.mobile, {
            // define the window and the document objects
            window: $(window),
            document: $(document),

            // TODO: Remove and use $.ui.keyCode directly
            keyCode: $.ui.keyCode,

            // Place to store various widget extensions
            behaviors: {},

            // Scroll page vertically: scroll to 0 to hide iOS address bar, or pass a Y value
            silentScroll: function (ypos) {
                if ($.type(ypos) !== "number") {
                    ypos = $.mobile.defaultHomeScroll;
                }

                // prevent scrollstart and scrollstop events
                $.event.special.scrollstart.enabled = false;

                setTimeout(function () {
                    window.scrollTo(0, ypos);
                    $.mobile.document.trigger("silentscroll", { x: 0, y: ypos });
                }, 20);

                setTimeout(function () {
                    $.event.special.scrollstart.enabled = true;
                }, 150);
            },

            getClosestBaseUrl: function (ele) {
                // Find the closest page and extract out its url.
                var url = $(ele).closest(".ui-page").jqmData("url"),
                    base = $.mobile.path.documentBase.hrefNoHash;

                if (!$.mobile.dynamicBaseEnabled || !url || !$.mobile.path.isPath(url)) {
                    url = base;
                }

                return $.mobile.path.makeUrlAbsolute(url, base);
            },
            removeActiveLinkClass: function (forceRemoval) {
                if (!!$.mobile.activeClickedLink &&
                    (!$.mobile.activeClickedLink.closest("." + $.mobile.activePageClass).length ||
                        forceRemoval)) {

                    $.mobile.activeClickedLink.removeClass($.mobile.activeBtnClass);
                }
                $.mobile.activeClickedLink = null;
            },

            // DEPRECATED in 1.4
            // Find the closest parent with a theme class on it. Note that
            // we are not using $.fn.closest() on purpose here because this
            // method gets called quite a bit and we need it to be as fast
            // as possible.
            getInheritedTheme: function (el, defaultTheme) {
                var e = el[0],
                    ltr = "",
                    re = /ui-(bar|body|overlay)-([a-z])\b/,
                    c, m;
                while (e) {
                    c = e.className || "";
                    if (c && (m = re.exec(c)) && (ltr = m[2])) {
                        // We found a parent with a theme class
                        // on it so bail from this loop.
                        break;
                    }

                    e = e.parentNode;
                }
                // Return the theme letter we found, if none, return the
                // specified default.
                return ltr || defaultTheme || "a";
            },

            enhanceable: function (elements) {
                return this.haveParents(elements, "enhance");
            },

            hijackable: function (elements) {
                return this.haveParents(elements, "ajax");
            },

            haveParents: function (elements, attr) {
                if (!$.mobile.ignoreContentEnabled) {
                    return elements;
                }

                var count = elements.length,
                    $newSet = $(),
                    e, $element, excluded,
                    i, c;

                for (i = 0; i < count; i++) {
                    $element = elements.eq(i);
                    excluded = false;
                    e = elements[i];

                    while (e) {
                        c = e.getAttribute ? e.getAttribute("data-" + $.mobile.ns + attr) : "";

                        if (c === "false") {
                            excluded = true;
                            break;
                        }

                        e = e.parentNode;
                    }

                    if (!excluded) {
                        $newSet = $newSet.add($element);
                    }
                }

                return $newSet;
            },

            getScreenHeight: function () {
                // Native innerHeight returns more accurate value for this across platforms,
                // jQuery version is here as a normalized fallback for platforms like Symbian
                return window.innerHeight || $.mobile.window.height();
            },

            //simply set the active page's minimum height to screen height, depending on orientation
            resetActivePageHeight: function (height) {
                var page = $("." + $.mobile.activePageClass),
                    pageHeight = page.height(),
                    pageOuterHeight = page.outerHeight(true);

                height = compensateToolbars(page,
                    (typeof height === "number") ? height : $.mobile.getScreenHeight());

                // Remove any previous min-height setting
                page.css("min-height", "");

                // Set the minimum height only if the height as determined by CSS is insufficient
                if (page.height() < height) {
                    page.css("min-height", height - (pageOuterHeight - pageHeight));
                }
            },

            loading: function () {
                // If this is the first call to this function, instantiate a loader widget
                var loader = this.loading._widget || $($.mobile.loader.prototype.defaultHtml).loader(),

                    // Call the appropriate method on the loader
                    returnValue = loader.loader.apply(loader, arguments);

                // Make sure the loader is retained for future calls to this function.
                this.loading._widget = loader;

                return returnValue;
            }
        });

        $.addDependents = function (elem, newDependents) {
            var $elem = $(elem),
                dependents = $elem.jqmData("dependents") || $();

            $elem.jqmData("dependents", $(dependents).add(newDependents));
        };

        // plugins
        $.fn.extend({
            removeWithDependents: function () {
                $.removeWithDependents(this);
            },

            // Enhance child elements
            enhanceWithin: function () {
                var index,
                    widgetElements = {},
                    keepNative = $.mobile.page.prototype.keepNativeSelector(),
                    that = this;

                // Add no js class to elements
                if ($.mobile.nojs) {
                    $.mobile.nojs(this);
                }

                // Bind links for ajax nav
                if ($.mobile.links) {
                    $.mobile.links(this);
                }

                // Degrade inputs for styleing
                if ($.mobile.degradeInputsWithin) {
                    $.mobile.degradeInputsWithin(this);
                }

                // Run buttonmarkup
                if ($.fn.buttonMarkup) {
                    this.find($.fn.buttonMarkup.initSelector).not(keepNative)
                    .jqmEnhanceable().buttonMarkup();
                }

                // Add classes for fieldContain
                if ($.fn.fieldcontain) {
                    this.find(":jqmData(role='fieldcontain')").not(keepNative)
                    .jqmEnhanceable().fieldcontain();
                }

                // Enhance widgets
                $.each($.mobile.widgets, function (name, constructor) {

                    // If initSelector not false find elements
                    if (constructor.initSelector) {

                        // Filter elements that should not be enhanced based on parents
                        var elements = $.mobile.enhanceable(that.find(constructor.initSelector));

                        // If any matching elements remain filter ones with keepNativeSelector
                        if (elements.length > 0) {

                            // $.mobile.page.prototype.keepNativeSelector is deprecated this is just for backcompat
                            // Switch to $.mobile.keepNative in 1.5 which is just a value not a function
                            elements = elements.not(keepNative);
                        }

                        // Enhance whatever is left
                        if (elements.length > 0) {
                            widgetElements[constructor.prototype.widgetName] = elements;
                        }
                    }
                });

                for (index in widgetElements) {
                    widgetElements[index][index]();
                }

                return this;
            },

            addDependents: function (newDependents) {
                $.addDependents(this, newDependents);
            },

            // note that this helper doesn't attempt to handle the callback
            // or setting of an html element's text, its only purpose is
            // to return the html encoded version of the text in all cases. (thus the name)
            getEncodedText: function () {
                return $("<a>").text(this.text()).html();
            },

            // fluent helper function for the mobile namespaced equivalent
            jqmEnhanceable: function () {
                return $.mobile.enhanceable(this);
            },

            jqmHijackable: function () {
                return $.mobile.hijackable(this);
            }
        });

        $.removeWithDependents = function (nativeElement) {
            var element = $(nativeElement);

            (element.jqmData("dependents") || $()).remove();
            element.remove();
        };
        $.addDependents = function (nativeElement, newDependents) {
            var element = $(nativeElement),
                dependents = element.jqmData("dependents") || $();

            element.jqmData("dependents", $(dependents).add(newDependents));
        };

        $.find.matches = function (expr, set) {
            return $.find(expr, null, null, set);
        };

        $.find.matchesSelector = function (node, expr) {
            return $.find(expr, null, null, [node]).length > 0;
        };

    })(jQuery, this);

    /*!
     * jQuery UI Widget c0ab71056b936627e8a7821f03c044aec6280a40
     * http://jqueryui.com
     *
     * Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/jQuery.widget/
     */
    (function ($, undefined) {

        var uuid = 0,
            slice = Array.prototype.slice,
            _cleanData = $.cleanData;
        $.cleanData = function (elems) {
            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                try {
                    $(elem).triggerHandler("remove");
                    // http://bugs.jquery.com/ticket/8235
                } catch (e) { }
            }
            _cleanData(elems);
        };

        $.widget = function (name, base, prototype) {
            var fullName, existingConstructor, constructor, basePrototype,
                // proxiedPrototype allows the provided prototype to remain unmodified
                // so that it can be used as a mixin for multiple widgets (#8876)
                proxiedPrototype = {},
                namespace = name.split(".")[0];

            name = name.split(".")[1];
            fullName = namespace + "-" + name;

            if (!prototype) {
                prototype = base;
                base = $.Widget;
            }

            // create selector for plugin
            $.expr[":"][fullName.toLowerCase()] = function (elem) {
                return !!$.data(elem, fullName);
            };

            $[namespace] = $[namespace] || {};
            existingConstructor = $[namespace][name];
            constructor = $[namespace][name] = function (options, element) {
                // allow instantiation without "new" keyword
                if (!this._createWidget) {
                    return new constructor(options, element);
                }

                // allow instantiation without initializing for simple inheritance
                // must use "new" keyword (the code above always passes args)
                if (arguments.length) {
                    this._createWidget(options, element);
                }
            };
            // extend with the existing constructor to carry over any static properties
            $.extend(constructor, existingConstructor, {
                version: prototype.version,
                // copy the object used to create the prototype in case we need to
                // redefine the widget later
                _proto: $.extend({}, prototype),
                // track widgets that inherit from this widget in case this widget is
                // redefined after a widget inherits from it
                _childConstructors: []
            });

            basePrototype = new base();
            // we need to make the options hash a property directly on the new instance
            // otherwise we'll modify the options hash on the prototype that we're
            // inheriting from
            basePrototype.options = $.widget.extend({}, basePrototype.options);
            $.each(prototype, function (prop, value) {
                if (!$.isFunction(value)) {
                    proxiedPrototype[prop] = value;
                    return;
                }
                proxiedPrototype[prop] = (function () {
                    var _super = function () {
                        return base.prototype[prop].apply(this, arguments);
                    },
                        _superApply = function (args) {
                            return base.prototype[prop].apply(this, args);
                        };
                    return function () {
                        var __super = this._super,
                            __superApply = this._superApply,
                            returnValue;

                        this._super = _super;
                        this._superApply = _superApply;

                        returnValue = value.apply(this, arguments);

                        this._super = __super;
                        this._superApply = __superApply;

                        return returnValue;
                    };
                })();
            });
            constructor.prototype = $.widget.extend(basePrototype, {
                // TODO: remove support for widgetEventPrefix
                // always use the name + a colon as the prefix, e.g., draggable:start
                // don't prefix for widgets that aren't DOM-based
                widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
            }, proxiedPrototype, {
                constructor: constructor,
                namespace: namespace,
                widgetName: name,
                widgetFullName: fullName
            });

            // If this widget is being redefined then we need to find all widgets that
            // are inheriting from it and redefine all of them so that they inherit from
            // the new version of this widget. We're essentially trying to replace one
            // level in the prototype chain.
            if (existingConstructor) {
                $.each(existingConstructor._childConstructors, function (i, child) {
                    var childPrototype = child.prototype;

                    // redefine the child widget using the same prototype that was
                    // originally used, but inherit from the new version of the base
                    $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
                });
                // remove the list of existing child constructors from the old constructor
                // so the old child constructors can be garbage collected
                delete existingConstructor._childConstructors;
            } else {
                base._childConstructors.push(constructor);
            }

            $.widget.bridge(name, constructor);

            return constructor;
        };

        $.widget.extend = function (target) {
            var input = slice.call(arguments, 1),
                inputIndex = 0,
                inputLength = input.length,
                key,
                value;
            for (; inputIndex < inputLength; inputIndex++) {
                for (key in input[inputIndex]) {
                    value = input[inputIndex][key];
                    if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                        // Clone objects
                        if ($.isPlainObject(value)) {
                            target[key] = $.isPlainObject(target[key]) ?
                                $.widget.extend({}, target[key], value) :
                                // Don't extend strings, arrays, etc. with objects
                                $.widget.extend({}, value);
                            // Copy everything else by reference
                        } else {
                            target[key] = value;
                        }
                    }
                }
            }
            return target;
        };

        $.widget.bridge = function (name, object) {
            var fullName = object.prototype.widgetFullName || name;
            $.fn[name] = function (options) {
                var isMethodCall = typeof options === "string",
                    args = slice.call(arguments, 1),
                    returnValue = this;

                // allow multiple hashes to be passed on init
                options = !isMethodCall && args.length ?
                    $.widget.extend.apply(null, [options].concat(args)) :
                    options;

                if (isMethodCall) {
                    this.each(function () {
                        var methodValue,
                            instance = $.data(this, fullName);
                        if (options === "instance") {
                            returnValue = instance;
                            return false;
                        }
                        if (!instance) {
                            return $.error("cannot call methods on " + name + " prior to initialization; " +
                                "attempted to call method '" + options + "'");
                        }
                        if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                            return $.error("no such method '" + options + "' for " + name + " widget instance");
                        }
                        methodValue = instance[options].apply(instance, args);
                        if (methodValue !== instance && methodValue !== undefined) {
                            returnValue = methodValue && methodValue.jquery ?
                                returnValue.pushStack(methodValue.get()) :
                                methodValue;
                            return false;
                        }
                    });
                } else {
                    this.each(function () {
                        var instance = $.data(this, fullName);
                        if (instance) {
                            instance.option(options || {})._init();
                        } else {
                            $.data(this, fullName, new object(options, this));
                        }
                    });
                }

                return returnValue;
            };
        };

        $.Widget = function ( /* options, element */) { };
        $.Widget._childConstructors = [];

        $.Widget.prototype = {
            widgetName: "widget",
            widgetEventPrefix: "",
            defaultElement: "<div>",
            options: {
                disabled: false,

                // callbacks
                create: null
            },
            _createWidget: function (options, element) {
                element = $(element || this.defaultElement || this)[0];
                this.element = $(element);
                this.uuid = uuid++;
                this.eventNamespace = "." + this.widgetName + this.uuid;
                this.options = $.widget.extend({},
                    this.options,
                    this._getCreateOptions(),
                    options);

                this.bindings = $();
                this.hoverable = $();
                this.focusable = $();

                if (element !== this) {
                    $.data(element, this.widgetFullName, this);
                    this._on(true, this.element, {
                        remove: function (event) {
                            if (event.target === element) {
                                this.destroy();
                            }
                        }
                    });
                    this.document = $(element.style ?
                        // element within the document
                        element.ownerDocument :
                        // element is window or document
                        element.document || element);
                    this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
                }

                this._create();
                this._trigger("create", null, this._getCreateEventData());
                this._init();
            },
            _getCreateOptions: $.noop,
            _getCreateEventData: $.noop,
            _create: $.noop,
            _init: $.noop,

            destroy: function () {
                this._destroy();
                // we can probably remove the unbind calls in 2.0
                // all event bindings should go through this._on()
                this.element
                    .unbind(this.eventNamespace)
                    .removeData(this.widgetFullName)
                    // support: jquery <1.6.3
                    // http://bugs.jquery.com/ticket/9413
                    .removeData($.camelCase(this.widgetFullName));
                this.widget()
                    .unbind(this.eventNamespace)
                    .removeAttr("aria-disabled")
                    .removeClass(
                        this.widgetFullName + "-disabled " +
                        "ui-state-disabled");

                // clean up events and states
                this.bindings.unbind(this.eventNamespace);
                this.hoverable.removeClass("ui-state-hover");
                this.focusable.removeClass("ui-state-focus");
            },
            _destroy: $.noop,

            widget: function () {
                return this.element;
            },

            option: function (key, value) {
                var options = key,
                    parts,
                    curOption,
                    i;

                if (arguments.length === 0) {
                    // don't return a reference to the internal hash
                    return $.widget.extend({}, this.options);
                }

                if (typeof key === "string") {
                    // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                    options = {};
                    parts = key.split(".");
                    key = parts.shift();
                    if (parts.length) {
                        curOption = options[key] = $.widget.extend({}, this.options[key]);
                        for (i = 0; i < parts.length - 1; i++) {
                            curOption[parts[i]] = curOption[parts[i]] || {};
                            curOption = curOption[parts[i]];
                        }
                        key = parts.pop();
                        if (value === undefined) {
                            return curOption[key] === undefined ? null : curOption[key];
                        }
                        curOption[key] = value;
                    } else {
                        if (value === undefined) {
                            return this.options[key] === undefined ? null : this.options[key];
                        }
                        options[key] = value;
                    }
                }

                this._setOptions(options);

                return this;
            },
            _setOptions: function (options) {
                var key;

                for (key in options) {
                    this._setOption(key, options[key]);
                }

                return this;
            },
            _setOption: function (key, value) {
                this.options[key] = value;

                if (key === "disabled") {
                    this.widget()
                        .toggleClass(this.widgetFullName + "-disabled", !!value);
                    this.hoverable.removeClass("ui-state-hover");
                    this.focusable.removeClass("ui-state-focus");
                }

                return this;
            },

            enable: function () {
                return this._setOptions({ disabled: false });
            },
            disable: function () {
                return this._setOptions({ disabled: true });
            },

            _on: function (suppressDisabledCheck, element, handlers) {
                var delegateElement,
                    instance = this;

                // no suppressDisabledCheck flag, shuffle arguments
                if (typeof suppressDisabledCheck !== "boolean") {
                    handlers = element;
                    element = suppressDisabledCheck;
                    suppressDisabledCheck = false;
                }

                // no element argument, shuffle and use this.element
                if (!handlers) {
                    handlers = element;
                    element = this.element;
                    delegateElement = this.widget();
                } else {
                    // accept selectors, DOM elements
                    element = delegateElement = $(element);
                    this.bindings = this.bindings.add(element);
                }

                $.each(handlers, function (event, handler) {
                    function handlerProxy() {
                        // allow widgets to customize the disabled handling
                        // - disabled as an array instead of boolean
                        // - disabled class as method for disabling individual parts
                        if (!suppressDisabledCheck &&
                                (instance.options.disabled === true ||
                                    $(this).hasClass("ui-state-disabled"))) {
                            return;
                        }
                        return (typeof handler === "string" ? instance[handler] : handler)
                            .apply(instance, arguments);
                    }

                    // copy the guid so direct unbinding works
                    if (typeof handler !== "string") {
                        handlerProxy.guid = handler.guid =
                            handler.guid || handlerProxy.guid || $.guid++;
                    }

                    var match = event.match(/^(\w+)\s*(.*)$/),
                        eventName = match[1] + instance.eventNamespace,
                        selector = match[2];
                    if (selector) {
                        delegateElement.delegate(selector, eventName, handlerProxy);
                    } else {
                        element.bind(eventName, handlerProxy);
                    }
                });
            },

            _off: function (element, eventName) {
                eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
                element.unbind(eventName).undelegate(eventName);
            },

            _delay: function (handler, delay) {
                function handlerProxy() {
                    return (typeof handler === "string" ? instance[handler] : handler)
                        .apply(instance, arguments);
                }
                var instance = this;
                return setTimeout(handlerProxy, delay || 0);
            },

            _hoverable: function (element) {
                this.hoverable = this.hoverable.add(element);
                this._on(element, {
                    mouseenter: function (event) {
                        $(event.currentTarget).addClass("ui-state-hover");
                    },
                    mouseleave: function (event) {
                        $(event.currentTarget).removeClass("ui-state-hover");
                    }
                });
            },

            _focusable: function (element) {
                this.focusable = this.focusable.add(element);
                this._on(element, {
                    focusin: function (event) {
                        $(event.currentTarget).addClass("ui-state-focus");
                    },
                    focusout: function (event) {
                        $(event.currentTarget).removeClass("ui-state-focus");
                    }
                });
            },

            _trigger: function (type, event, data) {
                var prop, orig,
                    callback = this.options[type];

                data = data || {};
                event = $.Event(event);
                event.type = (type === this.widgetEventPrefix ?
                    type :
                    this.widgetEventPrefix + type).toLowerCase();
                // the original event may come from any element
                // so we need to reset the target on the new event
                event.target = this.element[0];

                // copy original event properties over to the new event
                orig = event.originalEvent;
                if (orig) {
                    for (prop in orig) {
                        if (!(prop in event)) {
                            event[prop] = orig[prop];
                        }
                    }
                }

                this.element.trigger(event, data);
                return !($.isFunction(callback) &&
                    callback.apply(this.element[0], [event].concat(data)) === false ||
                    event.isDefaultPrevented());
            }
        };

        $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
            $.Widget.prototype["_" + method] = function (element, options, callback) {
                if (typeof options === "string") {
                    options = { effect: options };
                }
                var hasOptions,
                    effectName = !options ?
                    method :
                        options === true || typeof options === "number" ?
                    defaultEffect :
                            options.effect || defaultEffect;
                options = options || {};
                if (typeof options === "number") {
                    options = { duration: options };
                }
                hasOptions = !$.isEmptyObject(options);
                options.complete = callback;
                if (options.delay) {
                    element.delay(options.delay);
                }
                if (hasOptions && $.effects && $.effects.effect[effectName]) {
                    element[method](options);
                } else if (effectName !== method && element[effectName]) {
                    element[effectName](options.duration, options.easing, callback);
                } else {
                    element.queue(function (next) {
                        $(this)[method]();
                        if (callback) {
                            callback.call(element[0]);
                        }
                        next();
                    });
                }
            };
        });

    })(jQuery);

    (function ($, undefined) {

        var rcapitals = /[A-Z]/g,
            replaceFunction = function (c) {
                return "-" + c.toLowerCase();
            };

        $.extend($.Widget.prototype, {
            _getCreateOptions: function () {
                var option, value,
                    elem = this.element[0],
                    options = {};

                //
                if (!$.mobile.getAttribute(elem, "defaults")) {
                    for (option in this.options) {
                        value = $.mobile.getAttribute(elem, option.replace(rcapitals, replaceFunction));

                        if (value != null) {
                            options[option] = value;
                        }
                    }
                }

                return options;
            }
        });

        //TODO: Remove in 1.5 for backcompat only
        $.mobile.widget = $.Widget;

    })(jQuery);


    (function ($) {
        var meta = $("meta[name=viewport]"),
            initialContent = meta.attr("content"),
            disabledZoom = initialContent + ",maximum-scale=1, user-scalable=no",
            enabledZoom = initialContent + ",maximum-scale=10, user-scalable=yes",
            disabledInitially = /(user-scalable[\s]*=[\s]*no)|(maximum-scale[\s]*=[\s]*1)[$,\s]/.test(initialContent);

        $.mobile.zoom = $.extend({}, {
            enabled: !disabledInitially,
            locked: false,
            disable: function (lock) {
                if (!disabledInitially && !$.mobile.zoom.locked) {
                    meta.attr("content", disabledZoom);
                    $.mobile.zoom.enabled = false;
                    $.mobile.zoom.locked = lock || false;
                }
            },
            enable: function (unlock) {
                if (!disabledInitially && (!$.mobile.zoom.locked || unlock === true)) {
                    meta.attr("content", enabledZoom);
                    $.mobile.zoom.enabled = true;
                    $.mobile.zoom.locked = false;
                }
            },
            restore: function () {
                if (!disabledInitially) {
                    meta.attr("content", initialContent);
                    $.mobile.zoom.enabled = true;
                }
            }
        });

    }(jQuery));

    (function ($, window) {

        $.mobile.iosorientationfixEnabled = true;

        // This fix addresses an iOS bug, so return early if the UA claims it's something else.
        var ua = navigator.userAgent,
            zoom,
            evt, x, y, z, aig;
        if (!(/iPhone|iPad|iPod/.test(navigator.platform) && /OS [1-5]_[0-9_]* like Mac OS X/i.test(ua) && ua.indexOf("AppleWebKit") > -1)) {
            $.mobile.iosorientationfixEnabled = false;
            return;
        }

        zoom = $.mobile.zoom;

        function checkTilt(e) {
            evt = e.originalEvent;
            aig = evt.accelerationIncludingGravity;

            x = Math.abs(aig.x);
            y = Math.abs(aig.y);
            z = Math.abs(aig.z);

            // If portrait orientation and in one of the danger zones
            if (!window.orientation && (x > 7 || ((z > 6 && y < 8 || z < 8 && y > 6) && x > 5))) {
                if (zoom.enabled) {
                    zoom.disable();
                }
            } else if (!zoom.enabled) {
                zoom.enable();
            }
        }

        $.mobile.document.on("mobileinit", function () {
            if ($.mobile.iosorientationfixEnabled) {
                $.mobile.window
                    .bind("orientationchange.iosorientationfix", zoom.enable)
                    .bind("devicemotion.iosorientationfix", checkTilt);
            }
        });

    }(jQuery, this));


    (function ($, undefined) {
        var path, $base, dialogHashKey = "&ui-state=dialog";

        $.mobile.path = path = {
            uiStateKey: "&ui-state",

            // This scary looking regular expression parses an absolute URL or its relative
            // variants (protocol, site, document, query, and hash), into the various
            // components (protocol, host, path, query, fragment, etc that make up the
            // URL as well as some other commonly used sub-parts. When used with RegExp.exec()
            // or String.match, it parses the URL into a results array that looks like this:
            //
            //     [0]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread#msg-content
            //     [1]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread
            //     [2]: http://jblas:password@mycompany.com:8080/mail/inbox
            //     [3]: http://jblas:password@mycompany.com:8080
            //     [4]: http:
            //     [5]: //
            //     [6]: jblas:password@mycompany.com:8080
            //     [7]: jblas:password
            //     [8]: jblas
            //     [9]: password
            //    [10]: mycompany.com:8080
            //    [11]: mycompany.com
            //    [12]: 8080
            //    [13]: /mail/inbox
            //    [14]: /mail/
            //    [15]: inbox
            //    [16]: ?msg=1234&type=unread
            //    [17]: #msg-content
            //
            urlParseRE: /^\s*(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/,

            // Abstraction to address xss (Issue #4787) by removing the authority in
            // browsers that auto-decode it. All references to location.href should be
            // replaced with a call to this method so that it can be dealt with properly here
            getLocation: function (url) {
                var parsedUrl = this.parseUrl(url || location.href),
					uri = url ? parsedUrl : location,

					// Make sure to parse the url or the location object for the hash because using
					// location.hash is autodecoded in firefox, the rest of the url should be from
					// the object (location unless we're testing) to avoid the inclusion of the
					// authority
					hash = parsedUrl.hash;

                // mimic the browser with an empty string when the hash is empty
                hash = hash === "#" ? "" : hash;

                return uri.protocol +
					parsedUrl.doubleSlash +
					uri.host +

					// The pathname must start with a slash if there's a protocol, because you
					// can't have a protocol followed by a relative path. Also, it's impossible to
					// calculate absolute URLs from relative ones if the absolute one doesn't have
					// a leading "/".
					((uri.protocol !== "" && uri.pathname.substring(0, 1) !== "/") ?
						"/" : "") +
					uri.pathname +
					uri.search +
					hash;
            },

            //return the original document url
            getDocumentUrl: function (asParsedObject) {
                return asParsedObject ? $.extend({}, path.documentUrl) : path.documentUrl.href;
            },

            parseLocation: function () {
                return this.parseUrl(this.getLocation());
            },

            //Parse a URL into a structure that allows easy access to
            //all of the URL components by name.
            parseUrl: function (url) {
                // If we're passed an object, we'll assume that it is
                // a parsed url object and just return it back to the caller.
                if ($.type(url) === "object") {
                    return url;
                }

                var matches = path.urlParseRE.exec(url || "") || [];

                // Create an object that allows the caller to access the sub-matches
                // by name. Note that IE returns an empty string instead of undefined,
                // like all other browsers do, so we normalize everything so its consistent
                // no matter what browser we're running on.
                return {
                    href: matches[0] || "",
                    hrefNoHash: matches[1] || "",
                    hrefNoSearch: matches[2] || "",
                    domain: matches[3] || "",
                    protocol: matches[4] || "",
                    doubleSlash: matches[5] || "",
                    authority: matches[6] || "",
                    username: matches[8] || "",
                    password: matches[9] || "",
                    host: matches[10] || "",
                    hostname: matches[11] || "",
                    port: matches[12] || "",
                    pathname: matches[13] || "",
                    directory: matches[14] || "",
                    filename: matches[15] || "",
                    search: matches[16] || "",
                    hash: matches[17] || ""
                };
            },

            //Turn relPath into an asbolute path. absPath is
            //an optional absolute path which describes what
            //relPath is relative to.
            makePathAbsolute: function (relPath, absPath) {
                var absStack,
					relStack,
					i, d;

                if (relPath && relPath.charAt(0) === "/") {
                    return relPath;
                }

                relPath = relPath || "";
                absPath = absPath ? absPath.replace(/^\/|(\/[^\/]*|[^\/]+)$/g, "") : "";

                absStack = absPath ? absPath.split("/") : [];
                relStack = relPath.split("/");

                for (i = 0; i < relStack.length; i++) {
                    d = relStack[i];
                    switch (d) {
                        case ".":
                            break;
                        case "..":
                            if (absStack.length) {
                                absStack.pop();
                            }
                            break;
                        default:
                            absStack.push(d);
                            break;
                    }
                }
                return "/" + absStack.join("/");
            },

            //Returns true if both urls have the same domain.
            isSameDomain: function (absUrl1, absUrl2) {
                return path.parseUrl(absUrl1).domain.toLowerCase() ===
					path.parseUrl(absUrl2).domain.toLowerCase();
            },

            //Returns true for any relative variant.
            isRelativeUrl: function (url) {
                // All relative Url variants have one thing in common, no protocol.
                return path.parseUrl(url).protocol === "";
            },

            //Returns true for an absolute url.
            isAbsoluteUrl: function (url) {
                return path.parseUrl(url).protocol !== "";
            },

            //Turn the specified realtive URL into an absolute one. This function
            //can handle all relative variants (protocol, site, document, query, fragment).
            makeUrlAbsolute: function (relUrl, absUrl) {
                if (!path.isRelativeUrl(relUrl)) {
                    return relUrl;
                }

                if (absUrl === undefined) {
                    absUrl = this.documentBase;
                }

                var relObj = path.parseUrl(relUrl),
					absObj = path.parseUrl(absUrl),
					protocol = relObj.protocol || absObj.protocol,
					doubleSlash = relObj.protocol ? relObj.doubleSlash : (relObj.doubleSlash || absObj.doubleSlash),
					authority = relObj.authority || absObj.authority,
					hasPath = relObj.pathname !== "",
					pathname = path.makePathAbsolute(relObj.pathname || absObj.filename, absObj.pathname),
					search = relObj.search || (!hasPath && absObj.search) || "",
					hash = relObj.hash;

                return protocol + doubleSlash + authority + pathname + search + hash;
            },

            //Add search (aka query) params to the specified url.
            addSearchParams: function (url, params) {
                var u = path.parseUrl(url),
					p = (typeof params === "object") ? $.param(params) : params,
					s = u.search || "?";
                return u.hrefNoSearch + s + (s.charAt(s.length - 1) !== "?" ? "&" : "") + p + (u.hash || "");
            },

            convertUrlToDataUrl: function (absUrl) {
                var result = absUrl,
					u = path.parseUrl(absUrl);

                if (path.isEmbeddedPage(u)) {
                    // For embedded pages, remove the dialog hash key as in getFilePath(),
                    // and remove otherwise the Data Url won't match the id of the embedded Page.
                    result = u.hash
						.split(dialogHashKey)[0]
						.replace(/^#/, "")
						.replace(/\?.*$/, "");
                } else if (path.isSameDomain(u, this.documentBase)) {
                    result = u.hrefNoHash.replace(this.documentBase.domain, "").split(dialogHashKey)[0];
                }

                return window.decodeURIComponent(result);
            },

            //get path from current hash, or from a file path
            get: function (newPath) {
                if (newPath === undefined) {
                    newPath = path.parseLocation().hash;
                }
                return path.stripHash(newPath).replace(/[^\/]*\.[^\/*]+$/, "");
            },

            //set location hash to path
            set: function (path) {
                location.hash = path;
            },

            //test if a given url (string) is a path
            //NOTE might be exceptionally naive
            isPath: function (url) {
                return (/\//).test(url);
            },

            //return a url path with the window's location protocol/hostname/pathname removed
            clean: function (url) {
                return url.replace(this.documentBase.domain, "");
            },

            //just return the url without an initial #
            stripHash: function (url) {
                return url.replace(/^#/, "");
            },

            stripQueryParams: function (url) {
                return url.replace(/\?.*$/, "");
            },

            //remove the preceding hash, any query params, and dialog notations
            cleanHash: function (hash) {
                return path.stripHash(hash.replace(/\?.*$/, "").replace(dialogHashKey, ""));
            },

            isHashValid: function (hash) {
                return (/^#[^#]+$/).test(hash);
            },

            //check whether a url is referencing the same domain, or an external domain or different protocol
            //could be mailto, etc
            isExternal: function (url) {
                var u = path.parseUrl(url);

                return !!(u.protocol &&
					(u.domain.toLowerCase() !== this.documentUrl.domain.toLowerCase()));
            },

            hasProtocol: function (url) {
                return (/^(:?\w+:)/).test(url);
            },

            isEmbeddedPage: function (url) {
                var u = path.parseUrl(url);

                //if the path is absolute, then we need to compare the url against
                //both the this.documentUrl and the documentBase. The main reason for this
                //is that links embedded within external documents will refer to the
                //application document, whereas links embedded within the application
                //document will be resolved against the document base.
                if (u.protocol !== "") {
                    return (!this.isPath(u.hash) && u.hash && (u.hrefNoHash === this.documentUrl.hrefNoHash || (this.documentBaseDiffers && u.hrefNoHash === this.documentBase.hrefNoHash)));
                }
                return (/^#/).test(u.href);
            },

            squash: function (url, resolutionUrl) {
                var href, cleanedUrl, search, stateIndex, docUrl,
					isPath = this.isPath(url),
					uri = this.parseUrl(url),
					preservedHash = uri.hash,
					uiState = "";

                // produce a url against which we can resolve the provided path
                if (!resolutionUrl) {
                    if (isPath) {
                        resolutionUrl = path.getLocation();
                    } else {
                        docUrl = path.getDocumentUrl(true);
                        if (path.isPath(docUrl.hash)) {
                            resolutionUrl = path.squash(docUrl.href);
                        } else {
                            resolutionUrl = docUrl.href;
                        }
                    }
                }

                // If the url is anything but a simple string, remove any preceding hash
                // eg #foo/bar -> foo/bar
                //    #foo -> #foo
                cleanedUrl = isPath ? path.stripHash(url) : url;

                // If the url is a full url with a hash check if the parsed hash is a path
                // if it is, strip the #, and use it otherwise continue without change
                cleanedUrl = path.isPath(uri.hash) ? path.stripHash(uri.hash) : cleanedUrl;

                // Split the UI State keys off the href
                stateIndex = cleanedUrl.indexOf(this.uiStateKey);

                // store the ui state keys for use
                if (stateIndex > -1) {
                    uiState = cleanedUrl.slice(stateIndex);
                    cleanedUrl = cleanedUrl.slice(0, stateIndex);
                }

                // make the cleanedUrl absolute relative to the resolution url
                href = path.makeUrlAbsolute(cleanedUrl, resolutionUrl);

                // grab the search from the resolved url since parsing from
                // the passed url may not yield the correct result
                search = this.parseUrl(href).search;

                // TODO all this crap is terrible, clean it up
                if (isPath) {
                    // reject the hash if it's a path or it's just a dialog key
                    if (path.isPath(preservedHash) || preservedHash.replace("#", "").indexOf(this.uiStateKey) === 0) {
                        preservedHash = "";
                    }

                    // Append the UI State keys where it exists and it's been removed
                    // from the url
                    if (uiState && preservedHash.indexOf(this.uiStateKey) === -1) {
                        preservedHash += uiState;
                    }

                    // make sure that pound is on the front of the hash
                    if (preservedHash.indexOf("#") === -1 && preservedHash !== "") {
                        preservedHash = "#" + preservedHash;
                    }

                    // reconstruct each of the pieces with the new search string and hash
                    href = path.parseUrl(href);
                    href = href.protocol + href.doubleSlash + href.host + href.pathname + search +
						preservedHash;
                } else {
                    href += href.indexOf("#") > -1 ? uiState : "#" + uiState;
                }

                return href;
            },

            isPreservableHash: function (hash) {
                return hash.replace("#", "").indexOf(this.uiStateKey) === 0;
            },

            // Escape weird characters in the hash if it is to be used as a selector
            hashToSelector: function (hash) {
                var hasHash = (hash.substring(0, 1) === "#");
                if (hasHash) {
                    hash = hash.substring(1);
                }
                return (hasHash ? "#" : "") + hash.replace(/([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g, "\\$1");
            },

            // return the substring of a filepath before the dialogHashKey, for making a server
            // request
            getFilePath: function (path) {
                return path && path.split(dialogHashKey)[0];
            },

            // check if the specified url refers to the first page in the main
            // application document.
            isFirstPageUrl: function (url) {
                // We only deal with absolute paths.
                var u = path.parseUrl(path.makeUrlAbsolute(url, this.documentBase)),

					// Does the url have the same path as the document?
					samePath = u.hrefNoHash === this.documentUrl.hrefNoHash ||
						(this.documentBaseDiffers &&
							u.hrefNoHash === this.documentBase.hrefNoHash),

					// Get the first page element.
					fp = $.mobile.firstPage,

					// Get the id of the first page element if it has one.
					fpId = fp && fp[0] ? fp[0].id : undefined;

                // The url refers to the first page if the path matches the document and
                // it either has no hash value, or the hash is exactly equal to the id
                // of the first page element.
                return samePath &&
					(!u.hash ||
						u.hash === "#" ||
						(fpId && u.hash.replace(/^#/, "") === fpId));
            },

            // Some embedded browsers, like the web view in Phone Gap, allow
            // cross-domain XHR requests if the document doing the request was loaded
            // via the file:// protocol. This is usually to allow the application to
            // "phone home" and fetch app specific data. We normally let the browser
            // handle external/cross-domain urls, but if the allowCrossDomainPages
            // option is true, we will allow cross-domain http/https requests to go
            // through our page loading logic.
            isPermittedCrossDomainRequest: function (docUrl, reqUrl) {
                return $.mobile.allowCrossDomainPages &&
					(docUrl.protocol === "file:" || docUrl.protocol === "content:") &&
					reqUrl.search(/^https?:/) !== -1;
            }
        };

        path.documentUrl = path.parseLocation();

        $base = $("head").find("base");

        path.documentBase = $base.length ?
			path.parseUrl(path.makeUrlAbsolute($base.attr("href"), path.documentUrl.href)) :
			path.documentUrl;

        path.documentBaseDiffers = (path.documentUrl.hrefNoHash !== path.documentBase.hrefNoHash);

        //return the original document base url
        path.getDocumentBase = function (asParsedObject) {
            return asParsedObject ? $.extend({}, path.documentBase) : path.documentBase.href;
        };

        // DEPRECATED as of 1.4.0 - remove in 1.5.0
        $.extend($.mobile, {

            //return the original document url
            getDocumentUrl: path.getDocumentUrl,

            //return the original document base url
            getDocumentBase: path.getDocumentBase
        });
    })(jQuery);



    (function ($, undefined) {

        // existing base tag?
        var baseElement = $("head").children("base"),

        // base element management, defined depending on dynamic base tag support
        // TODO move to external widget
        base = {

            // define base element, for use in routing asset urls that are referenced
            // in Ajax-requested markup
            element: (baseElement.length ? baseElement :
                $("<base>", { href: $.mobile.path.documentBase.hrefNoHash }).prependTo($("head"))),

            linkSelector: "[src], link[href], a[rel='external'], :jqmData(ajax='false'), a[target]",

            // set the generated BASE element's href to a new page's base path
            set: function (href) {

                // we should do nothing if the user wants to manage their url base
                // manually
                if (!$.mobile.dynamicBaseEnabled) {
                    return;
                }

                // we should use the base tag if we can manipulate it dynamically
                if ($.support.dynamicBaseTag) {
                    base.element.attr("href",
                        $.mobile.path.makeUrlAbsolute(href, $.mobile.path.documentBase));
                }
            },

            rewrite: function (href, page) {
                var newPath = $.mobile.path.get(href);

                page.find(base.linkSelector).each(function (i, link) {
                    var thisAttr = $(link).is("[href]") ? "href" :
                        $(link).is("[src]") ? "src" : "action",
                    theLocation = $.mobile.path.parseLocation(),
                    thisUrl = $(link).attr(thisAttr);

                    // XXX_jblas: We need to fix this so that it removes the document
                    //            base URL, and then prepends with the new page URL.
                    // if full path exists and is same, chop it - helps IE out
                    thisUrl = thisUrl.replace(theLocation.protocol + theLocation.doubleSlash +
                        theLocation.host + theLocation.pathname, "");

                    if (!/^(\w+:|#|\/)/.test(thisUrl)) {
                        $(link).attr(thisAttr, newPath + thisUrl);
                    }
                });
            },

            // set the generated BASE element's href to a new page's base path
            reset: function (/* href */) {
                base.element.attr("href", $.mobile.path.documentBase.hrefNoSearch);
            }
        };

        $.mobile.base = base;

    })(jQuery);



    (function ($, undefined) {
        $.mobile.History = function (stack, index) {
            this.stack = stack || [];
            this.activeIndex = index || 0;
        };

        $.extend($.mobile.History.prototype, {
            getActive: function () {
                return this.stack[this.activeIndex];
            },

            getLast: function () {
                return this.stack[this.previousIndex];
            },

            getNext: function () {
                return this.stack[this.activeIndex + 1];
            },

            getPrev: function () {
                return this.stack[this.activeIndex - 1];
            },

            // addNew is used whenever a new page is added
            add: function (url, data) {
                data = data || {};

                //if there's forward history, wipe it
                if (this.getNext()) {
                    this.clearForward();
                }

                // if the hash is included in the data make sure the shape
                // is consistent for comparison
                if (data.hash && data.hash.indexOf("#") === -1) {
                    data.hash = "#" + data.hash;
                }

                data.url = url;
                this.stack.push(data);
                this.activeIndex = this.stack.length - 1;
            },

            //wipe urls ahead of active index
            clearForward: function () {
                this.stack = this.stack.slice(0, this.activeIndex + 1);
            },

            find: function (url, stack, earlyReturn) {
                stack = stack || this.stack;

                var entry, i, length = stack.length, index;

                for (i = 0; i < length; i++) {
                    entry = stack[i];

                    if (decodeURIComponent(url) === decodeURIComponent(entry.url) ||
                        decodeURIComponent(url) === decodeURIComponent(entry.hash)) {
                        index = i;

                        if (earlyReturn) {
                            return index;
                        }
                    }
                }

                return index;
            },

            closest: function (url) {
                var closest, a = this.activeIndex;

                // First, take the slice of the history stack before the current index and search
                // for a url match. If one is found, we'll avoid avoid looking through forward history
                // NOTE the preference for backward history movement is driven by the fact that
                //      most mobile browsers only have a dedicated back button, and users rarely use
                //      the forward button in desktop browser anyhow
                closest = this.find(url, this.stack.slice(0, a));

                // If nothing was found in backward history check forward. The `true`
                // value passed as the third parameter causes the find method to break
                // on the first match in the forward history slice. The starting index
                // of the slice must then be added to the result to get the element index
                // in the original history stack :( :(
                //
                // TODO this is hyper confusing and should be cleaned up (ugh so bad)
                if (closest === undefined) {
                    closest = this.find(url, this.stack.slice(a), true);
                    closest = closest === undefined ? closest : closest + a;
                }

                return closest;
            },

            direct: function (opts) {
                var newActiveIndex = this.closest(opts.url), a = this.activeIndex;

                // save new page index, null check to prevent falsey 0 result
                // record the previous index for reference
                if (newActiveIndex !== undefined) {
                    this.activeIndex = newActiveIndex;
                    this.previousIndex = a;
                }

                // invoke callbacks where appropriate
                //
                // TODO this is also convoluted and confusing
                if (newActiveIndex < a) {
                    (opts.present || opts.back || $.noop)(this.getActive(), "back");
                } else if (newActiveIndex > a) {
                    (opts.present || opts.forward || $.noop)(this.getActive(), "forward");
                } else if (newActiveIndex === undefined && opts.missing) {
                    opts.missing(this.getActive());
                }
            }
        });
    })(jQuery);



    (function ($) {
        // TODO move loader class down into the widget settings
        var loaderClass = "ui-loader", $html = $("html");

        $.widget("mobile.loader", {
            // NOTE if the global config settings are defined they will override these
            //      options
            options: {
                // the theme for the loading message
                theme: "a",

                // whether the text in the loading message is shown
                textVisible: false,

                // custom html for the inner content of the loading message
                html: "",

                // the text to be displayed when the popup is shown
                text: "loading"
            },

            defaultHtml: "<div class='" + loaderClass + "'>" +
                "<span class='ui-icon-loading'></span>" +
                "<h1></h1>" +
                "</div>",

            // For non-fixed supportin browsers. Position at y center (if scrollTop supported), above the activeBtn (if defined), or just 100px from top
            fakeFixLoader: function () {
                var activeBtn = $("." + $.mobile.activeBtnClass).first();

                this.element
                    .css({
                        top: $.support.scrollTop && this.window.scrollTop() + this.window.height() / 2 ||
                            activeBtn.length && activeBtn.offset().top || 100
                    });
            },

            // check position of loader to see if it appears to be "fixed" to center
            // if not, use abs positioning
            checkLoaderPosition: function () {
                var offset = this.element.offset(),
                    scrollTop = this.window.scrollTop(),
                    screenHeight = $.mobile.getScreenHeight();

                if (offset.top < scrollTop || (offset.top - scrollTop) > screenHeight) {
                    this.element.addClass("ui-loader-fakefix");
                    this.fakeFixLoader();
                    this.window
                        .unbind("scroll", this.checkLoaderPosition)
                        .bind("scroll", $.proxy(this.fakeFixLoader, this));
                }
            },

            resetHtml: function () {
                this.element.html($(this.defaultHtml).html());
            },

            // Turn on/off page loading message. Theme doubles as an object argument
            // with the following shape: { theme: '', text: '', html: '', textVisible: '' }
            // NOTE that the $.mobile.loading* settings and params past the first are deprecated
            // TODO sweet jesus we need to break some of this out
            show: function (theme, msgText, textonly) {
                var textVisible, message, loadSettings;

                this.resetHtml();

                // use the prototype options so that people can set them globally at
                // mobile init. Consistency, it's what's for dinner
                if ($.type(theme) === "object") {
                    loadSettings = $.extend({}, this.options, theme);

                    theme = loadSettings.theme;
                } else {
                    loadSettings = this.options;

                    // here we prefer the theme value passed as a string argument, then
                    // we prefer the global option because we can't use undefined default
                    // prototype options, then the prototype option
                    theme = theme || loadSettings.theme;
                }

                // set the message text, prefer the param, then the settings object
                // then loading message
                message = msgText || (loadSettings.text === false ? "" : loadSettings.text);

                // prepare the dom
                $html.addClass("ui-loading");

                textVisible = loadSettings.textVisible;

                // add the proper css given the options (theme, text, etc)
                // Force text visibility if the second argument was supplied, or
                // if the text was explicitly set in the object args
                this.element.attr("class", loaderClass +
                    " ui-corner-all ui-body-" + theme +
                    " ui-loader-" + (textVisible || msgText || theme.text ? "verbose" : "default") +
                    (loadSettings.textonly || textonly ? " ui-loader-textonly" : ""));

                // TODO verify that jquery.fn.html is ok to use in both cases here
                //      this might be overly defensive in preventing unknowing xss
                // if the html attribute is defined on the loading settings, use that
                // otherwise use the fallbacks from above
                if (loadSettings.html) {
                    this.element.html(loadSettings.html);
                } else {
                    this.element.find("h1").text(message);
                }

                // If the pagecontainer widget has been defined we may use the :mobile-pagecontainer
                // and attach to the element on which the pagecontainer widget has been defined. If not,
                // we attach to the body.
                this.element.appendTo($.mobile.pagecontainer ?
                    $(":mobile-pagecontainer") : $("body"));

                // check that the loader is visible
                this.checkLoaderPosition();

                // on scroll check the loader position
                this.window.bind("scroll", $.proxy(this.checkLoaderPosition, this));
            },

            hide: function () {
                $html.removeClass("ui-loading");

                if (this.options.text) {
                    this.element.removeClass("ui-loader-fakefix");
                }

                this.window.unbind("scroll", this.fakeFixLoader);
                this.window.unbind("scroll", this.checkLoaderPosition);
            }
        });

    })(jQuery, this);


    (function ($, undefined) {
        $.mobile.widgets = {};

        var originalWidget = $.widget,

            // Record the original, non-mobileinit-modified version of $.mobile.keepNative
            // so we can later determine whether someone has modified $.mobile.keepNative
            keepNativeFactoryDefault = $.mobile.keepNative;

        $.widget = (function (orig) {
            return function () {
                var constructor = orig.apply(this, arguments),
                    name = constructor.prototype.widgetName;

                constructor.initSelector = ((constructor.prototype.initSelector !== undefined) ?
                    constructor.prototype.initSelector : ":jqmData(role='" + name + "')");

                $.mobile.widgets[name] = constructor;

                return constructor;
            };
        })($.widget);

        // Make sure $.widget still has bridge and extend methods
        $.extend($.widget, originalWidget);

        // For backcompat remove in 1.5
        $.mobile.document.on("create", function (event) {
            $(event.target).enhanceWithin();
        });

        $.widget("mobile.page", {
            options: {
                theme: "a",
                domCache: false,

                // Deprecated in 1.4 remove in 1.5
                keepNativeDefault: $.mobile.keepNative,

                // Deprecated in 1.4 remove in 1.5
                contentTheme: null,
                enhanced: false
            },

            // DEPRECATED for > 1.4
            // TODO remove at 1.5
            _createWidget: function () {
                $.Widget.prototype._createWidget.apply(this, arguments);
                this._trigger("init");
            },

            _create: function () {
                // If false is returned by the callbacks do not create the page
                if (this._trigger("beforecreate") === false) {
                    return false;
                }

                if (!this.options.enhanced) {
                    this._enhance();
                }

                this._on(this.element, {
                    pagebeforehide: "removeContainerBackground",
                    pagebeforeshow: "_handlePageBeforeShow"
                });

                this.element.enhanceWithin();
                // Dialog widget is deprecated in 1.4 remove this in 1.5
                if ($.mobile.getAttribute(this.element[0], "role") === "dialog1" && $.mobile.dialog1) {
                    this.element.dialog();
                }
            },

            _enhance: function () {
                var attrPrefix = "data-" + $.mobile.ns,
                    self = this;

                if (this.options.role) {
                    this.element.attr("data-" + $.mobile.ns + "role", this.options.role);
                }

                this.element
                    .attr("tabindex", "0")
                    .addClass("ui-page ui-page-theme-" + this.options.theme);

                // Manipulation of content os Deprecated as of 1.4 remove in 1.5
                this.element.find("[" + attrPrefix + "role='content']").each(function () {
                    var $this = $(this),
                        theme = this.getAttribute(attrPrefix + "theme") || undefined;
                    self.options.contentTheme = theme || self.options.contentTheme || (self.options.dialog && self.options.theme) || (self.element.jqmData("role") === "dialog" && self.options.theme);
                    $this.addClass("ui-content");
                    if (self.options.contentTheme) {
                        $this.addClass("ui-body-" + (self.options.contentTheme));
                    }
                    // Add ARIA role
                    $this.attr("role", "main").addClass("ui-content");
                });
            },

            bindRemove: function (callback) {
                var page = this.element;

                // when dom caching is not enabled or the page is embedded bind to remove the page on hide
                if (!page.data("mobile-page").options.domCache &&
                    page.is(":jqmData(external-page='true')")) {

                    // TODO use _on - that is, sort out why it doesn't work in this case
                    page.bind("pagehide.remove", callback || function (e, data) {

                        //check if this is a same page transition and if so don't remove the page
                        if (!data.samePage) {
                            var $this = $(this),
                                prEvent = new $.Event("pageremove");

                            $this.trigger(prEvent);

                            if (!prEvent.isDefaultPrevented()) {
                                $this.removeWithDependents();
                            }
                        }
                    });
                }
            },

            _setOptions: function (o) {
                if (o.theme !== undefined) {
                    this.element.removeClass("ui-page-theme-" + this.options.theme).addClass("ui-page-theme-" + o.theme);
                }

                if (o.contentTheme !== undefined) {
                    this.element.find("[data-" + $.mobile.ns + "='content']").removeClass("ui-body-" + this.options.contentTheme)
                        .addClass("ui-body-" + o.contentTheme);
                }
            },

            _handlePageBeforeShow: function (/* e */) {
                this.setContainerBackground();
            },
            // Deprecated in 1.4 remove in 1.5
            removeContainerBackground: function () {
                this.element.closest(":mobile-pagecontainer").pagecontainer({ "theme": "none" });
            },
            // Deprecated in 1.4 remove in 1.5
            // set the page container background to the page theme
            setContainerBackground: function (theme) {
                this.element.parent().pagecontainer({ "theme": theme || this.options.theme });
            },
            // Deprecated in 1.4 remove in 1.5
            keepNativeSelector: function () {
                var options = this.options,
                    keepNative = $.trim(options.keepNative || ""),
                    globalValue = $.trim($.mobile.keepNative),
                    optionValue = $.trim(options.keepNativeDefault),

                    // Check if $.mobile.keepNative has changed from the factory default
                    newDefault = (keepNativeFactoryDefault === globalValue ?
                        "" : globalValue),

                    // If $.mobile.keepNative has not changed, use options.keepNativeDefault
                    oldDefault = (newDefault === "" ? optionValue : "");

                // Concatenate keepNative selectors from all sources where the value has
                // changed or, if nothing has changed, return the default
                return ((keepNative ? [keepNative] : [])
                    .concat(newDefault ? [newDefault] : [])
                    .concat(oldDefault ? [oldDefault] : [])
                    .join(", "));
            }
        });
    })(jQuery);


}));

// Limit scope pollution from any deprecated API
(function () {

    var matched, browser;

    // Use of jQuery.browser is frowned upon.
    // More details: http://api.jquery.com/jQuery.browser
    // jQuery.uaMatch maintained for back-compat
    jQuery.uaMatch = function (ua) {
        ua = ua.toLowerCase();

        var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
            /(webkit)[ \/]([\w.]+)/.exec(ua) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
            /(msie) ([\w.]+)/.exec(ua) ||
            ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
            [];

        return {
            browser: match[1] || "",
            version: match[2] || "0"
        };
    };

    matched = jQuery.uaMatch(navigator.userAgent);
    browser = {};

    if (matched.browser) {
        browser[matched.browser] = true;
        browser.version = matched.version;
    }

    // Chrome is Webkit, but Webkit is also Safari.
    if (browser.chrome) {
        browser.webkit = true;
    } else if (browser.webkit) {
        browser.safari = true;
    }

    jQuery.browser = browser;

    jQuery.sub = function () {
        function jQuerySub(selector, context) {
            return new jQuerySub.fn.init(selector, context);
        }
        jQuery.extend(true, jQuerySub, this);
        jQuerySub.superclass = this;
        jQuerySub.fn = jQuerySub.prototype = this();
        jQuerySub.fn.constructor = jQuerySub;
        jQuerySub.sub = this.sub;
        jQuerySub.fn.init = function init(selector, context) {
            if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                context = jQuerySub(context);
            }

            return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
        };
        jQuerySub.fn.init.prototype = jQuerySub.fn;
        var rootjQuerySub = jQuerySub(document);
        return jQuerySub;
    };

})();
jQuery.cookie=function(n,t,i){var f,r,e,o,u,s;if(typeof t!="undefined"){i=i||{};t===null&&(t="",i.expires=-1);f="";i.expires&&(typeof i.expires=="number"||i.expires.toUTCString)&&(typeof i.expires=="number"?(r=new Date,r.setTime(r.getTime()+i.expires*864e5)):r=i.expires,f="; expires="+r.toUTCString());var h=i.path?"; path="+i.path:"",c=i.domain?"; domain="+i.domain:"",l=i.secure?"; secure":"";document.cookie=[n,"=",encodeURIComponent(t),f,h,c,l].join("")}else{if(e=null,document.cookie&&document.cookie!="")for(o=document.cookie.split(";"),u=0;u<o.length;u++)if(s=jQuery.trim(o[u]),s.substring(0,n.length+1)==n+"="){e=decodeURIComponent(s.substring(n.length+1));break}return e}};


/*!
 * jQuery Templates Plugin 1.0.0pre
 * http://github.com/jquery/jquery-tmpl
 * Requires jQuery 1.4.2
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */
(function( jQuery, undefined ){
	var oldManip = jQuery.fn.domManip, tmplItmAtt = "_tmplitem", htmlExpr = /^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,
		newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];

	function newTmplItem( options, parentItem, fn, data ) {
		// Returns a template item data structure for a new rendered instance of a template (a 'template item').
		// The content field is a hierarchical array of strings and nested items (to be
		// removed and replaced by nodes field of dom elements, once inserted in DOM).
		var newItem = {
			data: data || (data === 0 || data === false) ? data : (parentItem ? parentItem.data : {}),
			_wrap: parentItem ? parentItem._wrap : null,
			tmpl: null,
			parent: parentItem || null,
			nodes: [],
			calls: tiCalls,
			nest: tiNest,
			wrap: tiWrap,
			html: tiHtml,
			update: tiUpdate
		};
		if ( options ) {
			jQuery.extend( newItem, options, { nodes: [], parent: parentItem });
		}
		if ( fn ) {
			// Build the hierarchical content to be used during insertion into DOM
			newItem.tmpl = fn;
			newItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );
			newItem.key = ++itemKey;
			// Keep track of new template item, until it is stored as jQuery Data on DOM element
			(stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;
		}
		return newItem;
	}

	// Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).
	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,
				parent = this.length === 1 && this[0].parentNode;

			appendToTmplItems = newTmplItems || {};
			if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
				insert[ original ]( this[0] );
				ret = this;
			} else {
				for ( i = 0, l = insert.length; i < l; i++ ) {
					cloneIndex = i;
					elems = (i > 0 ? this.clone(true) : this).get();
					jQuery( insert[i] )[ original ]( elems );
					ret = ret.concat( elems );
				}
				cloneIndex = 0;
				ret = this.pushStack( ret, name, insert.selector );
			}
			tmplItems = appendToTmplItems;
			appendToTmplItems = null;
			jQuery.tmpl.complete(tmplItems);
			
			return ret;
		};
	});

	jQuery.fn.extend({
		// Use first wrapped element as template markup.
		// Return wrapped set of template items, obtained by rendering template against data.
		tmpl: function( data, options, parentItem ) {
			return jQuery.tmpl( this[0], data, options, parentItem );
		},

		// Find which rendered template item the first wrapped DOM element belongs to
		tmplItem: function() {
			return jQuery.tmplItem( this[0] );
		},

		// Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.
		template: function( name ) {
			return jQuery.template( name, this[0] );
		},

		domManip: function( args, table, callback, options ) {
			if ( args[0] && jQuery.isArray( args[0] )) {
				var dmArgs = jQuery.makeArray( arguments ), elems = args[0], elemsLength = elems.length, i = 0, tmplItem;
				while ( i < elemsLength && !(tmplItem = jQuery.data( elems[i++], "tmplItem" ))) {}
				if ( tmplItem && cloneIndex ) {
					dmArgs[2] = function( fragClone ) {
						// Handler called by oldManip when rendered template has been inserted into DOM.
						jQuery.tmpl.afterManip( this, fragClone, callback );
					};
				}
				oldManip.apply( this, dmArgs );
			} else {
				oldManip.apply( this, arguments );
			}
			cloneIndex = 0;
			if ( !appendToTmplItems ) {
				jQuery.tmpl.complete( newTmplItems );
			}
			return this;
		}
	});

	jQuery.extend({
		// Return wrapped set of template items, obtained by rendering template against data.
	    tmpl: function (tmpl, data, options, parentItem) {
			var ret, topLevel = !parentItem;
			if ( topLevel ) {
				// This is a top-level tmpl call (not from a nested template using {{tmpl}})
				parentItem = topTmplItem;
				tmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );
				wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level
			} else if ( !tmpl ) {
				// The template item is already associated with DOM - this is a refresh.
				// Re-evaluate rendered template for the parentItem
				tmpl = parentItem.tmpl;
				newTmplItems[parentItem.key] = parentItem;
				parentItem.nodes = [];
				if ( parentItem.wrapped ) {
					updateWrapped( parentItem, parentItem.wrapped );
				}
				// Rebuild, without creating a new template item
				return jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));
			}
			if ( !tmpl ) {
				return []; // Could throw...
			}
			if ( typeof data === "function" ) {
				data = data.call( parentItem || {} );
			}
			if ( options && options.wrapped ) {
				updateWrapped( options, options.wrapped );
			}
			ret = jQuery.isArray( data ) ?
				jQuery.map( data, function( dataItem ) {
					return dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;
				}) :
				[newTmplItem(options, parentItem, tmpl, data)];
			var html = jQuery(build(parentItem, null, ret));
			if (typeof $.fn.bindResources === "function") {
			    html = html.bindResources();
			}
			return topLevel ? html : ret;
		},

		// Return rendered template item for an element.
		tmplItem: function( elem ) {
			var tmplItem;
			if ( elem instanceof jQuery ) {
				elem = elem[0];
			}
			while ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, "tmplItem" )) && (elem = elem.parentNode) ) {}
			return tmplItem || topTmplItem;
		},

		// Set:
		// Use $.template( name, tmpl ) to cache a named template,
		// where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.
		// Use $( "selector" ).template( name ) to provide access by name to a script block template declaration.

		// Get:
		// Use $.template( name ) to access a cached template.
		// Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )
		// will return the compiled template, without adding a name reference.
		// If templateString includes at least one HTML tag, $.template( templateString ) is equivalent
		// to $.template( null, templateString )
		template: function( name, tmpl ) {
			if (tmpl) {
				// Compile template and associate with name
				if ( typeof tmpl === "string" ) {
					// This is an HTML string being passed directly in.
					tmpl = buildTmplFn( tmpl );
				} else if ( tmpl instanceof jQuery ) {
					tmpl = tmpl[0] || {};
				}
				if ( tmpl.nodeType ) {
					// If this is a template block, use cached copy, or generate tmpl function and cache.
					tmpl = jQuery.data( tmpl, "tmpl" ) || jQuery.data( tmpl, "tmpl", buildTmplFn( tmpl.innerHTML ));
					// Issue: In IE, if the container element is not a script block, the innerHTML will remove quotes from attribute values whenever the value does not include white space.
					// This means that foo="${x}" will not work if the value of x includes white space: foo="${x}" -> foo=value of x.
					// To correct this, include space in tag: foo="${ x }" -> foo="value of x"
				}
				return typeof name === "string" ? (jQuery.template[name] = tmpl) : tmpl;
			}
			// Return named compiled template
			return name ? (typeof name !== "string" ? jQuery.template( null, name ):
				(jQuery.template[name] ||
					// If not in map, and not containing at least on HTML tag, treat as a selector.
					// (If integrated with core, use quickExpr.exec)
					jQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null;
		},

		encode: function( text ) {
			// Do HTML encoding replacing < > & and ' and " by corresponding entities.
			return ("" + text).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;");
		}
	});

	jQuery.extend( jQuery.tmpl, {
		tag: {
			"tmpl": {
				_default: { $2: "null" },
				open: "if($notnull_1){__=__.concat($item.nest($1,$2));}"
				// tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)
				// This means that {{tmpl foo}} treats foo as a template (which IS a function).
				// Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.
			},
			"wrap": {
				_default: { $2: "null" },
				open: "$item.calls(__,$1,$2);__=[];",
				close: "call=$item.calls();__=call._.concat($item.wrap(call,__));"
			},
			"each": {
				_default: { $2: "$index, $value" },
				open: "if($notnull_1){$.each($1a,function($2){with(this){",
				close: "}});}"
			},
			"if": {
				open: "if(($notnull_1) && $1a){",
				close: "}"
			},
			"else": {
				_default: { $1: "true" },
				open: "}else if(($notnull_1) && $1a){"
			},
			"html": {
				// Unecoded expression evaluation.
				open: "if($notnull_1){__.push($1a);}"
			},
			"=": {
				// Encoded expression evaluation. Abbreviated form is ${}.
				_default: { $1: "$data" },
				open: "if($notnull_1){__.push($.encode($1a));}"
			},
			"!": {
				// Comment tag. Skipped by parser
				open: ""
			}
		},

		// This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events
		complete: function( items ) {
			newTmplItems = {};
		},

		// Call this from code which overrides domManip, or equivalent
		// Manage cloning/storing template items etc.
		afterManip: function afterManip( elem, fragClone, callback ) {
			// Provides cloned fragment ready for fixup prior to and after insertion into DOM
			var content = fragClone.nodeType === 11 ?
				jQuery.makeArray(fragClone.childNodes) :
				fragClone.nodeType === 1 ? [fragClone] : [];

			// Return fragment to original caller (e.g. append) for DOM insertion
			callback.call( elem, fragClone );

			// Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.
			storeTmplItems( content );
			cloneIndex++;
		}
	});

	//========================== Private helper functions, used by code above ==========================

	function build( tmplItem, nested, content ) {
		// Convert hierarchical content into flat string array
		// and finally return array of fragments ready for DOM insertion
		var frag, ret = content ? jQuery.map( content, function( item ) {
			return (typeof item === "string") ?
				// Insert template item annotations, to be converted to jQuery.data( "tmplItem" ) when elems are inserted into DOM.
				(tmplItem.key ? item.replace( /(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g, "$1 " + tmplItmAtt + "=\"" + tmplItem.key + "\" $2" ) : item) :
				// This is a child template item. Build nested template.
				build( item, tmplItem, item._ctnt );
		}) :
		// If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.
		tmplItem;
		if ( nested ) {
			return ret;
		}

		// top-level template
		ret = ret.join("");

		// Support templates which have initial or final text nodes, or consist only of text
		// Also support HTML entities within the HTML markup.
		ret.replace( /^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/, function( all, before, middle, after) {
			frag = jQuery( middle ).get();

			storeTmplItems( frag );
			if ( before ) {
				frag = unencode( before ).concat(frag);
			}
			if ( after ) {
				frag = frag.concat(unencode( after ));
			}
		});
		
		return frag ? frag : unencode( ret );
	}

	function unencode( text ) {
		// Use createElement, since createTextNode will not render HTML entities correctly
		var el = document.createElement( "div" );
		el.innerHTML = text;
		return jQuery.makeArray(el.childNodes);
	}

	// Generate a reusable function that will serve to render a template against data
	function buildTmplFn( markup ) {
		return new Function("jQuery","$item",
			// Use the variable __ to hold a string array while building the compiled template. (See https://github.com/jquery/jquery-tmpl/issues#issue/10).
			"var $=jQuery,call,__=[],$data=$item.data;" +

			// Introduce the data as local variables using with(){}
			"with($data){__.push('" +

			// Convert the template into pure JavaScript
			jQuery.trim(markup)
				.replace( /([\\'])/g, "\\$1" )
				.replace( /[\r\t\n]/g, " " )
				.replace( /\$\{([^\}]*)\}/g, "{{= $1}}" )
				.replace( /\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,
				function( all, slash, type, fnargs, target, parens, args ) {
					var tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;
					if ( !tag ) {
						throw "Unknown template tag: " + type;
					}
					def = tag._default || [];
					if ( parens && !/\w$/.test(target)) {
						target += parens;
						parens = "";
					}
					if ( target ) {
						target = unescape( target );
						args = args ? ("," + unescape( args ) + ")") : (parens ? ")" : "");
						// Support for target being things like a.toLowerCase();
						// In that case don't call with template item as 'this' pointer. Just evaluate...
						expr = parens ? (target.indexOf(".") > -1 ? target + unescape( parens ) : ("(" + target + ").call($item" + args)) : target;
						exprAutoFnDetect = parens ? expr : "(typeof(" + target + ")==='function'?(" + target + ").call($item):(" + target + "))";
					} else {
						exprAutoFnDetect = expr = def.$1 || "null";
					}
					fnargs = unescape( fnargs );
					return "');" +
						tag[ slash ? "close" : "open" ]
							.split( "$notnull_1" ).join( target ? "typeof(" + target + ")!=='undefined' && (" + target + ")!=null" : "true" )
							.split( "$1a" ).join( exprAutoFnDetect )
							.split( "$1" ).join( expr )
							.split( "$2" ).join( fnargs || def.$2 || "" ) +
						"__.push('";
				}) +
			"');}return __;"
		);
	}
	function updateWrapped( options, wrapped ) {
		// Build the wrapped content.
		options._wrap = build( options, true,
			// Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.
			jQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]
		).join("");
	}

	function unescape( args ) {
		return args ? args.replace( /\\'/g, "'").replace(/\\\\/g, "\\" ) : null;
	}
	function outerHtml( elem ) {
		var div = document.createElement("div");
		div.appendChild( elem.cloneNode(true) );
		return div.innerHTML;
	}

	// Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.
	function storeTmplItems( content ) {
		var keySuffix = "_" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;
		for ( i = 0, l = content.length; i < l; i++ ) {
			if ( (elem = content[i]).nodeType !== 1 ) {
				continue;
			}
			elems = elem.getElementsByTagName("*");
			for ( m = elems.length - 1; m >= 0; m-- ) {
				processItemKey( elems[m] );
			}
			processItemKey( elem );
		}
		function processItemKey( el ) {
			var pntKey, pntNode = el, pntItem, tmplItem, key;
			// Ensure that each rendered template inserted into the DOM has its own template item,
			if ( (key = el.getAttribute( tmplItmAtt ))) {
				while ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }
				if ( pntKey !== key ) {
					// The next ancestor with a _tmplitem expando is on a different key than this one.
					// So this is a top-level element within this template item
					// Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.
					pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;
					if ( !(tmplItem = newTmplItems[key]) ) {
						// The item is for wrapped content, and was copied from the temporary parent wrappedItem.
						tmplItem = wrappedItems[key];
						tmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode] );
						tmplItem.key = ++itemKey;
						newTmplItems[itemKey] = tmplItem;
					}
					if ( cloneIndex ) {
						cloneTmplItem( key );
					}
				}
				el.removeAttribute( tmplItmAtt );
			} else if ( cloneIndex && (tmplItem = jQuery.data( el, "tmplItem" )) ) {
				// This was a rendered element, cloned during append or appendTo etc.
				// TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.
				cloneTmplItem( tmplItem.key );
				newTmplItems[tmplItem.key] = tmplItem;
				pntNode = jQuery.data( el.parentNode, "tmplItem" );
				pntNode = pntNode ? pntNode.key : 0;
			}
			if ( tmplItem ) {
				pntItem = tmplItem;
				// Find the template item of the parent element.
				// (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)
				while ( pntItem && pntItem.key != pntNode ) {
					// Add this element as a top-level node for this rendered template item, as well as for any
					// ancestor items between this item and the item of its parent element
					pntItem.nodes.push( el );
					pntItem = pntItem.parent;
				}
				// Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...
				delete tmplItem._ctnt;
				delete tmplItem._wrap;
				// Store template item as jQuery data on the element
				jQuery.data( el, "tmplItem", tmplItem );
			}
			function cloneTmplItem( key ) {
				key = key + keySuffix;
				tmplItem = newClonedItems[key] =
					(newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent ));
			}
		}
	}

	//---- Helper functions for template item ----

	function tiCalls( content, tmpl, data, options ) {
		if ( !content ) {
			return stack.pop();
		}
		stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });
	}

	function tiNest( tmpl, data, options ) {
		// nested template, using {{tmpl}} tag
		return jQuery.tmpl( jQuery.template( tmpl ), data, options, this );
	}

	function tiWrap( call, wrapped ) {
		// nested template, using {{wrap}} tag
		var options = call.options || {};
		options.wrapped = wrapped;
		// Apply the template, which may incorporate wrapped content,
		return jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );
	}

	function tiHtml( filter, textOnly ) {
		var wrapped = this._wrap;
		return jQuery.map(
			jQuery( jQuery.isArray( wrapped ) ? wrapped.join("") : wrapped ).filter( filter || "*" ),
			function(e) {
				return textOnly ?
					e.innerText || e.textContent :
					e.outerHTML || outerHtml(e);
			});
	}

	function tiUpdate() {
		var coll = this.nodes;
		jQuery.tmpl( null, null, null, this).insertBefore( coll[0] );
		jQuery( coll ).remove();
	}
})( jQuery );

/**
 * @preserve
 * jquery.layout 1.4.4
 * $Date: 2014-11-29 08:00:00 (Sat, 29 November 2014) $
 * $Rev: 1.0404 $
 *
 * Copyright (c) 2014 Kevin Dalman (http://jquery-dev.com)
 * Based on work by Fabrizio Balliano (http://www.fabrizioballiano.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * SEE: http://layout.jquery-dev.com/LICENSE.txt
 *
 * Changelog: http://layout.jquery-dev.com/changelog.cfm
 *
 * Docs: http://layout.jquery-dev.com/documentation.html
 * Tips: http://layout.jquery-dev.com/tips.html
 * Help: http://groups.google.com/group/jquery-ui-layout
 */

/* JavaDoc Info: http://code.google.com/closure/compiler/docs/js-for-compiler.html
 * {!Object}	non-nullable type (never NULL)
 * {?string}	nullable type (sometimes NULL) - default for {Object}
 * {number=}	optional parameter
 * {*}			ALL types
 */
/*	TODO for jQ 2.x 
 *	check $.fn.disableSelection - this is in jQuery UI 1.9.x
 */

// NOTE: For best readability, view with a fixed-width font and tabs equal to 4-chars

; (function ($) {

    // alias Math methods - used a lot!
    var min = Math.min
    , max = Math.max
    , round = Math.floor

    , isStr = function (v) { return $.type(v) === "string"; }

        /**
         * @param {!Object}			Instance
         * @param {Array.<string>}	a_fn
         */
    , runPluginCallbacks = function (Instance, a_fn) {
        if ($.isArray(a_fn))
            for (var i = 0, c = a_fn.length; i < c; i++) {
                var fn = a_fn[i];
                try {
                    if (isStr(fn)) // 'name' of a function
                        fn = eval(fn);
                    if ($.isFunction(fn))
                        g(fn)(Instance);
                } catch (ex) { }
            }
        function g(f) { return f; }; // compiler hack
    }
    ;

    /*
     *	GENERIC $.layout METHODS - used by all layouts
     */
    $.layout = {

        version: "1.4.4"
    , revision: 1.0404 // eg: ver 1.4.4 = rev 1.0404 - major(n+).minor(nn)+patch(nn+)

        // $.layout.browser REPLACES $.browser
    , browser: {} // set below

        // *PREDEFINED* EFFECTS & DEFAULTS 
        // MUST list effect here - OR MUST set an fxSettings option (can be an empty hash: {})
    , effects: {

        //	Pane Open/Close Animations
        slide: {
            all: { duration: "fast" } // eg: duration: 1000, easing: "easeOutBounce"
		, north: { direction: "up" }
		, south: { direction: "down" }
		, east: { direction: "right" }
		, west: { direction: "left" }
        }
        , drop: {
            all: { duration: "slow" }
            , north: { direction: "up" }
            , south: { direction: "down" }
            , east: { direction: "right" }
            , west: { direction: "left" }
        }
        , scale: {
            all: { duration: "fast" }
        }
        //	these are not recommended, but can be used
        , blind: {}
        , clip: {}
        , explode: {}
        , fade: {}
        , fold: {}
        , puff: {}

        //	Pane Resize Animations
        , size: {
            all: { easing: "swing" }
        }
    }

        // INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
    , config: {
        optionRootKeys: "effects,panes,north,south,west,east,center".split(",")
        , allPanes: "north,south,west,east,center".split(",")
        , borderPanes: "north,south,west,east".split(",")
        , oppositeEdge: {
            north: "south"
            , south: "north"
            , east: "west"
            , west: "east"
        }
        //	offscreen data
        , offscreenCSS: { left: "-99999px", right: "auto" } // used by hide/close if useOffscreenClose=true
        , offscreenReset: "offscreenReset" // key used for data
        //	CSS used in multiple places
        , hidden: { visibility: "hidden" }
        , visible: { visibility: "visible" }
        //	layout element settings
        , resizers: {
            cssReq: {
                position: "absolute"
			, padding: 0
			, margin: 0
			, fontSize: "1px"
			, textAlign: "left"	// to counter-act "center" alignment!
			, overflow: "hidden" // prevent toggler-button from overflowing
                //	SEE $.layout.defaults.zIndexes.resizer_normal
            }
            , cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
                background: "#DDD"
                , border: "none"
            }
        }
        , togglers: {
            cssReq: {
                position: "absolute"
			, display: "block"
			, padding: 0
			, margin: 0
			, overflow: "hidden"
			, textAlign: "center"
			, fontSize: "1px"
			, cursor: "pointer"
			, zIndex: 1
            }
            , cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
                background: "#AAA"
            }
        }
        , content: {
            cssReq: {
                position: "relative" /* contain floated or positioned elements */
            }
            , cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
                overflow: "auto"
                , padding: "10px"
            }
            , cssDemoPane: { // DEMO CSS - REMOVE scrolling from 'pane' when it has a content-div
                overflow: "hidden"
                , padding: 0
            }
        }
        , panes: { // defaults for ALL panes - overridden by 'per-pane settings' below
            cssReq: {
                position: "absolute"
			, margin: 0
                //	$.layout.defaults.zIndexes.pane_normal
            }
            , cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
                padding: "10px"
                , background: "#FFF"
                , border: "1px solid #BBB"
                , overflow: "auto"
            }
        }
        , north: {
            side: "top"
            , sizeType: "Height"
            , dir: "horz"
            , cssReq: {
                top: 0
                , bottom: "auto"
                , left: 0
                , right: 0
                , width: "auto"
                //	height: 	DYNAMIC
            }
        }
        , south: {
            side: "bottom"
            , sizeType: "Height"
            , dir: "horz"
            , cssReq: {
                top: "auto"
                , bottom: 0
                , left: 0
                , right: 0
                , width: "auto"
                //	height: 	DYNAMIC
            }
        }
        , east: {
            side: "right"
            , sizeType: "Width"
            , dir: "vert"
            , cssReq: {
                left: "auto"
                , right: 0
                , top: "auto" // DYNAMIC
                , bottom: "auto" // DYNAMIC
                , height: "auto"
                //	width: 		DYNAMIC
            }
        }
        , west: {
            side: "left"
            , sizeType: "Width"
            , dir: "vert"
            , cssReq: {
                left: 0
                , right: "auto"
                , top: "auto" // DYNAMIC
                , bottom: "auto" // DYNAMIC
                , height: "auto"
                //	width: 		DYNAMIC
            }
        }
        , center: {
            dir: "center"
            , cssReq: {
                left: "auto" // DYNAMIC
                , right: "auto" // DYNAMIC
                , top: "auto" // DYNAMIC
                , bottom: "auto" // DYNAMIC
                , height: "auto"
                , width: "auto"
            }
        }
    }

        // CALLBACK FUNCTION NAMESPACE - used to store reusable callback functions
    , callbacks: {}

    , getParentPaneElem: function (el) {
        // must pass either a container or pane element
        var $el = $(el)
		, layout = $el.data("layout") || $el.data("parentLayout");
        if (layout) {
            var $cont = layout.container;
            // see if this container is directly-nested inside an outer-pane
            if ($cont.data("layoutPane")) return $cont;
            var $pane = $cont.closest("." + $.layout.defaults.panes.paneClass);
            // if a pane was found, return it
            if ($pane.data("layoutPane")) return $pane;
        }
        return null;
    }

    , getParentPaneInstance: function (el) {
        // must pass either a container or pane element
        var $pane = $.layout.getParentPaneElem(el);
        return $pane ? $pane.data("layoutPane") : null;
    }

    , getParentLayoutInstance: function (el) {
        // must pass either a container or pane element
        var $pane = $.layout.getParentPaneElem(el);
        return $pane ? $pane.data("parentLayout") : null;
    }

    , getEventObject: function (evt) {
        return typeof evt === "object" && evt.stopPropagation ? evt : null;
    }
    , parsePaneName: function (evt_or_pane) {
        var evt = $.layout.getEventObject(evt_or_pane)
		, pane = evt_or_pane;
        if (evt) {
            // ALWAYS stop propagation of events triggered in Layout!
            evt.stopPropagation();
            pane = $(this).data("layoutEdge");
        }
        if (pane && !/^(west|east|north|south|center)$/.test(pane)) {
            $.layout.msg('LAYOUT ERROR - Invalid pane-name: "' + pane + '"');
            pane = "error";
        }
        return pane;
    }


        // LAYOUT-PLUGIN REGISTRATION
        // more plugins can added beyond this default list
    , plugins: {
        draggable: !!$.fn.draggable // resizing
        , effects: {
            core: !!$.effects		// animimations (specific effects tested by initOptions)
            , slide: $.effects && ($.effects.slide || ($.effects.effect && $.effects.effect.slide)) // default effect
        }
    }

        //	arrays of plugin or other methods to be triggered for events in *each layout* - will be passed 'Instance'
    , onCreate: []	// runs when layout is just starting to be created - right after options are set
    , onLoad: []	// runs after layout container and global events init, but before initPanes is called
    , onReady: []	// runs after initialization *completes* - ie, after initPanes completes successfully
    , onDestroy: []	// runs after layout is destroyed
    , onUnload: []	// runs after layout is destroyed OR when page unloads
    , afterOpen: []	// runs after setAsOpen() completes
    , afterClose: []	// runs after setAsClosed() completes

        /*
         *	GENERIC UTILITY METHODS
         */

        // calculate and return the scrollbar width, as an integer
    , scrollbarWidth: function () { return window.scrollbarWidth || $.layout.getScrollbarSize('width'); }
    , scrollbarHeight: function () { return window.scrollbarHeight || $.layout.getScrollbarSize('height'); }
    , getScrollbarSize: function (dim) {
        var $c = $('<div style="position: absolute; top: -10000px; left: -10000px; width: 100px; height: 100px; border: 0; overflow: scroll;"></div>').appendTo("body")
		, d = { width: $c.outerWidth - $c[0].clientWidth, height: 100 - $c[0].clientHeight };
        $c.remove();
        window.scrollbarWidth = d.width;
        window.scrollbarHeight = d.height;
        return dim.match(/^(width|height)$/) ? d[dim] : d;
    }


    , disableTextSelection: function () {
        var $d = $(document)
		, s = 'textSelectionDisabled'
		, x = 'textSelectionInitialized'
        ;
        if ($.fn.disableSelection) {
            if (!$d.data(x)) // document hasn't been initialized yet
                $d.on('mouseup', $.layout.enableTextSelection).data(x, true);
            if (!$d.data(s))
                $d.disableSelection().data(s, true);
        }
    }
    , enableTextSelection: function () {
        var $d = $(document)
		, s = 'textSelectionDisabled';
        if ($.fn.enableSelection && $d.data(s))
            $d.enableSelection().data(s, false);
    }


        /**
         * Returns hash container 'display' and 'visibility'
         *
         * @see	$.swap() - swaps CSS, runs callback, resets CSS
         * @param  {!Object}		$E				jQuery element
         * @param  {boolean=}	[force=false]	Run even if display != none
         * @return {!Object}						Returns current style props, if applicable
         */
    , showInvisibly: function ($E, force) {
        if ($E && $E.length && (force || $E.css("display") === "none")) { // only if not *already hidden*
            var s = $E[0].style
				// save ONLY the 'style' props because that is what we must restore
			, CSS = { display: s.display || '', visibility: s.visibility || '' };
            // show element 'invisibly' so can be measured
            $E.css({ display: "block", visibility: "hidden" });
            return CSS;
        }
        return {};
    }

        /**
         * Returns data for setting size of an element (container or a pane).
         *
         * @see  _create(), onWindowResize() for container, plus others for pane
         * @return JSON  Returns a hash of all dimensions: top, bottom, left, right, outerWidth, innerHeight, etc
         */
    , getElementDimensions: function ($E, inset) {
        var
		//	dimensions hash - start with current data IF passed
			d = { css: {}, inset: {} }
		, x = d.css			// CSS hash
		, i = { bottom: 0 }	// TEMP insets (bottom = complier hack)
		, N = $.layout.cssNum
		, R = Math.round
		, off = $E.offset()
		, b, p, ei			// TEMP border, padding
        ;
        d.offsetLeft = off.left;
        d.offsetTop = off.top;

        if (!inset) inset = {}; // simplify logic below

        $.each("Left,Right,Top,Bottom".split(","), function (idx, e) { // e = edge
            b = x["border" + e] = $.layout.borderWidth($E, e);
            p = x["padding" + e] = $.layout.cssNum($E, "padding" + e);
            ei = e.toLowerCase();
            d.inset[ei] = inset[ei] >= 0 ? inset[ei] : p; // any missing insetX value = paddingX
            i[ei] = d.inset[ei] + b; // total offset of content from outer side
        });

        x.width = R($E.width());
        x.height = R($E.height());
        x.top = N($E, "top", true);
        x.bottom = N($E, "bottom", true);
        x.left = N($E, "left", true);
        x.right = N($E, "right", true);

        d.outerWidth = R($E.outerWidth());
        d.outerHeight = R($E.outerHeight());
        // calc the TRUE inner-dimensions, even in quirks-mode!
        d.innerWidth = max(0, d.outerWidth - i.left - i.right);
        d.innerHeight = max(0, d.outerHeight - i.top - i.bottom);
        // layoutWidth/Height is used in calcs for manual resizing
        // layoutW/H only differs from innerW/H when in quirks-mode - then is like outerW/H
        d.layoutWidth = R($E.innerWidth());
        d.layoutHeight = R($E.innerHeight());

        //if ($E.prop('tagName') === 'BODY') { debugData( d, $E.prop('tagName') ); } // DEBUG

        //d.visible	= $E.is(":visible");// && x.width > 0 && x.height > 0;

        return d;
    }

    , getElementStyles: function ($E, list) {
        var
			CSS = {}
		, style = $E[0].style
		, props = list.split(",")
		, sides = "Top,Bottom,Left,Right".split(",")
		, attrs = "Color,Style,Width".split(",")
		, p, s, a, i, j, k
        ;
        for (i = 0; i < props.length; i++) {
            p = props[i];
            if (p.match(/(border|padding|margin)$/))
                for (j = 0; j < 4; j++) {
                    s = sides[j];
                    if (p === "border")
                        for (k = 0; k < 3; k++) {
                            a = attrs[k];
                            CSS[p + s + a] = style[p + s + a];
                        }
                    else
                        CSS[p + s] = style[p + s];
                }
            else
                CSS[p] = style[p];
        };
        return CSS
    }

        /**
         * Return the innerWidth for the current browser/doctype
         *
         * @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
         * @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
         * @param  {number=}			outerWidth (optional) Can pass a width, allowing calculations BEFORE element is resized
         * @return {number}			Returns the innerWidth of the elem by subtracting padding and borders
         */
    , cssWidth: function ($E, outerWidth) {
        // a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
        if (outerWidth <= 0) return 0;

        var lb = $.layout.browser
		, bs = !lb.boxModel ? "border-box" : lb.boxSizing ? $E.css("boxSizing") : "content-box"
		, b = $.layout.borderWidth
		, n = $.layout.cssNum
		, W = outerWidth
        ;
        // strip border and/or padding from outerWidth to get CSS Width
        if (bs !== "border-box")
            W -= (b($E, "Left") + b($E, "Right"));
        if (bs === "content-box")
            W -= (n($E, "paddingLeft") + n($E, "paddingRight"));
        return max(0, W);
    }

        /**
         * Return the innerHeight for the current browser/doctype
         *
         * @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
         * @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
         * @param  {number=}			outerHeight  (optional) Can pass a width, allowing calculations BEFORE element is resized
         * @return {number}			Returns the innerHeight of the elem by subtracting padding and borders
         */
    , cssHeight: function ($E, outerHeight) {
        // a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
        if (outerHeight <= 0) return 0;

        var lb = $.layout.browser
		, bs = !lb.boxModel ? "border-box" : lb.boxSizing ? $E.css("boxSizing") : "content-box"
		, b = $.layout.borderWidth
		, n = $.layout.cssNum
		, H = outerHeight
        ;
        // strip border and/or padding from outerHeight to get CSS Height
        if (bs !== "border-box")
            H -= (b($E, "Top") + b($E, "Bottom"));
        if (bs === "content-box")
            H -= (n($E, "paddingTop") + n($E, "paddingBottom"));
        return max(0, H);
    }

        /**
         * Returns the 'current CSS numeric value' for a CSS property - 0 if property does not exist
         *
         * @see  Called by many methods
         * @param {Array.<Object>}	$E					Must pass a jQuery object - first element is processed
         * @param {string}			prop				The name of the CSS property, eg: top, width, etc.
         * @param {boolean=}			[allowAuto=false]	true = return 'auto' if that is value; false = return 0
         * @return {(string|number)}						Usually used to get an integer value for position (top, left) or size (height, width)
         */
    , cssNum: function ($E, prop, allowAuto) {
        if (!$E.jquery) $E = $($E);
        var CSS = $.layout.showInvisibly($E)
		, p = $.css($E[0], prop, true)
		, v = allowAuto && p == "auto" ? p : Math.round(parseFloat(p) || 0);
        $E.css(CSS); // RESET
        return v;
    }

    , borderWidth: function (el, side) {
        if (el.jquery) el = el[0];
        var b = "border" + side.substr(0, 1).toUpperCase() + side.substr(1); // left => Left
        return $.css(el, b + "Style", true) === "none" ? 0 : Math.round(parseFloat($.css(el, b + "Width", true)) || 0);
    }

        /**
         * Mouse-tracking utility - FUTURE REFERENCE
         *
         * init: if (!window.mouse) {
         *			window.mouse = { x: 0, y: 0 };
         *			$(document).mousemove( $.layout.trackMouse );
         *		}
         *
         * @param {Object}		evt
         *
    ,	trackMouse: function (evt) {
            window.mouse = { x: evt.clientX, y: evt.clientY };
        }
        */

        /**
         * SUBROUTINE for preventPrematureSlideClose option
         *
         * @param {Object}		evt
         * @param {Object=}		el
         */
    , isMouseOverElem: function (evt, el) {
        var
			$E = $(el || this)
		, d = $E.offset()
		, T = d.top
		, L = d.left
		, R = L + $E.outerWidth()
		, B = T + $E.outerHeight()
		, x = evt.pageX	// evt.clientX ?
		, y = evt.pageY	// evt.clientY ?
        ;
        // if X & Y are < 0, probably means is over an open SELECT
        return ($.layout.browser.msie && x < 0 && y < 0) || ((x >= L && x <= R) && (y >= T && y <= B));
    }

        /**
         * Message/Logging Utility
         *
         * @example $.layout.msg("My message");				// log text
         * @example $.layout.msg("My message", true);		// alert text
         * @example $.layout.msg({ foo: "bar" }, "Title");	// log hash-data, with custom title
         * @example $.layout.msg({ foo: "bar" }, true, "Title", { sort: false }); -OR-
         * @example $.layout.msg({ foo: "bar" }, "Title", { sort: false, display: true }); // alert hash-data
         *
         * @param {(Object|string)}			info			String message OR Hash/Array
         * @param {(Boolean|string|Object)=}	[popup=false]	True means alert-box - can be skipped
         * @param {(Object|string)=}			[debugTitle=""]	Title for Hash data - can be skipped
         * @param {Object=}					[debugOpts]		Extra options for debug output
         */
    , msg: function (info, popup, debugTitle, debugOpts) {
        if ($.isPlainObject(info) && window.debugData) {
            if (typeof popup === "string") {
                debugOpts = debugTitle;
                debugTitle = popup;
            }
            else if (typeof debugTitle === "object") {
                debugOpts = debugTitle;
                debugTitle = null;
            }
            var t = debugTitle || "log( <object> )"
			, o = $.extend({ sort: false, returnHTML: false, display: false }, debugOpts);
            if (popup === true || o.display)
                debugData(info, t, o);
            else if (window.console)
                console.log(debugData(info, t, o));
        }
        else if (window.console)
            console.log(info);
        else if (popup)
            alert(info);
        else {
            var id = "#layoutLogger"
			, $l = $(id);
            if (!$l.length)
                $l = createLog();
            $l.children("ul").append('<li style="padding: 4px 10px; margin: 0; border-top: 1px solid #CCC;">' + info.replace(/\</g, "&lt;").replace(/\>/g, "&gt;") + '</li>');
        }

        function createLog() {
            var pos = $.support.fixedPosition ? 'fixed' : 'absolute'
			, $e = $('<div id="layoutLogger" style="position: ' + pos + '; top: 5px; z-index: 999999; max-width: 25%; overflow: hidden; border: 1px solid #000; border-radius: 5px; background: #FBFBFB; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">'
				+ '<div style="font-size: 13px; font-weight: bold; padding: 5px 10px; background: #F6F6F6; border-radius: 5px 5px 0 0; cursor: move;">'
				+ '<span style="float: right; padding-left: 7px; cursor: pointer;" title="Remove Console" onclick="$(this).closest(\'#layoutLogger\').remove()">X</span>Layout console.log</div>'
				+ '<ul style="font-size: 13px; font-weight: none; list-style: none; margin: 0; padding: 0 0 2px;"></ul>'
				+ '</div>'
				).appendTo("body");
            $e.css('left', $(window).width() - $e.outerWidth() - 5)
            if ($.ui.draggable) $e.draggable({ handle: ':first-child' });
            return $e;
        };
    }

    };


    /*
     *	$.layout.browser REPLACES removed $.browser, with extra data
     *	Parsing code here adapted from jQuery 1.8 $.browse
     */
    (function () {
        var u = navigator.userAgent.toLowerCase()
        , m = /(chrome)[ \/]([\w.]+)/.exec(u)
            || /(webkit)[ \/]([\w.]+)/.exec(u)
            || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(u)
            || /(msie) ([\w.]+)/.exec(u)
            || u.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(u)
            || []
        , b = m[1] || ""
        , v = m[2] || 0
        , ie = b === "msie"
        , cm = document.compatMode
        , $s = $.support
        , bs = $s.boxSizing !== undefined ? $s.boxSizing : $s.boxSizingReliable
        , bm = !ie || !cm || cm === "CSS1Compat" || $s.boxModel || false
        , lb = $.layout.browser = {
            version: v
            , safari: b === "webkit"	// webkit (NOT chrome) = safari
            , webkit: b === "chrome"	// chrome = webkit
            , msie: ie
            , isIE6: ie && v == 6
            // ONLY IE reverts to old box-model - Note that compatMode was deprecated as of IE8
            , boxModel: bm
            , boxSizing: !!(typeof bs === "function" ? bs() : bs)
        };
        ;
        if (b) lb[b] = true; // set CURRENT browser
        /*	OLD versions of jQuery only set $.support.boxModel after page is loaded
         *	so if this is IE, use support.boxModel to test for quirks-mode (ONLY IE changes boxModel) */
        if (!bm && !cm) $(function () { lb.boxModel = $s.boxModel; });
    })();


    // DEFAULT OPTIONS
    $.layout.defaults = {
        /*
         *	LAYOUT & LAYOUT-CONTAINER OPTIONS
         *	- none of these options are applicable to individual panes
         */
        name: ""			// Not required, but useful for buttons and used for the state-cookie
    , containerClass: "ui-layout-container" // layout-container element
    , inset: null		// custom container-inset values (override padding)
    , scrollToBookmarkOnLoad: true		// after creating a layout, scroll to bookmark in URL (.../page.htm#myBookmark)
    , resizeWithWindow: true		// bind thisLayout.resizeAll() to the window.resize event
    , resizeWithWindowDelay: 200			// delay calling resizeAll because makes window resizing very jerky
    , resizeWithWindowMaxDelay: 0			// 0 = none - force resize every XX ms while window is being resized
    , maskPanesEarly: false		// true = create pane-masks on resizer.mouseDown instead of waiting for resizer.dragstart
    , onresizeall_start: null		// CALLBACK when resizeAll() STARTS	- NOT pane-specific
    , onresizeall_end: null		// CALLBACK when resizeAll() ENDS	- NOT pane-specific
    , onload_start: null		// CALLBACK when Layout inits - after options initialized, but before elements
    , onload_end: null		// CALLBACK when Layout inits - after EVERYTHING has been initialized
    , onunload_start: null		// CALLBACK when Layout is destroyed OR onWindowUnload
    , onunload_end: null		// CALLBACK when Layout is destroyed OR onWindowUnload
    , initPanes: true		// false = DO NOT initialize the panes onLoad - will init later
    , showErrorMessages: true		// enables fatal error messages to warn developers of common errors
    , showDebugMessages: false		// display console-and-alert debug msgs - IF this Layout version _has_ debugging code!
        //	Changing this zIndex value will cause other zIndex values to automatically change
    , zIndex: null		// the PANE zIndex - resizers and masks will be +1
        //	DO NOT CHANGE the zIndex values below unless you clearly understand their relationships
    , zIndexes: {								// set _default_ z-index values here...
        pane_normal: 0			// normal z-index for panes
        , content_mask: 1			// applied to overlays used to mask content INSIDE panes during resizing
        , resizer_normal: 2			// normal z-index for resizer-bars
        , pane_sliding: 100			// applied to *BOTH* the pane and its resizer when a pane is 'slid open'
        , pane_animate: 1000		// applied to the pane when being animated - not applied to the resizer
        , resizer_drag: 10000		// applied to the CLONED resizer-bar when being 'dragged'
    }
    , errors: {
        pane: "pane"		// description of "layout pane element" - used only in error messages
        , selector: "selector"	// description of "jQuery-selector" - used only in error messages
        , addButtonError: "Error Adding Button\nInvalid "
        , containerMissing: "UI Layout Initialization Error\nThe specified layout-container does not exist."
        , centerPaneMissing: "UI Layout Initialization Error\nThe center-pane element does not exist.\nThe center-pane is a required element."
        , noContainerHeight: "UI Layout Initialization Warning\nThe layout-container \"CONTAINER\" has no height.\nTherefore the layout is 0-height and hence 'invisible'!"
        , callbackError: "UI Layout Callback Error\nThe EVENT callback is not a valid function."
    }
        /*
         *	PANE DEFAULT SETTINGS
         *	- settings under the 'panes' key become the default settings for *all panes*
         *	- ALL pane-options can also be set specifically for each panes, which will override these 'default values'
         */
    , panes: { // default options for 'all panes' - will be overridden by 'per-pane settings'
        applyDemoStyles: false		// NOTE: renamed from applyDefaultStyles for clarity
        , closable: true		// pane can open & close
        , resizable: true		// when open, pane can be resized 
        , slidable: true		// when closed, pane can 'slide open' over other panes - closes on mouse-out
        , initClosed: false		// true = init pane as 'closed'
        , initHidden: false 		// true = init pane as 'hidden' - no resizer-bar/spacing
        //	SELECTORS
        //,	paneSelector:			""			// MUST be pane-specific - jQuery selector for pane
        , contentSelector: ".ui-layout-content" // INNER div/element to auto-size so only it scrolls, not the entire pane!
        , contentIgnoreSelector: ".ui-layout-ignore"	// element(s) to 'ignore' when measuring 'content'
        , findNestedContent: false		// true = $P.find(contentSelector), false = $P.children(contentSelector)
        //	GENERIC ROOT-CLASSES - for auto-generated classNames
        , paneClass: "ui-layout-pane"	// Layout Pane
        , resizerClass: "ui-layout-resizer"	// Resizer Bar
        , togglerClass: "ui-layout-toggler"	// Toggler Button
        , buttonClass: "ui-layout-button"	// CUSTOM Buttons	- eg: '[ui-layout-button]-toggle/-open/-close/-pin'
        //	ELEMENT SIZE & SPACING
        //,	size:					100			// MUST be pane-specific -initial size of pane
        , minSize: 0			// when manually resizing a pane
        , maxSize: 0			// ditto, 0 = no limit
        , spacing_open: 6			// space between pane and adjacent panes - when pane is 'open'
        , spacing_closed: 6			// ditto - when pane is 'closed'
        , togglerLength_open: 50			// Length = WIDTH of toggler button on north/south sides - HEIGHT on east/west sides
        , togglerLength_closed: 50			// 100% OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
        , togglerAlign_open: "center"	// top/left, bottom/right, center, OR...
        , togglerAlign_closed: "center"	// 1 => nn = offset from top/left, -1 => -nn == offset from bottom/right
        , togglerContent_open: ""			// text or HTML to put INSIDE the toggler
        , togglerContent_closed: ""			// ditto
        //	RESIZING OPTIONS
        , resizerDblClickToggle: true		// 
        , autoResize: true		// IF size is 'auto' or a percentage, then recalc 'pixel size' whenever the layout resizes
        , autoReopen: true		// IF a pane was auto-closed due to noRoom, reopen it when there is room? False = leave it closed
        , resizerDragOpacity: 1			// option for ui.draggable
        //,	resizerCursor:			""			// MUST be pane-specific - cursor when over resizer-bar
        , maskContents: false		// true = add DIV-mask over-or-inside this pane so can 'drag' over IFRAMES
        , maskObjects: false		// true = add IFRAME-mask over-or-inside this pane to cover objects/applets - content-mask will overlay this mask
        , maskZindex: null		// will override zIndexes.content_mask if specified - not applicable to iframe-panes
        , resizingGrid: false		// grid size that the resizers will snap-to during resizing, eg: [20,20]
        , livePaneResizing: false		// true = LIVE Resizing as resizer is dragged
        , liveContentResizing: false		// true = re-measure header/footer heights as resizer is dragged
        , liveResizingTolerance: 1			// how many px change before pane resizes, to control performance
        //	SLIDING OPTIONS
        , sliderCursor: "pointer"	// cursor when resizer-bar will trigger 'sliding'
        , slideTrigger_open: "click"		// click, dblclick, mouseenter
        , slideTrigger_close: "mouseleave"// click, mouseleave
        , slideDelay_open: 300			// applies only for mouseenter event - 0 = instant open
        , slideDelay_close: 300			// applies only for mouseleave event (300ms is the minimum!)
        , hideTogglerOnSlide: false		// when pane is slid-open, should the toggler show?
        , preventQuickSlideClose: $.layout.browser.webkit // Chrome triggers slideClosed as it is opening
        , preventPrematureSlideClose: false	// handle incorrect mouseleave trigger, like when over a SELECT-list in IE
        //	PANE-SPECIFIC TIPS & MESSAGES
        , tips: {
            Open: "Open"		// eg: "Open Pane"
            , Close: "Close"
            , Resize: "Resize"
            , Slide: "Slide Open"
            , Pin: "Pin"
            , Unpin: "Un-Pin"
            , noRoomToOpen: "Not enough room to show this panel."	// alert if user tries to open a pane that cannot
            , minSizeWarning: "Panel has reached its minimum size"	// displays in browser statusbar
            , maxSizeWarning: "Panel has reached its maximum size"	// ditto
        }
        //	HOT-KEYS & MISC
        , showOverflowOnHover: false		// will bind allowOverflow() utility to pane.onMouseOver
        , enableCursorHotkey: true		// enabled 'cursor' hotkeys
        //,	customHotkey:			""			// MUST be pane-specific - EITHER a charCode OR a character
        , customHotkeyModifier: "SHIFT"		// either 'SHIFT', 'CTRL' or 'CTRL+SHIFT' - NOT 'ALT'
        //	PANE ANIMATION
        //	NOTE: fxSss_open, fxSss_close & fxSss_size options (eg: fxName_open) are auto-generated if not passed
        , fxName: "slide" 	// ('none' or blank), slide, drop, scale -- only relevant to 'open' & 'close', NOT 'size'
        , fxSpeed: null		// slow, normal, fast, 200, nnn - if passed, will OVERRIDE fxSettings.duration
        , fxSettings: {}			// can be passed, eg: { easing: "easeOutBounce", duration: 1500 }
        , fxOpacityFix: true		// tries to fix opacity in IE to restore anti-aliasing after animation
        , animatePaneSizing: false		// true = animate resizing after dragging resizer-bar OR sizePane() is called
        /*  NOTE: Action-specific FX options are auto-generated from the options above if not specifically set:
            fxName_open:			"slide"		// 'Open' pane animation
            fnName_close:			"slide"		// 'Close' pane animation
            fxName_size:			"slide"		// 'Size' pane animation - when animatePaneSizing = true
            fxSpeed_open:			null
            fxSpeed_close:			null
            fxSpeed_size:			null
            fxSettings_open:		{}
            fxSettings_close:		{}
            fxSettings_size:		{}
        */
        //	CHILD/NESTED LAYOUTS
        , children: null		// Layout-options for nested/child layout - even {} is valid as options
        , containerSelector: ''			// if child is NOT 'directly nested', a selector to find it/them (can have more than one child layout!)
        , initChildren: true		// true = child layout will be created as soon as _this_ layout completes initialization
        , destroyChildren: true		// true = destroy child-layout if this pane is destroyed
        , resizeChildren: true		// true = trigger child-layout.resizeAll() when this pane is resized
        //	EVENT TRIGGERING
        , triggerEventsOnLoad: false		// true = trigger onopen OR onclose callbacks when layout initializes
        , triggerEventsDuringLiveResize: true	// true = trigger onresize callback REPEATEDLY if livePaneResizing==true
        //	PANE CALLBACKS
        , onshow_start: null		// CALLBACK when pane STARTS to Show	- BEFORE onopen/onhide_start
        , onshow_end: null		// CALLBACK when pane ENDS being Shown	- AFTER  onopen/onhide_end
        , onhide_start: null		// CALLBACK when pane STARTS to Close	- BEFORE onclose_start
        , onhide_end: null		// CALLBACK when pane ENDS being Closed	- AFTER  onclose_end
        , onopen_start: null		// CALLBACK when pane STARTS to Open
        , onopen_end: null		// CALLBACK when pane ENDS being Opened
        , onclose_start: null		// CALLBACK when pane STARTS to Close
        , onclose_end: null		// CALLBACK when pane ENDS being Closed
        , onresize_start: null		// CALLBACK when pane STARTS being Resized ***FOR ANY REASON***
        , onresize_end: null		// CALLBACK when pane ENDS being Resized ***FOR ANY REASON***
        , onsizecontent_start: null		// CALLBACK when sizing of content-element STARTS
        , onsizecontent_end: null		// CALLBACK when sizing of content-element ENDS
        , onswap_start: null		// CALLBACK when pane STARTS to Swap
        , onswap_end: null		// CALLBACK when pane ENDS being Swapped
        , ondrag_start: null		// CALLBACK when pane STARTS being ***MANUALLY*** Resized
        , ondrag_end: null		// CALLBACK when pane ENDS being ***MANUALLY*** Resized
    }
        /*
         *	PANE-SPECIFIC SETTINGS
         *	- options listed below MUST be specified per-pane - they CANNOT be set under 'panes'
         *	- all options under the 'panes' key can also be set specifically for any pane
         *	- most options under the 'panes' key apply only to 'border-panes' - NOT the the center-pane
         */
    , north: {
        paneSelector: ".ui-layout-north"
        , size: "auto"		// eg: "auto", "30%", .30, 200
        , resizerCursor: "n-resize"	// custom = url(myCursor.cur)
        , customHotkey: ""			// EITHER a charCode (43) OR a character ("o")
    }
    , south: {
        paneSelector: ".ui-layout-south"
        , size: "auto"
        , resizerCursor: "s-resize"
        , customHotkey: ""
    }
    , east: {
        paneSelector: ".ui-layout-east"
        , size: 200
        , resizerCursor: "e-resize"
        , customHotkey: ""
    }
    , west: {
        paneSelector: ".ui-layout-west"
        , size: 200
        , resizerCursor: "w-resize"
        , customHotkey: ""
    }
    , center: {
        paneSelector: ".ui-layout-center"
        , minWidth: 0
        , minHeight: 0
    }
    };

    $.layout.optionsMap = {
        // layout/global options - NOT pane-options
        layout: ("name,instanceKey,stateManagement,effects,inset,zIndexes,errors,"
        + "zIndex,scrollToBookmarkOnLoad,showErrorMessages,maskPanesEarly,"
        + "outset,resizeWithWindow,resizeWithWindowDelay,resizeWithWindowMaxDelay,"
        + "onresizeall,onresizeall_start,onresizeall_end,onload,onload_start,onload_end,onunload,onunload_start,onunload_end").split(",")
        //	borderPanes: [ ALL options that are NOT specified as 'layout' ]
        // default.panes options that apply to the center-pane (most options apply _only_ to border-panes)
    , center: ("paneClass,contentSelector,contentIgnoreSelector,findNestedContent,applyDemoStyles,triggerEventsOnLoad,"
        + "showOverflowOnHover,maskContents,maskObjects,liveContentResizing,"
        + "containerSelector,children,initChildren,resizeChildren,destroyChildren,"
        + "onresize,onresize_start,onresize_end,onsizecontent,onsizecontent_start,onsizecontent_end").split(",")
        // options that MUST be specifically set 'per-pane' - CANNOT set in the panes (defaults) key
    , noDefault: ("paneSelector,resizerCursor,customHotkey").split(",")
    };

    /**
     * Processes options passed in converts flat-format data into subkey (JSON) format
     * In flat-format, subkeys are _currently_ separated with 2 underscores, like north__optName
     * Plugins may also call this method so they can transform their own data
     *
     * @param  {!Object}	hash			Data/options passed by user - may be a single level or nested levels
     * @param  {boolean=}	[addKeys=false]	Should the primary layout.options keys be added if they do not exist?
     * @return {Object}						Returns hash of minWidth & minHeight
     */
    $.layout.transformData = function (hash, addKeys) {
        var json = addKeys ? { panes: {}, center: {} } : {} // init return object
        , branch, optKey, keys, key, val, i, c;

        if (typeof hash !== "object") return json; // no options passed

        // convert all 'flat-keys' to 'sub-key' format
        for (optKey in hash) {
            branch = json;
            val = hash[optKey];
            keys = optKey.split("__"); // eg: west__size or north__fxSettings__duration
            c = keys.length - 1;
            // convert underscore-delimited to subkeys
            for (i = 0; i <= c; i++) {
                key = keys[i];
                if (i === c) {	// last key = value
                    if ($.isPlainObject(val))
                        branch[key] = $.layout.transformData(val); // RECURSE
                    else
                        branch[key] = val;
                }
                else {
                    if (!branch[key])
                        branch[key] = {}; // create the subkey
                    // recurse to sub-key for next loop - if not done
                    branch = branch[key];
                }
            }
        }
        return json;
    };

    // INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
    $.layout.backwardCompatibility = {
        // data used by renameOldOptions()
        map: {
            //	OLD Option Name:			NEW Option Name
            applyDefaultStyles: "applyDemoStyles"
            //	CHILD/NESTED LAYOUTS
        , childOptions: "children"
        , initChildLayout: "initChildren"
        , destroyChildLayout: "destroyChildren"
        , resizeChildLayout: "resizeChildren"
        , resizeNestedLayout: "resizeChildren"
            //	MISC Options
        , resizeWhileDragging: "livePaneResizing"
        , resizeContentWhileDragging: "liveContentResizing"
        , triggerEventsWhileDragging: "triggerEventsDuringLiveResize"
        , maskIframesOnResize: "maskContents"
            //	STATE MANAGEMENT
        , useStateCookie: "stateManagement.enabled"
        , "cookie.autoLoad": "stateManagement.autoLoad"
        , "cookie.autoSave": "stateManagement.autoSave"
        , "cookie.keys": "stateManagement.stateKeys"
        , "cookie.name": "stateManagement.cookie.name"
        , "cookie.domain": "stateManagement.cookie.domain"
        , "cookie.path": "stateManagement.cookie.path"
        , "cookie.expires": "stateManagement.cookie.expires"
        , "cookie.secure": "stateManagement.cookie.secure"
            //	OLD Language options
        , noRoomToOpenTip: "tips.noRoomToOpen"
        , togglerTip_open: "tips.Close"	// open   = Close
        , togglerTip_closed: "tips.Open"		// closed = Open
        , resizerTip: "tips.Resize"
        , sliderTip: "tips.Slide"
        }

        /**
        * @param {Object}	opts
        */
    , renameOptions: function (opts) {
        var map = $.layout.backwardCompatibility.map
		, oldData, newData, value
        ;
        for (var itemPath in map) {
            oldData = getBranch(itemPath);
            value = oldData.branch[oldData.key];
            if (value !== undefined) {
                newData = getBranch(map[itemPath], true);
                newData.branch[newData.key] = value;
                delete oldData.branch[oldData.key];
            }
        }

        /**
		 * @param {string}	path
		 * @param {boolean=}	[create=false]	Create path if does not exist
		 */
        function getBranch(path, create) {
            var a = path.split(".") // split keys into array
			, c = a.length - 1
			, D = { branch: opts, key: a[c] } // init branch at top & set key (last item)
			, i = 0, k, undef;
            for (; i < c; i++) { // skip the last key (data)
                k = a[i];
                if (D.branch[k] == undefined) { // child-key does not exist
                    if (create) {
                        D.branch = D.branch[k] = {}; // create child-branch
                    }
                    else // can't go any farther
                        D.branch = {}; // branch is undefined
                }
                else
                    D.branch = D.branch[k]; // get child-branch
            }
            return D;
        };
    }

        /**
        * @param {Object}	opts
        */
    , renameAllOptions: function (opts) {
        var ren = $.layout.backwardCompatibility.renameOptions;
        // rename root (layout) options
        ren(opts);
        // rename 'defaults' to 'panes'
        if (opts.defaults) {
            if (typeof opts.panes !== "object")
                opts.panes = {};
            $.extend(true, opts.panes, opts.defaults);
            delete opts.defaults;
        }
        // rename options in the the options.panes key
        if (opts.panes) ren(opts.panes);
        // rename options inside *each pane key*, eg: options.west
        $.each($.layout.config.allPanes, function (i, pane) {
            if (opts[pane]) ren(opts[pane]);
        });
        return opts;
    }
    };




    /*	============================================================
     *	BEGIN WIDGET: $( selector ).layout( {options} );
     *	============================================================
     */
    $.fn.layout = function (opts) {
        var

        // local aliases to global data
        browser = $.layout.browser
    , _c = $.layout.config

        // local aliases to utlity methods
    , cssW = $.layout.cssWidth
    , cssH = $.layout.cssHeight
    , elDims = $.layout.getElementDimensions
    , styles = $.layout.getElementStyles
    , evtObj = $.layout.getEventObject
    , evtPane = $.layout.parsePaneName

    /**
     * options - populated by initOptions()
     */
    , options = $.extend(true, {}, $.layout.defaults)
    , effects = options.effects = $.extend(true, {}, $.layout.effects)

    /**
     * layout-state object
     */
    , state = {
        // generate unique ID to use for event.namespace so can unbind only events added by 'this layout'
        id: "layout" + $.now()	// code uses alias: sID
        , initialized: false
        , paneResizing: false
        , panesSliding: {}
        , container: { 	// list all keys referenced in code to avoid compiler error msgs
            innerWidth: 0
            , innerHeight: 0
            , outerWidth: 0
            , outerHeight: 0
            , layoutWidth: 0
            , layoutHeight: 0
        }
        , north: { childIdx: 0 }
        , south: { childIdx: 0 }
        , east: { childIdx: 0 }
        , west: { childIdx: 0 }
        , center: { childIdx: 0 }
    }

    /**
     * parent/child-layout pointers
     */
    //,	hasParentLayout	= false	- exists ONLY inside Instance so can be set externally
    , children = {
        north: null
        , south: null
        , east: null
        , west: null
        , center: null
    }

    /*
     * ###########################
     *  INTERNAL HELPER FUNCTIONS
     * ###########################
     */

        /**
         * Manages all internal timers
         */
    , timer = {
        data: {}
        , set: function (s, fn, ms) { timer.clear(s); timer.data[s] = setTimeout(fn, ms); }
        , clear: function (s) { var t = timer.data; if (t[s]) { clearTimeout(t[s]); delete t[s]; } }
    }

        /**
         * Alert or console.log a message - IF option is enabled.
         *
         * @param {(string|!Object)}	msg				Message (or debug-data) to display
         * @param {boolean=}			[popup=false]	True by default, means 'alert', false means use console.log
         * @param {boolean=}			[debug=false]	True means is a widget debugging message
         */
    , _log = function (msg, popup, debug) {
        var o = options;
        if ((o.showErrorMessages && !debug) || (debug && o.showDebugMessages))
            $.layout.msg(o.name + ' / ' + msg, (popup !== false));
        return false;
    }

        /**
         * Executes a Callback function after a trigger event, like resize, open or close
         *
         * @param {string}				evtName					Name of the layout callback, eg "onresize_start"
         * @param {(string|boolean)=}	[pane=""]				This is passed only so we can pass the 'pane object' to the callback
         * @param {(string|boolean)=}	[skipBoundEvents=false]	True = do not run events bound to the elements - only the callbacks set in options
         */
    , _runCallbacks = function (evtName, pane, skipBoundEvents) {
        var hasPane = pane && isStr(pane)
		, s = hasPane ? state[pane] : state
		, o = hasPane ? options[pane] : options
		, lName = options.name
			// names like onopen and onopen_end separate are interchangeable in options...
		, lng = evtName + (evtName.match(/_/) ? "" : "_end")
		, shrt = lng.match(/_end$/) ? lng.substr(0, lng.length - 4) : ""
		, fn = o[lng] || o[shrt]
		, retVal = "NC" // NC = No Callback
		, args = []
		, $P = hasPane ? $Ps[pane] : 0
        ;
        if (hasPane && !$P) // a pane is specified, but does not exist!
            return retVal;
        if (!hasPane && $.type(pane) === "boolean") {
            skipBoundEvents = pane; // allow pane param to be skipped for Layout callback
            pane = "";
        }

        // first trigger the callback set in the options
        if (fn) {
            try {
                // convert function name (string) to function object
                if (isStr(fn)) {
                    if (fn.match(/,/)) {
                        // function name cannot contain a comma, 
                        // so must be a function name AND a parameter to pass
                        args = fn.split(",")
						, fn = eval(args[0]);
                    }
                    else // just the name of an external function?
                        fn = eval(fn);
                }
                // execute the callback, if exists
                if ($.isFunction(fn)) {
                    if (args.length)
                        retVal = g(fn)(args[1]); // pass the argument parsed from 'list'
                    else if (hasPane)
                        // pass data: pane-name, pane-element, pane-state, pane-options, and layout-name
                        retVal = g(fn)(pane, $Ps[pane], s, o, lName);
                    else // must be a layout/container callback - pass suitable info
                        retVal = g(fn)(Instance, s, o, lName);
                }
            }
            catch (ex) {
                _log(options.errors.callbackError.replace(/EVENT/, $.trim((pane || "") + " " + lng)), false);
                if ($.type(ex) === "string" && string.length)
                    _log("Exception:  " + ex, false);
            }
        }

        // trigger additional events bound directly to the pane
        if (!skipBoundEvents && retVal !== false) {
            if (hasPane) { // PANE events can be bound to each pane-elements
                o = options[pane];
                s = state[pane];
                $P.triggerHandler("layoutpane" + lng, [pane, $P, s, o, lName]);
                if (shrt)
                    $P.triggerHandler("layoutpane" + shrt, [pane, $P, s, o, lName]);
            }
            else { // LAYOUT events can be bound to the container-element
                $N.triggerHandler("layout" + lng, [Instance, s, o, lName]);
                if (shrt)
                    $N.triggerHandler("layout" + shrt, [Instance, s, o, lName]);
            }
        }

        // ALWAYS resizeChildren after an onresize_end event - even during initialization
        // IGNORE onsizecontent_end event because causes child-layouts to resize TWICE
        if (hasPane && evtName === "onresize_end") // BAD: || evtName === "onsizecontent_end"
            resizeChildren(pane + "", true); // compiler hack -force string

        return retVal;

        function g(f) { return f; }; // compiler hack
    }


        /**
         * cure iframe display issues in IE & other browsers
         */
    , _fixIframe = function (pane) {
        if (browser.mozilla) return; // skip FireFox - it auto-refreshes iframes onShow
        var $P = $Ps[pane];
        // if the 'pane' is an iframe, do it
        if (state[pane].tagName === "IFRAME")
            $P.css(_c.hidden).css(_c.visible);
        else // ditto for any iframes INSIDE the pane
            $P.find('IFRAME').css(_c.hidden).css(_c.visible);
    }

        /**
         * @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
         * @param  {number=}		outerSize	(optional) Can pass a width, allowing calculations BEFORE element is resized
         * @return {number}		Returns the innerHeight/Width of el by subtracting padding and borders
         */
    , cssSize = function (pane, outerSize) {
        var fn = _c[pane].dir == "horz" ? cssH : cssW;
        return fn($Ps[pane], outerSize);
    }

        /**
         * @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
         * @return {Object}		Returns hash of minWidth & minHeight
         */
    , cssMinDims = function (pane) {
        // minWidth/Height means CSS width/height = 1px
        var $P = $Ps[pane]
		, dir = _c[pane].dir
		, d = {
		    minWidth: 1001 - cssW($P, 1000)
			, minHeight: 1001 - cssH($P, 1000)
		}
        ;
        if (dir === "horz") d.minSize = d.minHeight;
        if (dir === "vert") d.minSize = d.minWidth;
        return d;
    }

        // TODO: see if these methods can be made more useful...
        // TODO: *maybe* return cssW/H from these so caller can use this info

        /**
         * @param {(string|!Object)}		el
         * @param {number=}				outerWidth
         * @param {boolean=}				[autoHide=false]
         */
    , setOuterWidth = function (el, outerWidth, autoHide) {
        var $E = el, w;
        if (isStr(el)) $E = $Ps[el]; // west
        else if (!el.jquery) $E = $(el);
        w = cssW($E, outerWidth);
        $E.css({ width: w });
        if (w > 0) {
            if (autoHide && $E.data('autoHidden') && $E.innerHeight() > 0) {
                $E.show().data('autoHidden', false);
                if (!browser.mozilla) // FireFox refreshes iframes - IE does not
                    // make hidden, then visible to 'refresh' display after animation
                    $E.css(_c.hidden).css(_c.visible);
            }
        }
        else if (autoHide && !$E.data('autoHidden'))
            $E.hide().data('autoHidden', true);
    }

        /**
         * @param {(string|!Object)}		el
         * @param {number=}				outerHeight
         * @param {boolean=}				[autoHide=false]
         */
    , setOuterHeight = function (el, outerHeight, autoHide) {
        var $E = el, h;
        if (isStr(el)) $E = $Ps[el]; // west
        else if (!el.jquery) $E = $(el);
        h = cssH($E, outerHeight);
        $E.css({ height: h, visibility: "visible" }); // may have been 'hidden' by sizeContent
        if (h > 0 && $E.innerWidth() > 0) {
            if (autoHide && $E.data('autoHidden')) {
                $E.show().data('autoHidden', false);
                if (!browser.mozilla) // FireFox refreshes iframes - IE does not
                    $E.css(_c.hidden).css(_c.visible);
            }
        }
        else if (autoHide && !$E.data('autoHidden'))
            $E.hide().data('autoHidden', true);
    }


        /**
         * Converts any 'size' params to a pixel/integer size, if not already
         * If 'auto' or a decimal/percentage is passed as 'size', a pixel-size is calculated
         *
        /**
         * @param  {string}				pane
         * @param  {(string|number)=}	size
         * @param  {string=}				[dir]
         * @return {number}
         */
    , _parseSize = function (pane, size, dir) {
        if (!dir) dir = _c[pane].dir;

        if (isStr(size) && size.match(/%/))
            size = (size === '100%') ? -1 : parseInt(size, 10) / 100; // convert % to decimal

        if (size === 0)
            return 0;
        else if (size >= 1)
            return parseInt(size, 10);

        var o = options, avail = 0;
        if (dir == "horz") // north or south or center.minHeight
            avail = sC.innerHeight - ($Ps.north ? o.north.spacing_open : 0) - ($Ps.south ? o.south.spacing_open : 0);
        else if (dir == "vert") // east or west or center.minWidth
            avail = sC.innerWidth - ($Ps.west ? o.west.spacing_open : 0) - ($Ps.east ? o.east.spacing_open : 0);

        if (size === -1) // -1 == 100%
            return avail;
        else if (size > 0) // percentage, eg: .25
            return round(avail * size);
        else if (pane == "center")
            return 0;
        else { // size < 0 || size=='auto' || size==Missing || size==Invalid
            // auto-size the pane
            var dim = (dir === "horz" ? "height" : "width")
			, $P = $Ps[pane]
			, $C = dim === 'height' ? $Cs[pane] : false
			, vis = $.layout.showInvisibly($P) // show pane invisibly if hidden
			, szP = $P.css(dim) // SAVE current pane size
			, szC = $C ? $C.css(dim) : 0 // SAVE current content size
            ;
            $P.css(dim, "auto");
            if ($C) $C.css(dim, "auto");
            size = (dim === "height") ? $P.outerHeight() : $P.outerWidth(); // MEASURE
            $P.css(dim, szP).css(vis); // RESET size & visibility
            if ($C) $C.css(dim, szC);
            return size;
        }
    }

        /**
         * Calculates current 'size' (outer-width or outer-height) of a border-pane - optionally with 'pane-spacing' added
         *
         * @param  {(string|!Object)}	pane
         * @param  {boolean=}			[inclSpace=false]
         * @return {number}				Returns EITHER Width for east/west panes OR Height for north/south panes
         */
    , getPaneSize = function (pane, inclSpace) {
        var
			$P = $Ps[pane]
		, o = options[pane]
		, s = state[pane]
		, oSp = (inclSpace ? o.spacing_open : 0)
		, cSp = (inclSpace ? o.spacing_closed : 0)
        ;
        if (!$P || s.isHidden)
            return 0;
        else if (s.isClosed || (s.isSliding && inclSpace))
            return cSp;
        else if (_c[pane].dir === "horz")
            return $P.outerHeight() + oSp;
        else // dir === "vert"
            return $P.outerWidth() + oSp;
    }

        /**
         * Calculate min/max pane dimensions and limits for resizing
         *
         * @param  {string}		pane
         * @param  {boolean=}	[slide=false]
         */
    , setSizeLimits = function (pane, slide) {
        if (!isInitialized()) return;
        var
			o = options[pane]
		, s = state[pane]
		, c = _c[pane]
		, dir = c.dir
		, type = c.sizeType.toLowerCase()
		, isSliding = (slide != undefined ? slide : s.isSliding) // only open() passes 'slide' param
		, $P = $Ps[pane]
		, paneSpacing = o.spacing_open
		//	measure the pane on the *opposite side* from this pane
		, altPane = _c.oppositeEdge[pane]
		, altS = state[altPane]
		, $altP = $Ps[altPane]
		, altPaneSize = (!$altP || altS.isVisible === false || altS.isSliding ? 0 : (dir == "horz" ? $altP.outerHeight() : $altP.outerWidth()))
		, altPaneSpacing = ((!$altP || altS.isHidden ? 0 : options[altPane][altS.isClosed !== false ? "spacing_closed" : "spacing_open"]) || 0)
		//	limitSize prevents this pane from 'overlapping' opposite pane
		, containerSize = (dir == "horz" ? sC.innerHeight : sC.innerWidth)
		, minCenterDims = cssMinDims("center")
		, minCenterSize = dir == "horz" ? max(options.center.minHeight, minCenterDims.minHeight) : max(options.center.minWidth, minCenterDims.minWidth)
		//	if pane is 'sliding', then ignore center and alt-pane sizes - because 'overlays' them
		, limitSize = (containerSize - paneSpacing - (isSliding ? 0 : (_parseSize("center", minCenterSize, dir) + altPaneSize + altPaneSpacing)))
		, minSize = s.minSize = max(_parseSize(pane, o.minSize), cssMinDims(pane).minSize)
		, maxSize = s.maxSize = min((o.maxSize ? _parseSize(pane, o.maxSize) : 100000), limitSize)
		, r = s.resizerPosition = {} // used to set resizing limits
		, top = sC.inset.top
		, left = sC.inset.left
		, W = sC.innerWidth
		, H = sC.innerHeight
		, rW = o.spacing_open // subtract resizer-width to get top/left position for south/east
        ;
        switch (pane) {
            case "north": r.min = top + minSize;
                r.max = top + maxSize;
                break;
            case "west": r.min = left + minSize;
                r.max = left + maxSize;
                break;
            case "south": r.min = top + H - maxSize - rW;
                r.max = top + H - minSize - rW;
                break;
            case "east": r.min = left + W - maxSize - rW;
                r.max = left + W - minSize - rW;
                break;
        };
    }

        /**
         * Returns data for setting the size/position of center pane. Also used to set Height for east/west panes
         *
         * @return JSON  Returns a hash of all dimensions: top, bottom, left, right, (outer) width and (outer) height
         */
    , calcNewCenterPaneDims = function () {
        var d = {
            top: getPaneSize("north", true) // true = include 'spacing' value for pane
		, bottom: getPaneSize("south", true)
		, left: getPaneSize("west", true)
		, right: getPaneSize("east", true)
		, width: 0
		, height: 0
        };

        // NOTE: sC = state.container
        // calc center-pane outer dimensions
        d.width = sC.innerWidth - d.left - d.right;  // outerWidth
        d.height = sC.innerHeight - d.bottom - d.top; // outerHeight
        // add the 'container border/padding' to get final positions relative to the container
        d.top += sC.inset.top;
        d.bottom += sC.inset.bottom;
        d.left += sC.inset.left;
        d.right += sC.inset.right;

        return d;
    }


        /**
         * @param {!Object}		el
         * @param {boolean=}		[allStates=false]
         */
    , getHoverClasses = function (el, allStates) {
        var
			$El = $(el)
		, type = $El.data("layoutRole")
		, pane = $El.data("layoutEdge")
		, o = options[pane]
		, root = o[type + "Class"]
		, _pane = "-" + pane // eg: "-west"
		, _open = "-open"
		, _closed = "-closed"
		, _slide = "-sliding"
		, _hover = "-hover " // NOTE the trailing space
		, _state = $El.hasClass(root + _closed) ? _closed : _open
		, _alt = _state === _closed ? _open : _closed
		, classes = (root + _hover) + (root + _pane + _hover) + (root + _state + _hover) + (root + _pane + _state + _hover)
        ;
        if (allStates) // when 'removing' classes, also remove alternate-state classes
            classes += (root + _alt + _hover) + (root + _pane + _alt + _hover);

        if (type == "resizer" && $El.hasClass(root + _slide))
            classes += (root + _slide + _hover) + (root + _pane + _slide + _hover);

        return $.trim(classes);
    }
    , addHover = function (evt, el) {
        var $E = $(el || this);
        if (evt && $E.data("layoutRole") === "toggler")
            evt.stopPropagation(); // prevent triggering 'slide' on Resizer-bar
        $E.addClass(getHoverClasses($E));
    }
    , removeHover = function (evt, el) {
        var $E = $(el || this);
        $E.removeClass(getHoverClasses($E, true));
    }

    , onResizerEnter = function (evt) { // ALSO called by toggler.mouseenter
        var pane = $(this).data("layoutEdge")
		, s = state[pane]
		, $d = $(document)
        ;
        // ignore closed-panes and mouse moving back & forth over resizer!
        // also ignore if ANY pane is currently resizing
        if (s.isResizing || state.paneResizing) return;

        if (options.maskPanesEarly)
            showMasks(pane, { resizing: true });
    }
    , onResizerLeave = function (evt, el) {
        var e = el || this // el is only passed when called by the timer
		, pane = $(e).data("layoutEdge")
		, name = pane + "ResizerLeave"
		, $d = $(document)
        ;
        timer.clear(pane + "_openSlider"); // cancel slideOpen timer, if set
        timer.clear(name); // cancel enableSelection timer - may re/set below
        // this method calls itself on a timer because it needs to allow
        // enough time for dragging to kick-in and set the isResizing flag
        // dragging has a 100ms delay set, so this delay must be >100
        if (!el) // 1st call - mouseleave event
            timer.set(name, function () { onResizerLeave(evt, e); }, 200);
            // if user is resizing, dragStop will reset everything, so skip it here
        else if (options.maskPanesEarly && !state.paneResizing) // 2nd call - by timer
            hideMasks();
    }

    /*
     * ###########################
     *   INITIALIZATION METHODS
     * ###########################
     */

        /**
         * Initialize the layout - called automatically whenever an instance of layout is created
         *
         * @see  none - triggered onInit
         * @return  mixed	true = fully initialized | false = panes not initialized (yet) | 'cancel' = abort
         */
    , _create = function () {
        // initialize config/options
        initOptions();
        var o = options
		, s = state;

        // TEMP state so isInitialized returns true during init process
        s.creatingLayout = true;

        // init plugins for this layout, if there are any (eg: stateManagement)
        runPluginCallbacks(Instance, $.layout.onCreate);

        // options & state have been initialized, so now run beforeLoad callback
        // onload will CANCEL layout creation if it returns false
        if (false === _runCallbacks("onload_start"))
            return 'cancel';

        // initialize the container element
        _initContainer();

        // bind hotkey function - keyDown - if required
        initHotkeys();

        // bind window.onunload
        $(window).bind("unload." + sID, unload);

        // init plugins for this layout, if there are any (eg: customButtons)
        runPluginCallbacks(Instance, $.layout.onLoad);

        // if layout elements are hidden, then layout WILL NOT complete initialization!
        // initLayoutElements will set initialized=true and run the onload callback IF successful
        if (o.initPanes) _initLayoutElements();

        delete s.creatingLayout;

        return state.initialized;
    }

        /**
         * Initialize the layout IF not already
         *
         * @see  All methods in Instance run this test
         * @return  boolean	true = layoutElements have been initialized | false = panes are not initialized (yet)
         */
    , isInitialized = function () {
        if (state.initialized || state.creatingLayout) return true;	// already initialized
        else return _initLayoutElements();	// try to init panes NOW
    }

        /**
         * Initialize the layout - called automatically whenever an instance of layout is created
         *
         * @see  _create() & isInitialized
         * @param {boolean=}		[retry=false]	// indicates this is a 2nd try
         * @return  An object pointer to the instance created
         */
    , _initLayoutElements = function (retry) {
        // initialize config/options
        var o = options;
        // CANNOT init panes inside a hidden container!
        if (!$N.is(":visible")) {
            // handle Chrome bug where popup window 'has no height'
            // if layout is BODY element, try again in 50ms
            // SEE: http://layout.jquery-dev.com/samples/test_popup_window.html
            if (!retry && browser.webkit && $N[0].tagName === "BODY")
                setTimeout(function () { _initLayoutElements(true); }, 50);
            return false;
        }

        // a center pane is required, so make sure it exists
        if (!getPane("center").length) {
            return _log(o.errors.centerPaneMissing);
        }

        // TEMP state so isInitialized returns true during init process
        state.creatingLayout = true;

        // update Container dims
        $.extend(sC, elDims($N, o.inset)); // passing inset means DO NOT include insetX values

        // initialize all layout elements
        initPanes();	// size & position panes - calls initHandles() - which calls initResizable()

        if (o.scrollToBookmarkOnLoad) {
            var l = self.location;
            if (l.hash) l.replace(l.hash); // scrollTo Bookmark
        }

        // check to see if this layout 'nested' inside a pane
        if (Instance.hasParentLayout)
            o.resizeWithWindow = false;
            // bind resizeAll() for 'this layout instance' to window.resize event
        else if (o.resizeWithWindow)
            $(window).bind("resize." + sID, windowResize);

        delete state.creatingLayout;
        state.initialized = true;

        // init plugins for this layout, if there are any
        runPluginCallbacks(Instance, $.layout.onReady);

        // now run the onload callback, if exists
        _runCallbacks("onload_end");

        return true; // elements initialized successfully
    }

        /**
         * Initialize nested layouts for a specific pane - can optionally pass layout-options
         *
         * @param {(string|Object)}	evt_or_pane	The pane being opened, ie: north, south, east, or west
         * @param {Object=}			[opts]		Layout-options - if passed, will OVERRRIDE options[pane].children
         * @return  An object pointer to the layout instance created - or null
         */
    , createChildren = function (evt_or_pane, opts) {
        var pane = evtPane.call(this, evt_or_pane)
		, $P = $Ps[pane]
        ;
        if (!$P) return;
        var $C = $Cs[pane]
		, s = state[pane]
		, o = options[pane]
		, sm = options.stateManagement || {}
		, cos = opts ? (o.children = opts) : o.children
        ;
        if ($.isPlainObject(cos))
            cos = [cos]; // convert a hash to a 1-elem array
        else if (!cos || !$.isArray(cos))
            return;

        $.each(cos, function (idx, co) {
            if (!$.isPlainObject(co)) return;

            // determine which element is supposed to be the 'child container'
            // if pane has a 'containerSelector' OR a 'content-div', use those instead of the pane
            var $containers = co.containerSelector ? $P.find(co.containerSelector) : ($C || $P);

            $containers.each(function () {
                var $cont = $(this)
				, child = $cont.data("layout") //	see if a child-layout ALREADY exists on this element
                ;
                // if no layout exists, but children are set, try to create the layout now
                if (!child) {
                    // TODO: see about moving this to the stateManagement plugin, as a method
                    // set a unique child-instance key for this layout, if not already set
                    setInstanceKey({ container: $cont, options: co }, s);
                    // If THIS layout has a hash in stateManagement.autoLoad,
                    // then see if it also contains state-data for this child-layout
                    // If so, copy the stateData to child.options.stateManagement.autoLoad
                    if (sm.includeChildren && state.stateData[pane]) {
                        //	THIS layout's state was cached when its state was loaded
                        var paneChildren = state.stateData[pane].children || {}
						, childState = paneChildren[co.instanceKey]
						, co_sm = co.stateManagement || (co.stateManagement = { autoLoad: true })
                        ;
                        // COPY the stateData into the autoLoad key
                        if (co_sm.autoLoad === true && childState) {
                            co_sm.autoSave = false; // disable autoSave because saving handled by parent-layout
                            co_sm.includeChildren = true;  // cascade option - FOR NOW
                            co_sm.autoLoad = $.extend(true, {}, childState); // COPY the state-hash
                        }
                    }

                    // create the layout
                    child = $cont.layout(co);

                    // if successful, update data
                    if (child) {
                        // add the child and update all layout-pointers
                        // MAY have already been done by child-layout calling parent.refreshChildren()
                        refreshChildren(pane, child);
                    }
                }
            });
        });
    }

    , setInstanceKey = function (child, parentPaneState) {
        // create a named key for use in state and instance branches
        var $c = child.container
		, o = child.options
		, sm = o.stateManagement
		, key = o.instanceKey || $c.data("layoutInstanceKey")
        ;
        if (!key) key = (sm && sm.cookie ? sm.cookie.name : '') || o.name; // look for a name/key
        if (!key) key = "layout" + (++parentPaneState.childIdx);	// if no name/key found, generate one
        else key = key.replace(/[^\w-]/gi, '_').replace(/_{2,}/g, '_');	 // ensure is valid as a hash key
        o.instanceKey = key;
        $c.data("layoutInstanceKey", key); // useful if layout is destroyed and then recreated
        return key;
    }

        /**
         * @param {string}		pane		The pane being opened, ie: north, south, east, or west
         * @param {Object=}		newChild	New child-layout Instance to add to this pane
         */
    , refreshChildren = function (pane, newChild) {
        var $P = $Ps[pane]
		, pC = children[pane]
		, s = state[pane]
		, o
        ;
        // check for destroy()ed layouts and update the child pointers & arrays
        if ($.isPlainObject(pC)) {
            $.each(pC, function (key, child) {
                if (child.destroyed) delete pC[key]
            });
            // if no more children, remove the children hash
            if ($.isEmptyObject(pC))
                pC = children[pane] = null; // clear children hash
        }

        // see if there is a directly-nested layout inside this pane
        // if there is, then there can be only ONE child-layout, so check that...
        if (!newChild && !pC) {
            newChild = $P.data("layout");
        }

        // if a newChild instance was passed, add it to children[pane]
        if (newChild) {
            // update child.state
            newChild.hasParentLayout = true; // set parent-flag in child
            // instanceKey is a key-name used in both state and children
            o = newChild.options;
            // set a unique child-instance key for this layout, if not already set
            setInstanceKey(newChild, s);
            // add pointer to pane.children hash
            if (!pC) pC = children[pane] = {}; // create an empty children hash
            pC[o.instanceKey] = newChild.container.data("layout"); // add childLayout instance
        }

        // ALWAYS refresh the pane.children alias, even if null
        Instance[pane].children = children[pane];

        // if newChild was NOT passed - see if there is a child layout NOW
        if (!newChild) {
            createChildren(pane); // MAY create a child and re-call this method
        }
    }

    , windowResize = function () {
        var o = options
		, delay = Number(o.resizeWithWindowDelay);
        if (delay < 10) delay = 100; // MUST have a delay!
        // resizing uses a delay-loop because the resize event fires repeatly - except in FF, but delay anyway
        timer.clear("winResize"); // if already running
        timer.set("winResize", function () {
            timer.clear("winResize");
            timer.clear("winResizeRepeater");
            var dims = elDims($N, o.inset);
            // only trigger resizeAll() if container has changed size
            if (dims.innerWidth !== sC.innerWidth || dims.innerHeight !== sC.innerHeight)
                resizeAll();
        }, delay);
        // ALSO set fixed-delay timer, if not already running
        if (!timer.data["winResizeRepeater"]) setWindowResizeRepeater();
    }

    , setWindowResizeRepeater = function () {
        var delay = Number(options.resizeWithWindowMaxDelay);
        if (delay > 0)
            timer.set("winResizeRepeater", function () { setWindowResizeRepeater(); resizeAll(); }, delay);
    }

    , unload = function () {
        var o = options;

        _runCallbacks("onunload_start");

        // trigger plugin callabacks for this layout (eg: stateManagement)
        runPluginCallbacks(Instance, $.layout.onUnload);

        _runCallbacks("onunload_end");
    }

        /**
         * Validate and initialize container CSS and events
         *
         * @see  _create()
         */
    , _initContainer = function () {
        var
			N = $N[0]
		, $H = $("html")
		, tag = sC.tagName = N.tagName
		, id = sC.id = N.id
		, cls = sC.className = N.className
		, o = options
		, name = o.name
		, props = "position,margin,padding,border"
		, css = "layoutCSS"
		, CSS = {}
		, hid = "hidden" // used A LOT!
		//	see if this container is a 'pane' inside an outer-layout
		, parent = $N.data("parentLayout")	// parent-layout Instance
		, pane = $N.data("layoutEdge")		// pane-name in parent-layout
		, isChild = parent && pane
		, num = $.layout.cssNum
		, $parent, n
        ;
        // sC = state.container
        sC.selector = $N.selector.split(".slice")[0];
        sC.ref = (o.name ? o.name + ' layout / ' : '') + tag + (id ? "#" + id : cls ? '.[' + cls + ']' : ''); // used in messages
        sC.isBody = (tag === "BODY");

        // try to find a parent-layout
        if (!isChild && !sC.isBody) {
            $parent = $N.closest("." + $.layout.defaults.panes.paneClass);
            parent = $parent.data("parentLayout");
            pane = $parent.data("layoutEdge");
            isChild = parent && pane;
        }

        $N.data({
            layout: Instance
			, layoutContainer: sID // FLAG to indicate this is a layout-container - contains unique internal ID
        })
			.addClass(o.containerClass)
        ;
        var layoutMethods = {
            destroy: ''
		, initPanes: ''
		, resizeAll: 'resizeAll'
		, resize: 'resizeAll'
        };
        // loop hash and bind all methods - include layoutID namespacing
        for (name in layoutMethods) {
            $N.bind("layout" + name.toLowerCase() + "." + sID, Instance[layoutMethods[name] || name]);
        }

        // if this container is another layout's 'pane', then set child/parent pointers
        if (isChild) {
            // update parent flag
            Instance.hasParentLayout = true;
            // set pointers to THIS child-layout (Instance) in parent-layout
            parent.refreshChildren(pane, Instance);
        }

        // SAVE original container CSS for use in destroy()
        if (!$N.data(css)) {
            // handle props like overflow different for BODY & HTML - has 'system default' values
            if (sC.isBody) {
                // SAVE <BODY> CSS
                $N.data(css, $.extend(styles($N, props), {
                    height: $N.css("height")
				, overflow: $N.css("overflow")
				, overflowX: $N.css("overflowX")
				, overflowY: $N.css("overflowY")
                }));
                // ALSO SAVE <HTML> CSS
                $H.data(css, $.extend(styles($H, 'padding'), {
                    height: "auto" // FF would return a fixed px-size!
				, overflow: $H.css("overflow")
				, overflowX: $H.css("overflowX")
				, overflowY: $H.css("overflowY")
                }));
            }
            else // handle props normally for non-body elements
                $N.data(css, styles($N, props + ",top,bottom,left,right,width,height,overflow,overflowX,overflowY"));
        }

        try {
            // common container CSS
            CSS = {
                overflow: hid
			, overflowX: hid
			, overflowY: hid
            };
            $N.css(CSS);

            if (o.inset && !$.isPlainObject(o.inset)) {
                // can specify a single number for equal outset all-around
                n = parseInt(o.inset, 10) || 0
                o.inset = {
                    top: n
				, bottom: n
				, left: n
				, right: n
                };
            }

            // format html & body if this is a full page layout
            if (sC.isBody) {
                // if HTML has padding, use this as an outer-spacing around BODY
                if (!o.outset) {
                    // use padding from parent-elem (HTML) as outset
                    o.outset = {
                        top: num($H, "paddingTop")
					, bottom: num($H, "paddingBottom")
					, left: num($H, "paddingLeft")
					, right: num($H, "paddingRight")
                    };
                }
                else if (!$.isPlainObject(o.outset)) {
                    // can specify a single number for equal outset all-around
                    n = parseInt(o.outset, 10) || 0
                    o.outset = {
                        top: n
					, bottom: n
					, left: n
					, right: n
                    };
                }
                // HTML
                $H.css(CSS).css({
                    height: "100%"
				, border: "none"	// no border or padding allowed when using height = 100%
				, padding: 0		// ditto
				, margin: 0
                });
                // BODY
                if (browser.isIE6) {
                    // IE6 CANNOT use the trick of setting absolute positioning on all 4 sides - must have 'height'
                    $N.css({
                        width: "100%"
					, height: "100%"
					, border: "none"	// no border or padding allowed when using height = 100%
					, padding: 0		// ditto
					, margin: 0
					, position: "relative"
                    });
                    // convert body padding to an inset option - the border cannot be measured in IE6!
                    if (!o.inset) o.inset = elDims($N).inset;
                }
                else { // use absolute positioning for BODY to allow borders & padding without overflow
                    $N.css({
                        width: "auto"
					, height: "auto"
					, margin: 0
					, position: "absolute"	// allows for border and padding on BODY
                    });
                    // apply edge-positioning created above
                    $N.css(o.outset);
                }
                // set current layout-container dimensions
                $.extend(sC, elDims($N, o.inset)); // passing inset means DO NOT include insetX values
            }
            else {
                // container MUST have 'position'
                var p = $N.css("position");
                if (!p || !p.match(/(fixed|absolute|relative)/))
                    $N.css("position", "relative");

                // set current layout-container dimensions
                if ($N.is(":visible")) {
                    $.extend(sC, elDims($N, o.inset)); // passing inset means DO NOT change insetX (padding) values
                    if (sC.innerHeight < 1) // container has no 'height' - warn developer
                        _log(o.errors.noContainerHeight.replace(/CONTAINER/, sC.ref));
                }
            }

            // if container has min-width/height, then enable scrollbar(s)
            if (num($N, "minWidth")) $N.parent().css("overflowX", "auto");
            if (num($N, "minHeight")) $N.parent().css("overflowY", "auto");

        } catch (ex) { }
    }

        /**
         * Bind layout hotkeys - if options enabled
         *
         * @see  _create() and addPane()
         * @param {string=}	[panes=""]	The edge(s) to process
         */
    , initHotkeys = function (panes) {
        panes = panes ? panes.split(",") : _c.borderPanes;
        // bind keyDown to capture hotkeys, if option enabled for ANY pane
        $.each(panes, function (i, pane) {
            var o = options[pane];
            if (o.enableCursorHotkey || o.customHotkey) {
                $(document).bind("keydown." + sID, keyDown); // only need to bind this ONCE
                return false; // BREAK - binding was done
            }
        });
    }

        /**
         * Build final OPTIONS data
         *
         * @see  _create()
         */
    , initOptions = function () {
        var data, d, pane, key, val, i, c, o;

        // reprocess user's layout-options to have correct options sub-key structure
        opts = $.layout.transformData(opts, true); // panes = default subkey

        // auto-rename old options for backward compatibility
        opts = $.layout.backwardCompatibility.renameAllOptions(opts);

        // if user-options has 'panes' key (pane-defaults), clean it...
        if (!$.isEmptyObject(opts.panes)) {
            // REMOVE any pane-defaults that MUST be set per-pane
            data = $.layout.optionsMap.noDefault;
            for (i = 0, c = data.length; i < c; i++) {
                key = data[i];
                delete opts.panes[key]; // OK if does not exist
            }
            // REMOVE any layout-options specified under opts.panes
            data = $.layout.optionsMap.layout;
            for (i = 0, c = data.length; i < c; i++) {
                key = data[i];
                delete opts.panes[key]; // OK if does not exist
            }
        }

        // MOVE any NON-layout-options from opts-root to opts.panes
        data = $.layout.optionsMap.layout;
        var rootKeys = $.layout.config.optionRootKeys;
        for (key in opts) {
            val = opts[key];
            if ($.inArray(key, rootKeys) < 0 && $.inArray(key, data) < 0) {
                if (!opts.panes[key])
                    opts.panes[key] = $.isPlainObject(val) ? $.extend(true, {}, val) : val;
                delete opts[key]
            }
        }

        // START by updating ALL options from opts
        $.extend(true, options, opts);

        // CREATE final options (and config) for EACH pane
        $.each(_c.allPanes, function (i, pane) {

            // apply 'pane-defaults' to CONFIG.[PANE]
            _c[pane] = $.extend(true, {}, _c.panes, _c[pane]);

            d = options.panes;
            o = options[pane];

            // center-pane uses SOME keys in defaults.panes branch
            if (pane === 'center') {
                // ONLY copy keys from opts.panes listed in: $.layout.optionsMap.center
                data = $.layout.optionsMap.center;		// list of 'center-pane keys'
                for (i = 0, c = data.length; i < c; i++) {	// loop the list...
                    key = data[i];
                    // only need to use pane-default if pane-specific value not set
                    if (!opts.center[key] && (opts.panes[key] || !o[key]))
                        o[key] = d[key]; // pane-default
                }
            }
            else {
                // border-panes use ALL keys in defaults.panes branch
                o = options[pane] = $.extend(true, {}, d, o); // re-apply pane-specific opts AFTER pane-defaults
                createFxOptions(pane);
                // ensure all border-pane-specific base-classes exist
                if (!o.resizerClass) o.resizerClass = "ui-layout-resizer";
                if (!o.togglerClass) o.togglerClass = "ui-layout-toggler";
            }
            // ensure we have base pane-class (ALL panes)
            if (!o.paneClass) o.paneClass = "ui-layout-pane";
        });

        // update options.zIndexes if a zIndex-option specified
        var zo = opts.zIndex
		, z = options.zIndexes;
        if (zo > 0) {
            z.pane_normal = zo;
            z.content_mask = max(zo + 1, z.content_mask);	// MIN = +1
            z.resizer_normal = max(zo + 2, z.resizer_normal);	// MIN = +2
        }

        // DELETE 'panes' key now that we are done - values were copied to EACH pane
        delete options.panes;


        function createFxOptions(pane) {
            var o = options[pane]
			, d = options.panes;
            // ensure fxSettings key to avoid errors
            if (!o.fxSettings) o.fxSettings = {};
            if (!d.fxSettings) d.fxSettings = {};

            $.each(["_open", "_close", "_size"], function (i, n) {
                var
					sName = "fxName" + n
				, sSpeed = "fxSpeed" + n
				, sSettings = "fxSettings" + n
					// recalculate fxName according to specificity rules
				, fxName = o[sName] =
						o[sName]	// options.west.fxName_open
					|| d[sName]	// options.panes.fxName_open
					|| o.fxName	// options.west.fxName
					|| d.fxName	// options.panes.fxName
					|| "none"		// MEANS $.layout.defaults.panes.fxName == "" || false || null || 0
				, fxExists = $.effects && ($.effects[fxName] || ($.effects.effect && $.effects.effect[fxName]))
                ;
                // validate fxName to ensure is valid effect - MUST have effect-config data in options.effects
                if (fxName === "none" || !options.effects[fxName] || !fxExists)
                    fxName = o[sName] = "none"; // effect not loaded OR unrecognized fxName

                // set vars for effects subkeys to simplify logic
                var fx = options.effects[fxName] || {}	// effects.slide
				, fx_all = fx.all || null				// effects.slide.all
				, fx_pane = fx[pane] || null				// effects.slide.west
                ;
                // create fxSpeed[_open|_close|_size]
                o[sSpeed] =
					o[sSpeed]				// options.west.fxSpeed_open
				|| d[sSpeed]				// options.west.fxSpeed_open
				|| o.fxSpeed				// options.west.fxSpeed
				|| d.fxSpeed				// options.panes.fxSpeed
				|| null					// DEFAULT - let fxSetting.duration control speed
                ;
                // create fxSettings[_open|_close|_size]
                o[sSettings] = $.extend(
					true
				, {}
				, fx_all					// effects.slide.all
				, fx_pane					// effects.slide.west
				, d.fxSettings			// options.panes.fxSettings
				, o.fxSettings			// options.west.fxSettings
				, d[sSettings]			// options.panes.fxSettings_open
				, o[sSettings]			// options.west.fxSettings_open
				);
            });

            // DONE creating action-specific-settings for this pane,
            // so DELETE generic options - are no longer meaningful
            delete o.fxName;
            delete o.fxSpeed;
            delete o.fxSettings;
        }
    }

        /**
         * Initialize module objects, styling, size and position for all panes
         *
         * @see  _initElements()
         * @param {string}	pane		The pane to process
         */
    , getPane = function (pane) {
        var sel = options[pane].paneSelector
        if (sel.substr(0, 1) === "#") // ID selector
            // NOTE: elements selected 'by ID' DO NOT have to be 'children'
            return $N.find(sel).eq(0);
        else { // class or other selector
            var $P = $N.children(sel).eq(0);
            // look for the pane nested inside a 'form' element
            return $P.length ? $P : $N.children("form:first").children(sel).eq(0);
        }
    }

        /**
         * @param {Object=}		evt
         */
    , initPanes = function (evt) {
        // stopPropagation if called by trigger("layoutinitpanes") - use evtPane utility 
        evtPane(evt);

        // NOTE: do north & south FIRST so we can measure their height - do center LAST
        $.each(_c.allPanes, function (idx, pane) {
            addPane(pane, true);
        });

        // init the pane-handles NOW in case we have to hide or close the pane below
        initHandles();

        // now that all panes have been initialized and initially-sized,
        // make sure there is really enough space available for each pane
        $.each(_c.borderPanes, function (i, pane) {
            if ($Ps[pane] && state[pane].isVisible) { // pane is OPEN
                setSizeLimits(pane);
                makePaneFit(pane); // pane may be Closed, Hidden or Resized by makePaneFit()
            }
        });
        // size center-pane AGAIN in case we 'closed' a border-pane in loop above
        sizeMidPanes("center");

        //	Chrome/Webkit sometimes fires callbacks BEFORE it completes resizing!
        //	Before RC30.3, there was a 10ms delay here, but that caused layout 
        //	to load asynchrously, which is BAD, so try skipping delay for now

        // process pane contents and callbacks, and init/resize child-layout if exists
        $.each(_c.allPanes, function (idx, pane) {
            afterInitPane(pane);
        });
    }

        /**
         * Add a pane to the layout - subroutine of initPanes()
         *
         * @see  initPanes()
         * @param {string}	pane			The pane to process
         * @param {boolean=}	[force=false]	Size content after init
         */
    , addPane = function (pane, force) {
        if (!force && !isInitialized()) return;
        var
			o = options[pane]
		, s = state[pane]
		, c = _c[pane]
		, dir = c.dir
		, fx = s.fx
		, spacing = o.spacing_open || 0
		, isCenter = (pane === "center")
		, CSS = {}
		, $P = $Ps[pane]
		, size, minSize, maxSize, child
        ;
        // if pane-pointer already exists, remove the old one first
        if ($P)
            removePane(pane, false, true, false);
        else
            $Cs[pane] = false; // init

        $P = $Ps[pane] = getPane(pane);
        if (!$P.length) {
            $Ps[pane] = false; // logic
            return;
        }

        // SAVE original Pane CSS
        if (!$P.data("layoutCSS")) {
            var props = "position,top,left,bottom,right,width,height,overflow,zIndex,display,backgroundColor,padding,margin,border";
            $P.data("layoutCSS", styles($P, props));
        }

        // create alias for pane data in Instance - initHandles will add more
        Instance[pane] = {
            name: pane
		, pane: $Ps[pane]
		, content: $Cs[pane]
		, options: options[pane]
		, state: state[pane]
		, children: children[pane]
        };

        // add classes, attributes & events
        $P.data({
            parentLayout: Instance		// pointer to Layout Instance
			, layoutPane: Instance[pane]	// NEW pointer to pane-alias-object
			, layoutEdge: pane
			, layoutRole: "pane"
        })
			.css(c.cssReq).css("zIndex", options.zIndexes.pane_normal)
			.css(o.applyDemoStyles ? c.cssDemo : {}) // demo styles
			.addClass(o.paneClass + " " + o.paneClass + "-" + pane) // default = "ui-layout-pane ui-layout-pane-west" - may be a dupe of 'paneSelector'
			.bind("mouseenter." + sID, addHover)
			.bind("mouseleave." + sID, removeHover)
        ;
        var paneMethods = {
            hide: ''
			, show: ''
			, toggle: ''
			, close: ''
			, open: ''
			, slideOpen: ''
			, slideClose: ''
			, slideToggle: ''
			, size: 'sizePane'
			, sizePane: 'sizePane'
			, sizeContent: ''
			, sizeHandles: ''
			, enableClosable: ''
			, disableClosable: ''
			, enableSlideable: ''
			, disableSlideable: ''
			, enableResizable: ''
			, disableResizable: ''
			, swapPanes: 'swapPanes'
			, swap: 'swapPanes'
			, move: 'swapPanes'
			, removePane: 'removePane'
			, remove: 'removePane'
			, createChildren: ''
			, resizeChildren: ''
			, resizeAll: 'resizeAll'
			, resizeLayout: 'resizeAll'
        }
		, name;
        // loop hash and bind all methods - include layoutID namespacing
        for (name in paneMethods) {
            $P.bind("layoutpane" + name.toLowerCase() + "." + sID, Instance[paneMethods[name] || name]);
        }

        // see if this pane has a 'scrolling-content element'
        initContent(pane, false); // false = do NOT sizeContent() - called later

        if (!isCenter) {
            // call _parseSize AFTER applying pane classes & styles - but before making visible (if hidden)
            // if o.size is auto or not valid, then MEASURE the pane and use that as its 'size'
            size = s.size = _parseSize(pane, o.size);
            minSize = _parseSize(pane, o.minSize) || 1;
            maxSize = _parseSize(pane, o.maxSize) || 100000;
            if (size > 0) size = max(min(size, maxSize), minSize);
            s.autoResize = o.autoResize; // used with percentage sizes

            // state for border-panes
            s.isClosed = false; // true = pane is closed
            s.isSliding = false; // true = pane is currently open by 'sliding' over adjacent panes
            s.isResizing = false; // true = pane is in process of being resized
            s.isHidden = false; // true = pane is hidden - no spacing, resizer or toggler is visible!

            // array for 'pin buttons' whose classNames are auto-updated on pane-open/-close
            if (!s.pins) s.pins = [];
        }
        //	states common to ALL panes
        s.tagName = $P[0].tagName;
        s.edge = pane;		// useful if pane is (or about to be) 'swapped' - easy find out where it is (or is going)
        s.noRoom = false;	// true = pane 'automatically' hidden due to insufficient room - will unhide automatically
        s.isVisible = true;		// false = pane is invisible - closed OR hidden - simplify logic

        // init pane positioning
        setPanePosition(pane);

        // if pane is not visible, 
        if (dir === "horz") // north or south pane
            CSS.height = cssH($P, size);
        else if (dir === "vert") // east or west pane
            CSS.width = cssW($P, size);
        //else if (isCenter) {}

        $P.css(CSS); // apply size -- top, bottom & height will be set by sizeMidPanes
        if (dir != "horz") sizeMidPanes(pane, true); // true = skipCallback

        // if manually adding a pane AFTER layout initialization, then...
        if (state.initialized) {
            initHandles(pane);
            initHotkeys(pane);
        }

        // close or hide the pane if specified in settings
        if (o.initClosed && o.closable && !o.initHidden)
            close(pane, true, true); // true, true = force, noAnimation
        else if (o.initHidden || o.initClosed)
            hide(pane); // will be completely invisible - no resizer or spacing
        else if (!s.noRoom)
            // make the pane visible - in case was initially hidden
            $P.css("display", "block");
        // ELSE setAsOpen() - called later by initHandles()

        // RESET visibility now - pane will appear IF display:block
        $P.css("visibility", "visible");

        // check option for auto-handling of pop-ups & drop-downs
        if (o.showOverflowOnHover)
            $P.hover(allowOverflow, resetOverflow);

        // if manually adding a pane AFTER layout initialization, then...
        if (state.initialized) {
            afterInitPane(pane);
        }
    }

    , afterInitPane = function (pane) {
        var $P = $Ps[pane]
		, s = state[pane]
		, o = options[pane]
        ;
        if (!$P) return;

        // see if there is a directly-nested layout inside this pane
        if ($P.data("layout"))
            refreshChildren(pane, $P.data("layout"));

        // process pane contents and callbacks, and init/resize child-layout if exists
        if (s.isVisible) { // pane is OPEN
            if (state.initialized) // this pane was added AFTER layout was created
                resizeAll(); // will also sizeContent
            else
                sizeContent(pane);

            if (o.triggerEventsOnLoad)
                _runCallbacks("onresize_end", pane);
            else // automatic if onresize called, otherwise call it specifically
                // resize child - IF inner-layout already exists (created before this layout)
                resizeChildren(pane, true); // a previously existing childLayout
        }

        // init childLayouts - even if pane is not visible
        if (o.initChildren && o.children)
            createChildren(pane);
    }

        /**
         * @param {string=}	panes		The pane(s) to process
         */
    , setPanePosition = function (panes) {
        panes = panes ? panes.split(",") : _c.borderPanes;

        // create toggler DIVs for each pane, and set object pointers for them, eg: $R.north = north toggler DIV
        $.each(panes, function (i, pane) {
            var $P = $Ps[pane]
			, $R = $Rs[pane]
			, o = options[pane]
			, s = state[pane]
			, side = _c[pane].side
			, CSS = {}
            ;
            if (!$P) return; // pane does not exist - skip

            // set css-position to account for container borders & padding
            switch (pane) {
                case "north": CSS.top = sC.inset.top;
                    CSS.left = sC.inset.left;
                    CSS.right = sC.inset.right;
                    break;
                case "south": CSS.bottom = sC.inset.bottom;
                    CSS.left = sC.inset.left;
                    CSS.right = sC.inset.right;
                    break;
                case "west": CSS.left = sC.inset.left; // top, bottom & height set by sizeMidPanes()
                    break;
                case "east": CSS.right = sC.inset.right; // ditto
                    break;
                case "center":	// top, left, width & height set by sizeMidPanes()
            }
            // apply position
            $P.css(CSS);

            // update resizer position
            if ($R && s.isClosed)
                $R.css(side, sC.inset[side]);
            else if ($R && !s.isHidden)
                $R.css(side, sC.inset[side] + getPaneSize(pane));
        });
    }

        /**
         * Initialize module objects, styling, size and position for all resize bars and toggler buttons
         *
         * @see  _create()
         * @param {string=}	[panes=""]	The edge(s) to process
         */
    , initHandles = function (panes) {
        panes = panes ? panes.split(",") : _c.borderPanes;

        // create toggler DIVs for each pane, and set object pointers for them, eg: $R.north = north toggler DIV
        $.each(panes, function (i, pane) {
            var $P = $Ps[pane];
            $Rs[pane] = false; // INIT
            $Ts[pane] = false;
            if (!$P) return; // pane does not exist - skip

            var o = options[pane]
			, s = state[pane]
			, c = _c[pane]
			, paneId = o.paneSelector.substr(0, 1) === "#" ? o.paneSelector.substr(1) : ""
			, rClass = o.resizerClass
			, tClass = o.togglerClass
			, spacing = (s.isVisible ? o.spacing_open : o.spacing_closed)
			, _pane = "-" + pane // used for classNames
			, _state = (s.isVisible ? "-open" : "-closed") // used for classNames
			, I = Instance[pane]
				// INIT RESIZER BAR
			, $R = I.resizer = $Rs[pane] = $("<div></div>")
				// INIT TOGGLER BUTTON
			, $T = I.toggler = (o.closable ? $Ts[pane] = $("<div></div>") : false)
            ;

            //if (s.isVisible && o.resizable) ... handled by initResizable
            if (!s.isVisible && o.slidable)
                $R.attr("title", o.tips.Slide).css("cursor", o.sliderCursor);

            $R	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "paneLeft-resizer"
				.attr("id", paneId ? paneId + "-resizer" : "")
				.data({
				    parentLayout: Instance
				, layoutPane: Instance[pane]	// NEW pointer to pane-alias-object
				, layoutEdge: pane
				, layoutRole: "resizer"
				})
				.css(_c.resizers.cssReq).css("zIndex", options.zIndexes.resizer_normal)
				.css(o.applyDemoStyles ? _c.resizers.cssDemo : {}) // add demo styles
				.addClass(rClass + " " + rClass + _pane)
				.hover(addHover, removeHover) // ALWAYS add hover-classes, even if resizing is not enabled - handle with CSS instead
				.hover(onResizerEnter, onResizerLeave) // ALWAYS NEED resizer.mouseleave to balance toggler.mouseenter
				.mousedown($.layout.disableTextSelection)	// prevent text-selection OUTSIDE resizer
				.mouseup($.layout.enableTextSelection)		// not really necessary, but just in case
				.appendTo($N) // append DIV to container
            ;
            if ($.fn.disableSelection)
                $R.disableSelection(); // prevent text-selection INSIDE resizer
            if (o.resizerDblClickToggle)
                $R.bind("dblclick." + sID, toggle);

            if ($T) {
                $T	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "#paneLeft-toggler"
					.attr("id", paneId ? paneId + "-toggler" : "")
					.data({
					    parentLayout: Instance
					, layoutPane: Instance[pane]	// NEW pointer to pane-alias-object
					, layoutEdge: pane
					, layoutRole: "toggler"
					})
					.css(_c.togglers.cssReq) // add base/required styles
					.css(o.applyDemoStyles ? _c.togglers.cssDemo : {}) // add demo styles
					.addClass(tClass + " " + tClass + _pane)
					.hover(addHover, removeHover) // ALWAYS add hover-classes, even if toggling is not enabled - handle with CSS instead
					.bind("mouseenter", onResizerEnter) // NEED toggler.mouseenter because mouseenter MAY NOT fire on resizer
					.appendTo($R) // append SPAN to resizer DIV
                ;
                // ADD INNER-SPANS TO TOGGLER
                if (o.togglerContent_open) // ui-layout-open
                    $("<span>" + o.togglerContent_open + "</span>")
						.data({
						    layoutEdge: pane
						, layoutRole: "togglerContent"
						})
						.data("layoutRole", "togglerContent")
						.data("layoutEdge", pane)
						.addClass("content content-open")
						.css("display", "none")
						.appendTo($T)
                //.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-open instead!
                ;
                if (o.togglerContent_closed) // ui-layout-closed
                    $("<span>" + o.togglerContent_closed + "</span>")
						.data({
						    layoutEdge: pane
						, layoutRole: "togglerContent"
						})
						.addClass("content content-closed")
						.css("display", "none")
						.appendTo($T)
                //.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-closed instead!
                ;
                // ADD TOGGLER.click/.hover
                enableClosable(pane);
            }

            // add Draggable events
            initResizable(pane);

            // ADD CLASSNAMES & SLIDE-BINDINGS - eg: class="resizer resizer-west resizer-open"
            if (s.isVisible)
                setAsOpen(pane);	// onOpen will be called, but NOT onResize
            else {
                setAsClosed(pane);	// onClose will be called
                bindStartSlidingEvents(pane, true); // will enable events IF option is set
            }

        });

        // SET ALL HANDLE DIMENSIONS
        sizeHandles();
    }


        /**
         * Initialize scrolling ui-layout-content div - if exists
         *
         * @see  initPane() - or externally after an Ajax injection
         * @param {string}	pane			The pane to process
         * @param {boolean=}	[resize=true]	Size content after init
         */
    , initContent = function (pane, resize) {
        if (!isInitialized()) return;
        var
			o = options[pane]
		, sel = o.contentSelector
		, I = Instance[pane]
		, $P = $Ps[pane]
		, $C
        ;
        if (sel) $C = I.content = $Cs[pane] = (o.findNestedContent)
			? $P.find(sel).eq(0) // match 1-element only
			: $P.children(sel).eq(0)
        ;
        if ($C && $C.length) {
            $C.data("layoutRole", "content");
            // SAVE original Content CSS
            if (!$C.data("layoutCSS"))
                $C.data("layoutCSS", styles($C, "height"));
            $C.css(_c.content.cssReq);
            if (o.applyDemoStyles) {
                $C.css(_c.content.cssDemo); // add padding & overflow: auto to content-div
                $P.css(_c.content.cssDemoPane); // REMOVE padding/scrolling from pane
            }
            // ensure no vertical scrollbar on pane - will mess up measurements
            if ($P.css("overflowX").match(/(scroll|auto)/)) {
                $P.css("overflow", "hidden");
            }
            state[pane].content = {}; // init content state
            if (resize !== false) sizeContent(pane);
            // sizeContent() is called AFTER init of all elements
        }
        else
            I.content = $Cs[pane] = false;
    }


        /**
         * Add resize-bars to all panes that specify it in options
         * -dependancy: $.fn.resizable - will skip if not found
         *
         * @see  _create()
         * @param {string=}	[panes=""]	The edge(s) to process
         */
    , initResizable = function (panes) {
        var draggingAvailable = $.layout.plugins.draggable
		, side // set in start()
        ;
        panes = panes ? panes.split(",") : _c.borderPanes;

        $.each(panes, function (idx, pane) {
            var o = options[pane];
            if (!draggingAvailable || !$Ps[pane] || !o.resizable) {
                o.resizable = false;
                return true; // skip to next
            }

            var s = state[pane]
			, z = options.zIndexes
			, c = _c[pane]
			, side = c.dir == "horz" ? "top" : "left"
			, $P = $Ps[pane]
			, $R = $Rs[pane]
			, base = o.resizerClass
			, lastPos = 0 // used when live-resizing
			, r, live // set in start because may change
			//	'drag' classes are applied to the ORIGINAL resizer-bar while dragging is in process
			, resizerClass = base + "-drag"				// resizer-drag
			, resizerPaneClass = base + "-" + pane + "-drag"		// resizer-north-drag
			//	'helper' class is applied to the CLONED resizer-bar while it is being dragged
			, helperClass = base + "-dragging"			// resizer-dragging
			, helperPaneClass = base + "-" + pane + "-dragging" // resizer-north-dragging
			, helperLimitClass = base + "-dragging-limit"	// resizer-drag
			, helperPaneLimitClass = base + "-" + pane + "-dragging-limit"	// resizer-north-drag
			, helperClassesSet = false 					// logic var
            ;

            if (!s.isClosed)
                $R.attr("title", o.tips.Resize)
				  .css("cursor", o.resizerCursor); // n-resize, s-resize, etc

            $R.draggable({
                containment: $N[0] // limit resizing to layout container
			, axis: (c.dir == "horz" ? "y" : "x") // limit resizing to horz or vert axis
			, delay: 0
			, distance: 1
			, grid: o.resizingGrid
                //	basic format for helper - style it using class: .ui-draggable-dragging
			, helper: "clone"
			, opacity: o.resizerDragOpacity
			, addClasses: false // avoid ui-state-disabled class when disabled
                //,	iframeFix:		o.draggableIframeFix // TODO: consider using when bug is fixed
			, zIndex: z.resizer_drag

			, start: function (e, ui) {
			    // REFRESH options & state pointers in case we used swapPanes
			    o = options[pane];
			    s = state[pane];
			    // re-read options
			    live = o.livePaneResizing;

			    // ondrag_start callback - will CANCEL hide if returns false
			    // TODO: dragging CANNOT be cancelled like this, so see if there is a way?
			    if (false === _runCallbacks("ondrag_start", pane)) return false;

			    s.isResizing = true; // prevent pane from closing while resizing
			    state.paneResizing = pane; // easy to see if ANY pane is resizing
			    timer.clear(pane + "_closeSlider"); // just in case already triggered

			    // SET RESIZER LIMITS - used in drag()
			    setSizeLimits(pane); // update pane/resizer state
			    r = s.resizerPosition;
			    lastPos = ui.position[side]

			    $R.addClass(resizerClass + " " + resizerPaneClass); // add drag classes
			    helperClassesSet = false; // reset logic var - see drag()

			    // MASK PANES CONTAINING IFRAMES, APPLETS OR OTHER TROUBLESOME ELEMENTS
			    showMasks(pane, { resizing: true });
			}

			, drag: function (e, ui) {
			    if (!helperClassesSet) { // can only add classes after clone has been added to the DOM
			        //$(".ui-draggable-dragging")
			        ui.helper
                        .addClass(helperClass + " " + helperPaneClass) // add helper classes
                        .css({ right: "auto", bottom: "auto" })	// fix dir="rtl" issue
                        .children().css("visibility", "hidden")	// hide toggler inside dragged resizer-bar
			        ;
			        helperClassesSet = true;
			        // draggable bug!? RE-SET zIndex to prevent E/W resize-bar showing through N/S pane!
			        if (s.isSliding) $Ps[pane].css("zIndex", z.pane_sliding);
			    }
			    // CONTAIN RESIZER-BAR TO RESIZING LIMITS
			    var limit = 0;
			    if (ui.position[side] < r.min) {
			        ui.position[side] = r.min;
			        limit = -1;
			    }
			    else if (ui.position[side] > r.max) {
			        ui.position[side] = r.max;
			        limit = 1;
			    }
			    // ADD/REMOVE dragging-limit CLASS
			    if (limit) {
			        ui.helper.addClass(helperLimitClass + " " + helperPaneLimitClass); // at dragging-limit
			        window.defaultStatus = (limit > 0 && pane.match(/(north|west)/)) || (limit < 0 && pane.match(/(south|east)/)) ? o.tips.maxSizeWarning : o.tips.minSizeWarning;
			    }
			    else {
			        ui.helper.removeClass(helperLimitClass + " " + helperPaneLimitClass); // not at dragging-limit
			        window.defaultStatus = "";
			    }
			    // DYNAMICALLY RESIZE PANES IF OPTION ENABLED
			    // won't trigger unless resizer has actually moved!
			    if (live && Math.abs(ui.position[side] - lastPos) >= o.liveResizingTolerance) {
			        lastPos = ui.position[side];
			        resizePanes(e, ui, pane)
			    }
			}

			, stop: function (e, ui) {
			    $('body').enableSelection(); // RE-ENABLE TEXT SELECTION
			    window.defaultStatus = ""; // clear 'resizing limit' message from statusbar
			    $R.removeClass(resizerClass + " " + resizerPaneClass); // remove drag classes from Resizer
			    s.isResizing = false;
			    state.paneResizing = false; // easy to see if ANY pane is resizing
			    resizePanes(e, ui, pane, true); // true = resizingDone
			}

            });
        });

        /**
		 * resizePanes
		 *
		 * Sub-routine called from stop() - and drag() if livePaneResizing
		 *
		 * @param {!Object}		evt
		 * @param {!Object}		ui
		 * @param {string}		pane
		 * @param {boolean=}		[resizingDone=false]
		 */
        var resizePanes = function (evt, ui, pane, resizingDone) {
            var dragPos = ui.position
			, c = _c[pane]
			, o = options[pane]
			, s = state[pane]
			, resizerPos
            ;
            switch (pane) {
                case "north": resizerPos = dragPos.top; break;
                case "west": resizerPos = dragPos.left; break;
                case "south": resizerPos = sC.layoutHeight - dragPos.top - o.spacing_open; break;
                case "east": resizerPos = sC.layoutWidth - dragPos.left - o.spacing_open; break;
            };
            // remove container margin from resizer position to get the pane size
            var newSize = resizerPos - sC.inset[c.side];

            // Disable OR Resize Mask(s) created in drag.start
            if (!resizingDone) {
                // ensure we meet liveResizingTolerance criteria
                if (Math.abs(newSize - s.size) < o.liveResizingTolerance)
                    return; // SKIP resize this time
                // resize the pane
                manualSizePane(pane, newSize, false, true); // true = noAnimation
                sizeMasks(); // resize all visible masks
            }
            else { // resizingDone
                // ondrag_end callback
                if (false !== _runCallbacks("ondrag_end", pane))
                    manualSizePane(pane, newSize, false, true); // true = noAnimation
                hideMasks(true); // true = force hiding all masks even if one is 'sliding'
                if (s.isSliding) // RE-SHOW 'object-masks' so objects won't show through sliding pane
                    showMasks(pane, { resizing: true });
            }
        };
    }

        /**
         *	sizeMask
         *
         *	Needed to overlay a DIV over an IFRAME-pane because mask CANNOT be *inside* the pane
         *	Called when mask created, and during livePaneResizing
         */
    , sizeMask = function () {
        var $M = $(this)
		, pane = $M.data("layoutMask") // eg: "west"
		, s = state[pane]
        ;
        // only masks over an IFRAME-pane need manual resizing
        if (s.tagName == "IFRAME" && s.isVisible) // no need to mask closed/hidden panes
            $M.css({
                top: s.offsetTop
			, left: s.offsetLeft
			, width: s.outerWidth
			, height: s.outerHeight
            });
        /* ALT Method...
		var $P = $Ps[pane];
		$M.css( $P.position() ).css({ width: $P[0].offsetWidth, height: $P[0].offsetHeight });
		*/
    }
    , sizeMasks = function () {
        $Ms.each(sizeMask); // resize all 'visible' masks
    }

        /**
         * @param {string}	pane		The pane being resized, animated or isSliding
         * @param {Object=}	[args]		(optional) Options: which masks to apply, and to which panes
         */
    , showMasks = function (pane, args) {
        var c = _c[pane]
		, panes = ["center"]
		, z = options.zIndexes
		, a = $.extend({
		    objectsOnly: false
					, animation: false
					, resizing: true
					, sliding: state[pane].isSliding
		}, args)
		, o, s
        ;
        if (a.resizing)
            panes.push(pane);
        if (a.sliding)
            panes.push(_c.oppositeEdge[pane]); // ADD the oppositeEdge-pane

        if (c.dir === "horz") {
            panes.push("west");
            panes.push("east");
        }

        $.each(panes, function (i, p) {
            s = state[p];
            o = options[p];
            if (s.isVisible && (o.maskObjects || (!a.objectsOnly && o.maskContents))) {
                getMasks(p).each(function () {
                    sizeMask.call(this);
                    this.style.zIndex = s.isSliding ? z.pane_sliding + 1 : z.pane_normal + 1
                    this.style.display = "block";
                });
            }
        });
    }

        /**
         * @param {boolean=}	force		Hide masks even if a pane is sliding
         */
    , hideMasks = function (force) {
        // ensure no pane is resizing - could be a timing issue
        if (force || !state.paneResizing) {
            $Ms.hide(); // hide ALL masks
        }
            // if ANY pane is sliding, then DO NOT remove masks from panes with maskObjects enabled
        else if (!force && !$.isEmptyObject(state.panesSliding)) {
            var i = $Ms.length - 1
			, p, $M;
            for (; i >= 0; i--) {
                $M = $Ms.eq(i);
                p = $M.data("layoutMask");
                if (!options[p].maskObjects) {
                    $M.hide();
                }
            }
        }
    }

        /**
         * @param {string}	pane
         */
    , getMasks = function (pane) {
        var $Masks = $([])
		, $M, i = 0, c = $Ms.length
        ;
        for (; i < c; i++) {
            $M = $Ms.eq(i);
            if ($M.data("layoutMask") === pane)
                $Masks = $Masks.add($M);
        }
        if ($Masks.length)
            return $Masks;
        else
            return createMasks(pane);
    }

        /**
         * createMasks
         *
         * Generates both DIV (ALWAYS used) and IFRAME (optional) elements as masks
         * An IFRAME mask is created *under* the DIV when maskObjects=true, because a DIV cannot mask an applet
         *
         * @param {string}	pane
         */
    , createMasks = function (pane) {
        var
			$P = $Ps[pane]
		, s = state[pane]
		, o = options[pane]
		, z = options.zIndexes
		, isIframe, el, $M, css, i
        ;
        if (!o.maskContents && !o.maskObjects) return $([]);
        // if o.maskObjects=true, then loop TWICE to create BOTH kinds of mask, else only create a DIV
        for (i = 0; i < (o.maskObjects ? 2 : 1) ; i++) {
            isIframe = o.maskObjects && i == 0;
            el = document.createElement(isIframe ? "iframe" : "div");
            $M = $(el).data("layoutMask", pane); // add data to relate mask to pane
            el.className = "ui-layout-mask ui-layout-mask-" + pane; // for user styling
            css = el.style;
            // Both DIVs and IFRAMES
            css.background = "#FFF";
            css.position = "absolute";
            css.display = "block";
            if (isIframe) { // IFRAME-only props
                el.src = "about:blank";
                el.frameborder = 0;
                css.border = 0;
                css.opacity = 0;
                css.filter = "Alpha(Opacity='0')";
                //el.allowTransparency = true; - for IE, but breaks masking ability!
            }
            else { // DIV-only props
                css.opacity = 0.001;
                css.filter = "Alpha(Opacity='1')";
            }
            // if pane IS an IFRAME, then must mask the pane itself
            if (s.tagName == "IFRAME") {
                // NOTE sizing done by a subroutine so can be called during live-resizing
                css.zIndex = z.pane_normal + 1; // 1-higher than pane
                $N.append(el); // append to LAYOUT CONTAINER
            }
                // otherwise put masks *inside the pane* to mask its contents
            else {
                $M.addClass("ui-layout-mask-inside-pane");
                css.zIndex = o.maskZindex || z.content_mask; // usually 1, but customizable
                css.top = 0;
                css.left = 0;
                css.width = "100%";
                css.height = "100%";
                $P.append(el); // append INSIDE pane element
            }
            // add Mask to cached array so can be resized & reused
            $Ms = $Ms.add(el);
        }
        return $Ms;
    }


        /**
         * Destroy this layout and reset all elements
         *
         * @param {boolean=}	[destroyChildren=false]		Destory Child-Layouts first?
         */
    , destroy = function (evt_or_destroyChildren, destroyChildren) {
        // UNBIND layout events and remove global object
        $(window).unbind("." + sID);		// resize & unload
        $(document).unbind("." + sID);	// keyDown (hotkeys)

        if (typeof evt_or_destroyChildren === "object")
            // stopPropagation if called by trigger("layoutdestroy") - use evtPane utility 
            evtPane(evt_or_destroyChildren);
        else // no event, so transfer 1st param to destroyChildren param
            destroyChildren = evt_or_destroyChildren;

        // need to look for parent layout BEFORE we remove the container data, else skips a level
        //var parentPane = Instance.hasParentLayout ? $.layout.getParentPaneInstance( $N ) : null;

        // reset layout-container
        $N.clearQueue()
			.removeData("layout")
			.removeData("layoutContainer")
			.removeClass(options.containerClass)
			.unbind("." + sID) // remove ALL Layout events
        ;

        // remove all mask elements that have been created
        $Ms.remove();

        // loop all panes to remove layout classes, attributes and bindings
        $.each(_c.allPanes, function (i, pane) {
            removePane(pane, false, true, destroyChildren); // true = skipResize
        });

        // do NOT reset container CSS if is a 'pane' (or 'content') in an outer-layout - ie, THIS layout is 'nested'
        var css = "layoutCSS";
        if ($N.data(css) && !$N.data("layoutRole")) // RESET CSS
            $N.css($N.data(css)).removeData(css);

        // for full-page layouts, also reset the <HTML> CSS
        if (sC.tagName === "BODY" && ($N = $("html")).data(css)) // RESET <HTML> CSS
            $N.css($N.data(css)).removeData(css);

        // trigger plugins for this layout, if there are any
        runPluginCallbacks(Instance, $.layout.onDestroy);

        // trigger state-management and onunload callback
        unload();

        // clear the Instance of everything except for container & options (so could recreate)
        // RE-CREATE: myLayout = myLayout.container.layout( myLayout.options );
        for (var n in Instance)
            if (!n.match(/^(container|options)$/)) delete Instance[n];
        // add a 'destroyed' flag to make it easy to check
        Instance.destroyed = true;

        // if this is a child layout, CLEAR the child-pointer in the parent
        /* for now the pointer REMAINS, but with only container, options and destroyed keys
		if (parentPane) {
			var layout	= parentPane.pane.data("parentLayout")
			,	key		= layout.options.instanceKey || 'error';
			// THIS SYNTAX MAY BE WRONG!
			parentPane.children[key] = layout.children[ parentPane.name ].children[key] = null;
		}
		*/

        return Instance; // for coding convenience
    }

        /**
         * Remove a pane from the layout - subroutine of destroy()
         *
         * @see  destroy()
         * @param {(string|Object)}	evt_or_pane			The pane to process
         * @param {boolean=}			[remove=false]		Remove the DOM element?
         * @param {boolean=}			[skipResize=false]	Skip calling resizeAll()?
         * @param {boolean=}			[destroyChild=true]	Destroy Child-layouts? If not passed, obeys options setting
         */
    , removePane = function (evt_or_pane, remove, skipResize, destroyChild) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, $P = $Ps[pane]
		, $C = $Cs[pane]
		, $R = $Rs[pane]
		, $T = $Ts[pane]
        ;
        // NOTE: elements can still exist even after remove()
        //		so check for missing data(), which is cleared by removed()
        if ($P && $.isEmptyObject($P.data())) $P = false;
        if ($C && $.isEmptyObject($C.data())) $C = false;
        if ($R && $.isEmptyObject($R.data())) $R = false;
        if ($T && $.isEmptyObject($T.data())) $T = false;

        if ($P) $P.stop(true, true);

        var o = options[pane]
		, s = state[pane]
		, d = "layout"
		, css = "layoutCSS"
		, pC = children[pane]
		, hasChildren = $.isPlainObject(pC) && !$.isEmptyObject(pC)
		, destroy = destroyChild !== undefined ? destroyChild : o.destroyChildren
        ;
        // FIRST destroy the child-layout(s)
        if (hasChildren && destroy) {
            $.each(pC, function (key, child) {
                if (!child.destroyed)
                    child.destroy(true);// tell child-layout to destroy ALL its child-layouts too
                if (child.destroyed)	// destroy was successful
                    delete pC[key];
            });
            // if no more children, remove the children hash
            if ($.isEmptyObject(pC)) {
                pC = children[pane] = null; // clear children hash
                hasChildren = false;
            }
        }

        // Note: can't 'remove' a pane element with non-destroyed children
        if ($P && remove && !hasChildren)
            $P.remove(); // remove the pane-element and everything inside it
        else if ($P && $P[0]) {
            //	create list of ALL pane-classes that need to be removed
            var root = o.paneClass // default="ui-layout-pane"
			, pRoot = root + "-" + pane // eg: "ui-layout-pane-west"
			, _open = "-open"
			, _sliding = "-sliding"
			, _closed = "-closed"
			, classes = [root, root + _open, root + _closed, root + _sliding,		// generic classes
							pRoot, pRoot + _open, pRoot + _closed, pRoot + _sliding]	// pane-specific classes
            ;
            $.merge(classes, getHoverClasses($P, true)); // ADD hover-classes
            // remove all Layout classes from pane-element
            $P.removeClass(classes.join(" ")) // remove ALL pane-classes
				.removeData("parentLayout")
				.removeData("layoutPane")
				.removeData("layoutRole")
				.removeData("layoutEdge")
				.removeData("autoHidden")	// in case set
				.unbind("." + sID) // remove ALL Layout events
            // TODO: remove these extra unbind commands when jQuery is fixed
            //.unbind("mouseenter"+ sID)
            //.unbind("mouseleave"+ sID)
            ;
            // do NOT reset CSS if this pane/content is STILL the container of a nested layout!
            // the nested layout will reset its 'container' CSS when/if it is destroyed
            if (hasChildren && $C) {
                // a content-div may not have a specific width, so give it one to contain the Layout
                $C.width($C.width());
                $.each(pC, function (key, child) {
                    child.resizeAll(); // resize the Layout
                });
            }
            else if ($C)
                $C.css($C.data(css)).removeData(css).removeData("layoutRole");
            // remove pane AFTER content in case there was a nested layout
            if (!$P.data(d))
                $P.css($P.data(css)).removeData(css);
        }

        // REMOVE pane resizer and toggler elements
        if ($T) $T.remove();
        if ($R) $R.remove();

        // CLEAR all pointers and state data
        Instance[pane] = $Ps[pane] = $Cs[pane] = $Rs[pane] = $Ts[pane] = false;
        s = { removed: true };

        if (!skipResize)
            resizeAll();
    }


    /*
     * ###########################
     *	   ACTION METHODS
     * ###########################
     */

        /**
         * @param {string}	pane
         */
    , _hidePane = function (pane) {
        var $P = $Ps[pane]
		, o = options[pane]
		, s = $P[0].style
        ;
        if (o.useOffscreenClose) {
            if (!$P.data(_c.offscreenReset))
                $P.data(_c.offscreenReset, { left: s.left, right: s.right });
            $P.css(_c.offscreenCSS);
        }
        else
            $P.hide().removeData(_c.offscreenReset);
    }

        /**
         * @param {string}	pane
         */
    , _showPane = function (pane) {
        var $P = $Ps[pane]
		, o = options[pane]
		, off = _c.offscreenCSS
		, old = $P.data(_c.offscreenReset)
		, s = $P[0].style
        ;
        $P.show() // ALWAYS show, just in case
			.removeData(_c.offscreenReset);
        if (o.useOffscreenClose && old) {
            if (s.left == off.left)
                s.left = old.left;
            if (s.right == off.right)
                s.right = old.right;
        }
    }


        /**
         * Completely 'hides' a pane, including its spacing - as if it does not exist
         * The pane is not actually 'removed' from the source, so can use 'show' to un-hide it
         *
         * @param {(string|Object)}	evt_or_pane			The pane being hidden, ie: north, south, east, or west
         * @param {boolean=}			[noAnimation=false]	
         */
    , hide = function (evt_or_pane, noAnimation) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, o = options[pane]
		, s = state[pane]
		, $P = $Ps[pane]
		, $R = $Rs[pane]
        ;
        if (pane === "center" || !$P || s.isHidden) return; // pane does not exist OR is already hidden

        // onhide_start callback - will CANCEL hide if returns false
        if (state.initialized && false === _runCallbacks("onhide_start", pane)) return;

        s.isSliding = false; // just in case
        delete state.panesSliding[pane];

        // now hide the elements
        if ($R) $R.hide(); // hide resizer-bar
        if (!state.initialized || s.isClosed) {
            s.isClosed = true; // to trigger open-animation on show()
            s.isHidden = true;
            s.isVisible = false;
            if (!state.initialized)
                _hidePane(pane); // no animation when loading page
            sizeMidPanes(_c[pane].dir === "horz" ? "" : "center");
            if (state.initialized || o.triggerEventsOnLoad)
                _runCallbacks("onhide_end", pane);
        }
        else {
            s.isHiding = true; // used by onclose
            close(pane, false, noAnimation); // adjust all panes to fit
        }
    }

        /**
         * Show a hidden pane - show as 'closed' by default unless openPane = true
         *
         * @param {(string|Object)}	evt_or_pane			The pane being opened, ie: north, south, east, or west
         * @param {boolean=}			[openPane=false]
         * @param {boolean=}			[noAnimation=false]
         * @param {boolean=}			[noAlert=false]
         */
    , show = function (evt_or_pane, openPane, noAnimation, noAlert) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, o = options[pane]
		, s = state[pane]
		, $P = $Ps[pane]
		, $R = $Rs[pane]
        ;
        if (pane === "center" || !$P || !s.isHidden) return; // pane does not exist OR is not hidden

        // onshow_start callback - will CANCEL show if returns false
        if (false === _runCallbacks("onshow_start", pane)) return;

        s.isShowing = true; // used by onopen/onclose
        //s.isHidden  = false; - will be set by open/close - if not cancelled
        s.isSliding = false; // just in case
        delete state.panesSliding[pane];

        // now show the elements
        //if ($R) $R.show(); - will be shown by open/close
        if (openPane === false)
            close(pane, true); // true = force
        else
            open(pane, false, noAnimation, noAlert); // adjust all panes to fit
    }


        /**
         * Toggles a pane open/closed by calling either open or close
         *
         * @param {(string|Object)}	evt_or_pane		The pane being toggled, ie: north, south, east, or west
         * @param {boolean=}			[slide=false]
         */
    , toggle = function (evt_or_pane, slide) {
        if (!isInitialized()) return;
        var evt = evtObj(evt_or_pane)
		, pane = evtPane.call(this, evt_or_pane)
		, s = state[pane]
        ;
        if (evt) // called from to $R.dblclick OR triggerPaneEvent
            evt.stopImmediatePropagation();
        if (s.isHidden)
            show(pane); // will call 'open' after unhiding it
        else if (s.isClosed)
            open(pane, !!slide);
        else
            close(pane);
    }


        /**
         * Utility method used during init or other auto-processes
         *
         * @param {string}	pane   The pane being closed
         * @param {boolean=}	[setHandles=false]
         */
    , _closePane = function (pane, setHandles) {
        var
			$P = $Ps[pane]
		, s = state[pane]
        ;
        _hidePane(pane);
        s.isClosed = true;
        s.isVisible = false;
        if (setHandles) setAsClosed(pane);
    }

        /**
         * Close the specified pane (animation optional), and resize all other panes as needed
         *
         * @param {(string|Object)}	evt_or_pane			The pane being closed, ie: north, south, east, or west
         * @param {boolean=}			[force=false]
         * @param {boolean=}			[noAnimation=false]
         * @param {boolean=}			[skipCallback=false]
         */
    , close = function (evt_or_pane, force, noAnimation, skipCallback) {
        var pane = evtPane.call(this, evt_or_pane);
        if (pane === "center") return; // validate
        // if pane has been initialized, but NOT the complete layout, close pane instantly
        if (!state.initialized && $Ps[pane]) {
            _closePane(pane, true); // INIT pane as closed
            return;
        }
        if (!isInitialized()) return;

        var
			$P = $Ps[pane]
		, $R = $Rs[pane]
		, $T = $Ts[pane]
		, o = options[pane]
		, s = state[pane]
		, c = _c[pane]
		, doFX, isShowing, isHiding, wasSliding;

        // QUEUE in case another action/animation is in progress
        $N.queue(function (queueNext) {

            if (!$P
			|| (!o.closable && !s.isShowing && !s.isHiding)	// invalid request // (!o.resizable && !o.closable) ???
			|| (!force && s.isClosed && !s.isShowing)			// already closed
			) return queueNext();

            // onclose_start callback - will CANCEL hide if returns false
            // SKIP if just 'showing' a hidden pane as 'closed'
            var abort = !s.isShowing && false === _runCallbacks("onclose_start", pane);

            // transfer logic vars to temp vars
            isShowing = s.isShowing;
            isHiding = s.isHiding;
            wasSliding = s.isSliding;
            // now clear the logic vars (REQUIRED before aborting)
            delete s.isShowing;
            delete s.isHiding;

            if (abort) return queueNext();

            doFX = !noAnimation && !s.isClosed && (o.fxName_close != "none");
            s.isMoving = true;
            s.isClosed = true;
            s.isVisible = false;
            // update isHidden BEFORE sizing panes
            if (isHiding) s.isHidden = true;
            else if (isShowing) s.isHidden = false;

            if (s.isSliding) // pane is being closed, so UNBIND trigger events
                bindStopSlidingEvents(pane, false); // will set isSliding=false
            else // resize panes adjacent to this one
                sizeMidPanes(_c[pane].dir === "horz" ? "" : "center", false); // false = NOT skipCallback

            // if this pane has a resizer bar, move it NOW - before animation
            setAsClosed(pane);

            // CLOSE THE PANE
            if (doFX) { // animate the close
                lockPaneForFX(pane, true);	// need to set left/top so animation will work
                $P.hide(o.fxName_close, o.fxSettings_close, o.fxSpeed_close, function () {
                    lockPaneForFX(pane, false); // undo
                    if (s.isClosed) close_2();
                    queueNext();
                });
            }
            else { // hide the pane without animation
                _hidePane(pane);
                close_2();
                queueNext();
            };
        });

        // SUBROUTINE
        function close_2() {
            s.isMoving = false;
            bindStartSlidingEvents(pane, true); // will enable if o.slidable = true

            // if opposite-pane was autoClosed, see if it can be autoOpened now
            var altPane = _c.oppositeEdge[pane];
            if (state[altPane].noRoom) {
                setSizeLimits(altPane);
                makePaneFit(altPane);
            }

            if (!skipCallback && (state.initialized || o.triggerEventsOnLoad)) {
                // onclose callback - UNLESS just 'showing' a hidden pane as 'closed'
                if (!isShowing) _runCallbacks("onclose_end", pane);
                // onhide OR onshow callback
                if (isShowing) _runCallbacks("onshow_end", pane);
                if (isHiding) _runCallbacks("onhide_end", pane);
            }
        }
    }

        /**
         * @param {string}	pane	The pane just closed, ie: north, south, east, or west
         */
    , setAsClosed = function (pane) {
        if (!$Rs[pane]) return; // handles not initialized yet!
        var
			$P = $Ps[pane]
		, $R = $Rs[pane]
		, $T = $Ts[pane]
		, o = options[pane]
		, s = state[pane]
		, side = _c[pane].side
		, rClass = o.resizerClass
		, tClass = o.togglerClass
		, _pane = "-" + pane // used for classNames
		, _open = "-open"
		, _sliding = "-sliding"
		, _closed = "-closed"
        ;
        $R
			.css(side, sC.inset[side]) // move the resizer
			.removeClass(rClass + _open + " " + rClass + _pane + _open)
			.removeClass(rClass + _sliding + " " + rClass + _pane + _sliding)
			.addClass(rClass + _closed + " " + rClass + _pane + _closed)
        ;
        // handle already-hidden panes in case called by swap() or a similar method 
        if (s.isHidden) $R.hide(); // hide resizer-bar 

        // DISABLE 'resizing' when closed - do this BEFORE bindStartSlidingEvents?
        if (o.resizable && $.layout.plugins.draggable)
            $R
				.draggable("disable")
				.removeClass("ui-state-disabled") // do NOT apply disabled styling - not suitable here
				.css("cursor", "default")
				.attr("title", "")
        ;

        // if pane has a toggler button, adjust that too
        if ($T) {
            $T
				.removeClass(tClass + _open + " " + tClass + _pane + _open)
				.addClass(tClass + _closed + " " + tClass + _pane + _closed)
				.attr("title", o.tips.Open) // may be blank
            ;
            // toggler-content - if exists
            $T.children(".content-open").hide();
            $T.children(".content-closed").css("display", "block");
        }

        // sync any 'pin buttons'
        syncPinBtns(pane, false);

        if (state.initialized) {
            // resize 'length' and position togglers for adjacent panes
            sizeHandles();
        }
    }

        /**
         * Open the specified pane (animation optional), and resize all other panes as needed
         *
         * @param {(string|Object)}	evt_or_pane			The pane being opened, ie: north, south, east, or west
         * @param {boolean=}			[slide=false]
         * @param {boolean=}			[noAnimation=false]
         * @param {boolean=}			[noAlert=false]
         */
    , open = function (evt_or_pane, slide, noAnimation, noAlert) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, $P = $Ps[pane]
		, $R = $Rs[pane]
		, $T = $Ts[pane]
		, o = options[pane]
		, s = state[pane]
		, c = _c[pane]
		, doFX, isShowing
        ;
        if (pane === "center") return; // validate
        // QUEUE in case another action/animation is in progress
        $N.queue(function (queueNext) {

            if (!$P
			|| (!o.resizable && !o.closable && !s.isShowing)	// invalid request
			|| (s.isVisible && !s.isSliding)					// already open
			) return queueNext();

            // pane can ALSO be unhidden by just calling show(), so handle this scenario
            if (s.isHidden && !s.isShowing) {
                queueNext(); // call before show() because it needs the queue free
                show(pane, true);
                return;
            }

            if (s.autoResize && s.size != o.size) // resize pane to original size set in options
                sizePane(pane, o.size, true, true, true); // true=skipCallback/noAnimation/forceResize
            else
                // make sure there is enough space available to open the pane
                setSizeLimits(pane, slide);

            // onopen_start callback - will CANCEL open if returns false
            var cbReturn = _runCallbacks("onopen_start", pane);

            if (cbReturn === "abort")
                return queueNext();

            // update pane-state again in case options were changed in onopen_start
            if (cbReturn !== "NC") // NC = "No Callback"
                setSizeLimits(pane, slide);

            if (s.minSize > s.maxSize) { // INSUFFICIENT ROOM FOR PANE TO OPEN!
                syncPinBtns(pane, false); // make sure pin-buttons are reset
                if (!noAlert && o.tips.noRoomToOpen) {
                    if (window.console) {
                        console.log(o.tips.noRoomToOpen);
                    }
                    else {
                        alert(o.tips.noRoomToOpen);
                    }
                }
                return queueNext(); // ABORT
            }

            if (slide) // START Sliding - will set isSliding=true
                bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
            else if (s.isSliding) // PIN PANE (stop sliding) - open pane 'normally' instead
                bindStopSlidingEvents(pane, false); // UNBIND trigger events - will set isSliding=false
            else if (o.slidable)
                bindStartSlidingEvents(pane, false); // UNBIND trigger events

            s.noRoom = false; // will be reset by makePaneFit if 'noRoom'
            makePaneFit(pane);

            // transfer logic var to temp var
            isShowing = s.isShowing;
            // now clear the logic var
            delete s.isShowing;

            doFX = !noAnimation && s.isClosed && (o.fxName_open != "none");
            s.isMoving = true;
            s.isVisible = true;
            s.isClosed = false;
            // update isHidden BEFORE sizing panes - WHY??? Old?
            if (isShowing) s.isHidden = false;

            if (doFX) { // ANIMATE
                // mask adjacent panes with objects
                lockPaneForFX(pane, true);	// need to set left/top so animation will work
                $P.show(o.fxName_open, o.fxSettings_open, o.fxSpeed_open, function () {
                    lockPaneForFX(pane, false); // undo
                    if (s.isVisible) open_2(); // continue
                    queueNext();
                });
            }
            else { // no animation
                _showPane(pane);// just show pane and...
                open_2();		// continue
                queueNext();
            };
        });

        // SUBROUTINE
        function open_2() {
            s.isMoving = false;

            // cure iframe display issues
            _fixIframe(pane);

            // NOTE: if isSliding, then other panes are NOT 'resized'
            if (!s.isSliding) { // resize all panes adjacent to this one
                sizeMidPanes(_c[pane].dir == "vert" ? "center" : "", false); // false = NOT skipCallback
            }

            // set classes, position handles and execute callbacks...
            setAsOpen(pane);
        };

    }

        /**
         * @param {string}	pane		The pane just opened, ie: north, south, east, or west
         * @param {boolean=}	[skipCallback=false]
         */
    , setAsOpen = function (pane, skipCallback) {
        var
			$P = $Ps[pane]
		, $R = $Rs[pane]
		, $T = $Ts[pane]
		, o = options[pane]
		, s = state[pane]
		, side = _c[pane].side
		, rClass = o.resizerClass
		, tClass = o.togglerClass
		, _pane = "-" + pane // used for classNames
		, _open = "-open"
		, _closed = "-closed"
		, _sliding = "-sliding"
        ;
        $R
			.css(side, sC.inset[side] + getPaneSize(pane)) // move the resizer
			.removeClass(rClass + _closed + " " + rClass + _pane + _closed)
			.addClass(rClass + _open + " " + rClass + _pane + _open)
        ;
        if (s.isSliding)
            $R.addClass(rClass + _sliding + " " + rClass + _pane + _sliding)
        else // in case 'was sliding'
            $R.removeClass(rClass + _sliding + " " + rClass + _pane + _sliding)

        removeHover(0, $R); // remove hover classes
        if (o.resizable && $.layout.plugins.draggable)
            $R.draggable("enable")
				.css("cursor", o.resizerCursor)
				.attr("title", o.tips.Resize);
        else if (!s.isSliding)
            $R.css("cursor", "default"); // n-resize, s-resize, etc

        // if pane also has a toggler button, adjust that too
        if ($T) {
            $T.removeClass(tClass + _closed + " " + tClass + _pane + _closed)
				.addClass(tClass + _open + " " + tClass + _pane + _open)
				.attr("title", o.tips.Close); // may be blank
            removeHover(0, $T); // remove hover classes
            // toggler-content - if exists
            $T.children(".content-closed").hide();
            $T.children(".content-open").css("display", "block");
        }

        // sync any 'pin buttons'
        syncPinBtns(pane, !s.isSliding);

        // update pane-state dimensions - BEFORE resizing content
        $.extend(s, elDims($P));

        if (state.initialized) {
            // resize resizer & toggler sizes for all panes
            sizeHandles();
            // resize content every time pane opens - to be sure
            sizeContent(pane, true); // true = remeasure headers/footers, even if 'pane.isMoving'
        }

        if (!skipCallback && (state.initialized || o.triggerEventsOnLoad) && $P.is(":visible")) {
            // onopen callback
            _runCallbacks("onopen_end", pane);
            // onshow callback - TODO: should this be here?
            if (s.isShowing) _runCallbacks("onshow_end", pane);

            // ALSO call onresize because layout-size *may* have changed while pane was closed
            if (state.initialized)
                _runCallbacks("onresize_end", pane);
        }

        // TODO: Somehow sizePane("north") is being called after this point???
    }


        /**
         * slideOpen / slideClose / slideToggle
         *
         * Pass-though methods for sliding
         */
    , slideOpen = function (evt_or_pane) {
        if (!isInitialized()) return;
        var evt = evtObj(evt_or_pane)
		, pane = evtPane.call(this, evt_or_pane)
		, s = state[pane]
		, delay = options[pane].slideDelay_open
        ;
        if (pane === "center") return; // validate
        // prevent event from triggering on NEW resizer binding created below
        if (evt) evt.stopImmediatePropagation();

        if (s.isClosed && evt && evt.type === "mouseenter" && delay > 0)
            // trigger = mouseenter - use a delay
            timer.set(pane + "_openSlider", open_NOW, delay);
        else
            open_NOW(); // will unbind events if is already open

        /**
		 * SUBROUTINE for timed open
		 */
        function open_NOW() {
            if (!s.isClosed) // skip if no longer closed!
                bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
            else if (!s.isMoving)
                open(pane, true); // true = slide - open() will handle binding
        };
    }

    , slideClose = function (evt_or_pane) {
        if (!isInitialized()) return;
        var evt = evtObj(evt_or_pane)
		, pane = evtPane.call(this, evt_or_pane)
		, o = options[pane]
		, s = state[pane]
		, delay = s.isMoving ? 1000 : 300 // MINIMUM delay - option may override
        ;
        if (pane === "center") return; // validate
        if (s.isClosed || s.isResizing)
            return; // skip if already closed OR in process of resizing
        else if (o.slideTrigger_close === "click")
            close_NOW(); // close immediately onClick
        else if (o.preventQuickSlideClose && s.isMoving)
            return; // handle Chrome quick-close on slide-open
        else if (o.preventPrematureSlideClose && evt && $.layout.isMouseOverElem(evt, $Ps[pane]))
            return; // handle incorrect mouseleave trigger, like when over a SELECT-list in IE
        else if (evt) // trigger = mouseleave - use a delay
            // 1 sec delay if 'opening', else .3 sec
            timer.set(pane + "_closeSlider", close_NOW, max(o.slideDelay_close, delay));
        else // called programically
            close_NOW();

        /**
		 * SUBROUTINE for timed close
		 */
        function close_NOW() {
            if (s.isClosed) // skip 'close' if already closed!
                bindStopSlidingEvents(pane, false); // UNBIND trigger events - TODO: is this needed here?
            else if (!s.isMoving)
                close(pane); // close will handle unbinding
        };
    }

        /**
         * @param {(string|Object)}	evt_or_pane		The pane being opened, ie: north, south, east, or west
         */
    , slideToggle = function (evt_or_pane) {
        var pane = evtPane.call(this, evt_or_pane);
        toggle(pane, true);
    }


        /**
         * Must set left/top on East/South panes so animation will work properly
         *
         * @param {string}	pane	The pane to lock, 'east' or 'south' - any other is ignored!
         * @param {boolean}	doLock  true = set left/top, false = remove
         */
    , lockPaneForFX = function (pane, doLock) {
        var $P = $Ps[pane]
		, s = state[pane]
		, o = options[pane]
		, z = options.zIndexes
        ;
        if (doLock) {
            showMasks(pane, { animation: true, objectsOnly: true });
            $P.css({ zIndex: z.pane_animate }); // overlay all elements during animation
            if (pane == "south")
                $P.css({ top: sC.inset.top + sC.innerHeight - $P.outerHeight() });
            else if (pane == "east")
                $P.css({ left: sC.inset.left + sC.innerWidth - $P.outerWidth() });
        }
        else { // animation DONE - RESET CSS
            hideMasks();
            $P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
            if (pane == "south")
                $P.css({ top: "auto" });
                // if pane is positioned 'off-screen', then DO NOT screw with it!
            else if (pane == "east" && !$P.css("left").match(/\-99999/))
                $P.css({ left: "auto" });
            // fix anti-aliasing in IE - only needed for animations that change opacity
            if (browser.msie && o.fxOpacityFix && o.fxName_open != "slide" && $P.css("filter") && $P.css("opacity") == 1)
                $P[0].style.removeAttribute('filter');
        }
    }


        /**
         * Toggle sliding functionality of a specific pane on/off by adding removing 'slide open' trigger
         *
         * @see  open(), close()
         * @param {string}	pane	The pane to enable/disable, 'north', 'south', etc.
         * @param {boolean}	enable	Enable or Disable sliding?
         */
    , bindStartSlidingEvents = function (pane, enable) {
        var o = options[pane]
		, $P = $Ps[pane]
		, $R = $Rs[pane]
		, evtName = o.slideTrigger_open.toLowerCase()
        ;
        if (!$R || (enable && !o.slidable)) return;

        // make sure we have a valid event
        if (evtName.match(/mouseover/))
            evtName = o.slideTrigger_open = "mouseenter";
        else if (!evtName.match(/(click|dblclick|mouseenter)/))
            evtName = o.slideTrigger_open = "click";

        // must remove double-click-toggle when using dblclick-slide
        if (o.resizerDblClickToggle && evtName.match(/click/)) {
            $R[enable ? "unbind" : "bind"]('dblclick.' + sID, toggle)
        }

        $R
			// add or remove event
			[enable ? "bind" : "unbind"](evtName + '.' + sID, slideOpen)
			// set the appropriate cursor & title/tip
			.css("cursor", enable ? o.sliderCursor : "default")
			.attr("title", enable ? o.tips.Slide : "")
        ;
    }

        /**
         * Add or remove 'mouseleave' events to 'slide close' when pane is 'sliding' open or closed
         * Also increases zIndex when pane is sliding open
         * See bindStartSlidingEvents for code to control 'slide open'
         *
         * @see  slideOpen(), slideClose()
         * @param {string}	pane	The pane to process, 'north', 'south', etc.
         * @param {boolean}	enable	Enable or Disable events?
         */
    , bindStopSlidingEvents = function (pane, enable) {
        var o = options[pane]
		, s = state[pane]
		, c = _c[pane]
		, z = options.zIndexes
		, evtName = o.slideTrigger_close.toLowerCase()
		, action = (enable ? "bind" : "unbind")
		, $P = $Ps[pane]
		, $R = $Rs[pane]
        ;
        timer.clear(pane + "_closeSlider"); // just in case

        if (enable) {
            s.isSliding = true;
            state.panesSliding[pane] = true;
            // remove 'slideOpen' event from resizer
            // ALSO will raise the zIndex of the pane & resizer
            bindStartSlidingEvents(pane, false);
        }
        else {
            s.isSliding = false;
            delete state.panesSliding[pane];
        }

        // RE/SET zIndex - increases when pane is sliding-open, resets to normal when not
        $P.css("zIndex", enable ? z.pane_sliding : z.pane_normal);
        $R.css("zIndex", enable ? z.pane_sliding + 2 : z.resizer_normal); // NOTE: mask = pane_sliding+1

        // make sure we have a valid event
        if (!evtName.match(/(click|mouseleave)/))
            evtName = o.slideTrigger_close = "mouseleave"; // also catches 'mouseout'

        // add/remove slide triggers
        $R[action](evtName, slideClose); // base event on resize
        // need extra events for mouseleave
        if (evtName === "mouseleave") {
            // also close on pane.mouseleave
            $P[action]("mouseleave." + sID, slideClose);
            // cancel timer when mouse moves between 'pane' and 'resizer'
            $R[action]("mouseenter." + sID, cancelMouseOut);
            $P[action]("mouseenter." + sID, cancelMouseOut);
        }

        if (!enable)
            timer.clear(pane + "_closeSlider");
        else if (evtName === "click" && !o.resizable) {
            // IF pane is not resizable (which already has a cursor and tip) 
            // then set the a cursor & title/tip on resizer when sliding
            $R.css("cursor", enable ? o.sliderCursor : "default");
            $R.attr("title", enable ? o.tips.Close : ""); // use Toggler-tip, eg: "Close Pane"
        }

        // SUBROUTINE for mouseleave timer clearing
        function cancelMouseOut(evt) {
            timer.clear(pane + "_closeSlider");
            evt.stopPropagation();
        }
    }


        /**
         * Hides/closes a pane if there is insufficient room - reverses this when there is room again
         * MUST have already called setSizeLimits() before calling this method
         *
         * @param {string}	pane					The pane being resized
         * @param {boolean=}	[isOpening=false]		Called from onOpen?
         * @param {boolean=}	[skipCallback=false]	Should the onresize callback be run?
         * @param {boolean=}	[force=false]
         */
    , makePaneFit = function (pane, isOpening, skipCallback, force) {
        var o = options[pane]
		, s = state[pane]
		, c = _c[pane]
		, $P = $Ps[pane]
		, $R = $Rs[pane]
		, isSidePane = c.dir === "vert"
		, hasRoom = false
        ;
        // special handling for center & east/west panes
        if (pane === "center" || (isSidePane && s.noVerticalRoom)) {
            // see if there is enough room to display the pane
            // ERROR: hasRoom = s.minHeight <= s.maxHeight && (isSidePane || s.minWidth <= s.maxWidth);
            hasRoom = (s.maxHeight >= 0);
            if (hasRoom && s.noRoom) { // previously hidden due to noRoom, so show now
                _showPane(pane);
                if ($R) $R.show();
                s.isVisible = true;
                s.noRoom = false;
                if (isSidePane) s.noVerticalRoom = false;
                _fixIframe(pane);
            }
            else if (!hasRoom && !s.noRoom) { // not currently hidden, so hide now
                _hidePane(pane);
                if ($R) $R.hide();
                s.isVisible = false;
                s.noRoom = true;
            }
        }

        // see if there is enough room to fit the border-pane
        if (pane === "center") {
            // ignore center in this block
        }
        else if (s.minSize <= s.maxSize) { // pane CAN fit
            hasRoom = true;
            if (s.size > s.maxSize) // pane is too big - shrink it
                sizePane(pane, s.maxSize, skipCallback, true, force); // true = noAnimation
            else if (s.size < s.minSize) // pane is too small - enlarge it
                sizePane(pane, s.minSize, skipCallback, true, force); // true = noAnimation
                // need s.isVisible because new pseudoClose method keeps pane visible, but off-screen
            else if ($R && s.isVisible && $P.is(":visible")) {
                // make sure resizer-bar is positioned correctly
                // handles situation where nested layout was 'hidden' when initialized
                var pos = s.size + sC.inset[c.side];
                if ($.layout.cssNum($R, c.side) != pos) $R.css(c.side, pos);
            }

            // if was previously hidden due to noRoom, then RESET because NOW there is room
            if (s.noRoom) {
                // s.noRoom state will be set by open or show
                if (s.wasOpen && o.closable) {
                    if (o.autoReopen)
                        open(pane, false, true, true); // true = noAnimation, true = noAlert
                    else // leave the pane closed, so just update state
                        s.noRoom = false;
                }
                else
                    show(pane, s.wasOpen, true, true); // true = noAnimation, true = noAlert
            }
        }
        else { // !hasRoom - pane CANNOT fit
            if (!s.noRoom) { // pane not set as noRoom yet, so hide or close it now...
                s.noRoom = true; // update state
                s.wasOpen = !s.isClosed && !s.isSliding;
                if (s.isClosed) { } // SKIP
                else if (o.closable) // 'close' if possible
                    close(pane, true, true); // true = force, true = noAnimation
                else // 'hide' pane if cannot just be closed
                    hide(pane, true); // true = noAnimation
            }
        }
    }


        /**
         * manualSizePane is an exposed flow-through method allowing extra code when pane is 'manually resized'
         *
         * @param {(string|Object)}	evt_or_pane				The pane being resized
         * @param {number}			size					The *desired* new size for this pane - will be validated
         * @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
         * @param {boolean=}			[noAnimation=false]
         * @param {boolean=}			[force=false]			Force resizing even if does not seem necessary
         */
    , manualSizePane = function (evt_or_pane, size, skipCallback, noAnimation, force) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, o = options[pane]
		, s = state[pane]
		//	if resizing callbacks have been delayed and resizing is now DONE, force resizing to complete...
		, forceResize = force || (o.livePaneResizing && !s.isResizing)
        ;
        if (pane === "center") return; // validate
        // ANY call to manualSizePane disables autoResize - ie, percentage sizing
        s.autoResize = false;
        // flow-through...
        sizePane(pane, size, skipCallback, noAnimation, forceResize); // will animate resize if option enabled
    }

        /**
         * sizePane is called only by internal methods whenever a pane needs to be resized
         *
         * @param {(string|Object)}	evt_or_pane				The pane being resized
         * @param {number}			size					The *desired* new size for this pane - will be validated
         * @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
         * @param {boolean=}			[noAnimation=false]
         * @param {boolean=}			[force=false]			Force resizing even if does not seem necessary
         */
    , sizePane = function (evt_or_pane, size, skipCallback, noAnimation, force) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane) // probably NEVER called from event?
		, o = options[pane]
		, s = state[pane]
		, $P = $Ps[pane]
		, $R = $Rs[pane]
		, side = _c[pane].side
		, dimName = _c[pane].sizeType.toLowerCase()
		, skipResizeWhileDragging = s.isResizing && !o.triggerEventsDuringLiveResize
		, doFX = noAnimation !== true && o.animatePaneSizing
		, oldSize, newSize
        ;
        if (pane === "center") return; // validate
        // QUEUE in case another action/animation is in progress
        $N.queue(function (queueNext) {
            // calculate 'current' min/max sizes
            setSizeLimits(pane); // update pane-state
            oldSize = s.size;
            size = _parseSize(pane, size); // handle percentages & auto
            size = max(size, _parseSize(pane, o.minSize));
            size = min(size, s.maxSize);
            if (size < s.minSize) { // not enough room for pane!
                queueNext(); // call before makePaneFit() because it needs the queue free
                makePaneFit(pane, false, skipCallback);	// will hide or close pane
                return;
            }

            // IF newSize is same as oldSize, then nothing to do - abort
            if (!force && size === oldSize)
                return queueNext();

            s.newSize = size;

            // onresize_start callback CANNOT cancel resizing because this would break the layout!
            if (!skipCallback && state.initialized && s.isVisible)
                _runCallbacks("onresize_start", pane);

            // resize the pane, and make sure its visible
            newSize = cssSize(pane, size);

            if (doFX && $P.is(":visible")) { // ANIMATE
                var fx = $.layout.effects.size[pane] || $.layout.effects.size.all
				, easing = o.fxSettings_size.easing || fx.easing
				, z = options.zIndexes
				, props = {};
                props[dimName] = newSize + 'px';
                s.isMoving = true;
                // overlay all elements during animation
                $P.css({ zIndex: z.pane_animate })
				  .show().animate(props, o.fxSpeed_size, easing, function () {
				      // reset zIndex after animation
				      $P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
				      s.isMoving = false;
				      delete s.newSize;
				      sizePane_2(); // continue
				      queueNext();
				  });
            }
            else { // no animation
                $P.css(dimName, newSize);	// resize pane
                delete s.newSize;
                // if pane is visible, then 
                if ($P.is(":visible"))
                    sizePane_2(); // continue
                else {
                    // pane is NOT VISIBLE, so just update state data...
                    // when pane is *next opened*, it will have the new size
                    s.size = size;				// update state.size
                    //$.extend(s, elDims($P));	// update state dimensions - CANNOT do this when not visible!				}
                }
                queueNext();
            };

        });

        // SUBROUTINE
        function sizePane_2() {
            /*	Panes are sometimes not sized precisely in some browsers!?
			 *	This code will resize the pane up to 3 times to nudge the pane to the correct size
			 */
            var actual = dimName === 'width' ? $P.outerWidth() : $P.outerHeight()
			, tries = [{
			    pane: pane
						, count: 1
						, target: size
						, actual: actual
						, correct: (size === actual)
						, attempt: size
						, cssSize: newSize
			}]
			, lastTry = tries[0]
			, thisTry = {}
			, msg = 'Inaccurate size after resizing the ' + pane + '-pane.'
            ;
            while (!lastTry.correct) {
                thisTry = { pane: pane, count: lastTry.count + 1, target: size };

                if (lastTry.actual > size)
                    thisTry.attempt = max(0, lastTry.attempt - (lastTry.actual - size));
                else // lastTry.actual < size
                    thisTry.attempt = max(0, lastTry.attempt + (size - lastTry.actual));

                thisTry.cssSize = cssSize(pane, thisTry.attempt);
                $P.css(dimName, thisTry.cssSize);

                thisTry.actual = dimName == 'width' ? $P.outerWidth() : $P.outerHeight();
                thisTry.correct = (size === thisTry.actual);

                // log attempts and alert the user of this *non-fatal error* (if showDebugMessages)
                if (tries.length === 1) {
                    _log(msg, false, true);
                    _log(lastTry, false, true);
                }
                _log(thisTry, false, true);
                // after 4 tries, is as close as its gonna get!
                if (tries.length > 3) break;

                tries.push(thisTry);
                lastTry = tries[tries.length - 1];
            }
            // END TESTING CODE

            // update pane-state dimensions
            s.size = size;
            $.extend(s, elDims($P));

            if (s.isVisible && $P.is(":visible")) {
                // reposition the resizer-bar
                if ($R) $R.css(side, size + sC.inset[side]);
                // resize the content-div
                sizeContent(pane);
            }

            if (!skipCallback && !skipResizeWhileDragging && state.initialized && s.isVisible)
                _runCallbacks("onresize_end", pane);

            // resize all the adjacent panes, and adjust their toggler buttons
            // when skipCallback passed, it means the controlling method will handle 'other panes'
            if (!skipCallback) {
                // also no callback if live-resize is in progress and NOT triggerEventsDuringLiveResize
                if (!s.isSliding) sizeMidPanes(_c[pane].dir == "horz" ? "" : "center", skipResizeWhileDragging, force);
                sizeHandles();
            }

            // if opposite-pane was autoClosed, see if it can be autoOpened now
            var altPane = _c.oppositeEdge[pane];
            if (size < oldSize && state[altPane].noRoom) {
                setSizeLimits(altPane);
                makePaneFit(altPane, false, skipCallback);
            }

            // DEBUG - ALERT user/developer so they know there was a sizing problem
            if (tries.length > 1)
                _log(msg + '\nSee the Error Console for details.', true, true);
        }
    }

        /**
         * @see  initPanes(), sizePane(), 	resizeAll(), open(), close(), hide()
         * @param {(Array.<string>|string)}	panes					The pane(s) being resized, comma-delmited string
         * @param {boolean=}					[skipCallback=false]	Should the onresize callback be run?
         * @param {boolean=}					[force=false]
         */
    , sizeMidPanes = function (panes, skipCallback, force) {
        panes = (panes ? panes : "east,west,center").split(",");

        $.each(panes, function (i, pane) {
            if (!$Ps[pane]) return; // NO PANE - skip
            var
				o = options[pane]
			, s = state[pane]
			, $P = $Ps[pane]
			, $R = $Rs[pane]
			, isCenter = (pane == "center")
			, hasRoom = true
			, CSS = {}
			//	if pane is not visible, show it invisibly NOW rather than for *each call* in this script
			, visCSS = $.layout.showInvisibly($P)

			, newCenter = calcNewCenterPaneDims()
            ;

            // update pane-state dimensions
            $.extend(s, elDims($P));

            if (pane === "center") {
                if (!force && s.isVisible && newCenter.width === s.outerWidth && newCenter.height === s.outerHeight) {
                    $P.css(visCSS);
                    return true; // SKIP - pane already the correct size
                }
                // set state for makePaneFit() logic
                $.extend(s, cssMinDims(pane), {
                    maxWidth: newCenter.width
				, maxHeight: newCenter.height
                });
                CSS = newCenter;
                s.newWidth = CSS.width;
                s.newHeight = CSS.height;
                // convert OUTER width/height to CSS width/height 
                CSS.width = cssW($P, CSS.width);
                // NEW - allow pane to extend 'below' visible area rather than hide it
                CSS.height = cssH($P, CSS.height);
                hasRoom = CSS.width >= 0 && CSS.height >= 0; // height >= 0 = ALWAYS TRUE NOW

                // during layout init, try to shrink east/west panes to make room for center
                if (!state.initialized && o.minWidth > newCenter.width) {
                    var
						reqPx = o.minWidth - s.outerWidth
					, minE = options.east.minSize || 0
					, minW = options.west.minSize || 0
					, sizeE = state.east.size
					, sizeW = state.west.size
					, newE = sizeE
					, newW = sizeW
                    ;
                    if (reqPx > 0 && state.east.isVisible && sizeE > minE) {
                        newE = max(sizeE - minE, sizeE - reqPx);
                        reqPx -= sizeE - newE;
                    }
                    if (reqPx > 0 && state.west.isVisible && sizeW > minW) {
                        newW = max(sizeW - minW, sizeW - reqPx);
                        reqPx -= sizeW - newW;
                    }
                    // IF we found enough extra space, then resize the border panes as calculated
                    if (reqPx === 0) {
                        if (sizeE && sizeE != minE)
                            sizePane('east', newE, true, true, force); // true = skipCallback/noAnimation - initPanes will handle when done
                        if (sizeW && sizeW != minW)
                            sizePane('west', newW, true, true, force); // true = skipCallback/noAnimation
                        // now start over!
                        sizeMidPanes('center', skipCallback, force);
                        $P.css(visCSS);
                        return; // abort this loop
                    }
                }
            }
            else { // for east and west, set only the height, which is same as center height
                // set state.min/maxWidth/Height for makePaneFit() logic
                if (s.isVisible && !s.noVerticalRoom)
                    $.extend(s, elDims($P), cssMinDims(pane))
                if (!force && !s.noVerticalRoom && newCenter.height === s.outerHeight) {
                    $P.css(visCSS);
                    return true; // SKIP - pane already the correct size
                }
                // east/west have same top, bottom & height as center
                CSS.top = newCenter.top;
                CSS.bottom = newCenter.bottom;
                s.newSize = newCenter.height
                // NEW - allow pane to extend 'below' visible area rather than hide it
                CSS.height = cssH($P, newCenter.height);
                s.maxHeight = CSS.height;
                hasRoom = (s.maxHeight >= 0); // ALWAYS TRUE NOW
                if (!hasRoom) s.noVerticalRoom = true; // makePaneFit() logic
            }

            if (hasRoom) {
                // resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
                if (!skipCallback && state.initialized)
                    _runCallbacks("onresize_start", pane);

                $P.css(CSS); // apply the CSS to pane
                if (pane !== "center")
                    sizeHandles(pane); // also update resizer length
                if (s.noRoom && !s.isClosed && !s.isHidden)
                    makePaneFit(pane); // will re-open/show auto-closed/hidden pane
                if (s.isVisible) {
                    $.extend(s, elDims($P)); // update pane dimensions
                    if (state.initialized) sizeContent(pane); // also resize the contents, if exists
                }
            }
            else if (!s.noRoom && s.isVisible) // no room for pane
                makePaneFit(pane); // will hide or close pane

            // reset visibility, if necessary
            $P.css(visCSS);

            delete s.newSize;
            delete s.newWidth;
            delete s.newHeight;

            if (!s.isVisible)
                return true; // DONE - next pane

            /*
			 * Extra CSS for IE6 or IE7 in Quirks-mode - add 'width' to NORTH/SOUTH panes
			 * Normally these panes have only 'left' & 'right' positions so pane auto-sizes
			 * ALSO required when pane is an IFRAME because will NOT default to 'full width'
			 *	TODO: Can I use width:100% for a north/south iframe?
			 *	TODO: Sounds like a job for $P.outerWidth( sC.innerWidth ) SETTER METHOD
			 */
            if (pane === "center") { // finished processing midPanes
                var fix = browser.isIE6 || !browser.boxModel;
                if ($Ps.north && (fix || state.north.tagName == "IFRAME"))
                    $Ps.north.css("width", cssW($Ps.north, sC.innerWidth));
                if ($Ps.south && (fix || state.south.tagName == "IFRAME"))
                    $Ps.south.css("width", cssW($Ps.south, sC.innerWidth));
            }

            // resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
            if (!skipCallback && state.initialized)
                _runCallbacks("onresize_end", pane);
        });
    }


        /**
         * @see  window.onresize(), callbacks or custom code
         * @param {(Object|boolean)=}	evt_or_refresh	If 'true', then also reset pane-positioning
         */
    , resizeAll = function (evt_or_refresh) {
        var oldW = sC.innerWidth
		, oldH = sC.innerHeight
        ;
        // stopPropagation if called by trigger("layoutdestroy") - use evtPane utility 
        evtPane(evt_or_refresh);

        // cannot size layout when 'container' is hidden or collapsed
        if (!$N.is(":visible")) return;

        if (!state.initialized) {
            _initLayoutElements();
            return; // no need to resize since we just initialized!
        }

        if (evt_or_refresh === true && $.isPlainObject(options.outset)) {
            // update container CSS in case outset option has changed
            $N.css(options.outset);
        }
        // UPDATE container dimensions
        $.extend(sC, elDims($N, options.inset));
        if (!sC.outerHeight) return;

        // if 'true' passed, refresh pane & handle positioning too
        if (evt_or_refresh === true) {
            setPanePosition();
        }

        // onresizeall_start will CANCEL resizing if returns false
        // state.container has already been set, so user can access this info for calcuations
        if (false === _runCallbacks("onresizeall_start")) return false;

        var	// see if container is now 'smaller' than before
			shrunkH = (sC.innerHeight < oldH)
		, shrunkW = (sC.innerWidth < oldW)
		, $P, o, s
        ;
        // NOTE special order for sizing: S-N-E-W
        $.each(["south", "north", "east", "west"], function (i, pane) {
            if (!$Ps[pane]) return; // no pane - SKIP
            o = options[pane];
            s = state[pane];
            if (s.autoResize && s.size != o.size) // resize pane to original size set in options
                sizePane(pane, o.size, true, true, true); // true=skipCallback/noAnimation/forceResize
            else {
                setSizeLimits(pane);
                makePaneFit(pane, false, true, true); // true=skipCallback/forceResize
            }
        });

        sizeMidPanes("", true, true); // true=skipCallback/forceResize
        sizeHandles(); // reposition the toggler elements

        // trigger all individual pane callbacks AFTER layout has finished resizing
        $.each(_c.allPanes, function (i, pane) {
            $P = $Ps[pane];
            if (!$P) return; // SKIP
            if (state[pane].isVisible) // undefined for non-existent panes
                _runCallbacks("onresize_end", pane); // callback - if exists
        });

        _runCallbacks("onresizeall_end");
        //_triggerLayoutEvent(pane, 'resizeall');
    }

        /**
         * Whenever a pane resizes or opens that has a nested layout, trigger resizeAll
         *
         * @param {(string|Object)}	evt_or_pane		The pane just resized or opened
         */
    , resizeChildren = function (evt_or_pane, skipRefresh) {
        var pane = evtPane.call(this, evt_or_pane);

        if (!options[pane].resizeChildren) return;

        // ensure the pane-children are up-to-date
        if (!skipRefresh) refreshChildren(pane);
        var pC = children[pane];
        if ($.isPlainObject(pC)) {
            // resize one or more children
            $.each(pC, function (key, child) {
                if (!child.destroyed) child.resizeAll();
            });
        }
    }

        /**
         * IF pane has a content-div, then resize all elements inside pane to fit pane-height
         *
         * @param {(string|Object)}	evt_or_panes		The pane(s) being resized
         * @param {boolean=}			[remeasure=false]	Should the content (header/footer) be remeasured?
         */
    , sizeContent = function (evt_or_panes, remeasure) {
        if (!isInitialized()) return;

        var panes = evtPane.call(this, evt_or_panes);
        panes = panes ? panes.split(",") : _c.allPanes;

        $.each(panes, function (idx, pane) {
            var
				$P = $Ps[pane]
			, $C = $Cs[pane]
			, o = options[pane]
			, s = state[pane]
			, m = s.content // m = measurements
            ;
            if (!$P || !$C || !$P.is(":visible")) return true; // NOT VISIBLE - skip

            // if content-element was REMOVED, update OR remove the pointer
            if (!$C.length) {
                initContent(pane, false);	// false = do NOT sizeContent() - already there!
                if (!$C) return;			// no replacement element found - pointer have been removed
            }

            // onsizecontent_start will CANCEL resizing if returns false
            if (false === _runCallbacks("onsizecontent_start", pane)) return;

            // skip re-measuring offsets if live-resizing
            if ((!s.isMoving && !s.isResizing) || o.liveContentResizing || remeasure || m.top == undefined) {
                _measure();
                // if any footers are below pane-bottom, they may not measure correctly,
                // so allow pane overflow and re-measure
                if (m.hiddenFooters > 0 && $P.css("overflow") === "hidden") {
                    $P.css("overflow", "visible");
                    _measure(); // remeasure while overflowing
                    $P.css("overflow", "hidden");
                }
            }
            // NOTE: spaceAbove/Below *includes* the pane paddingTop/Bottom, but not pane.borders
            var newH = s.innerHeight - (m.spaceAbove - s.css.paddingTop) - (m.spaceBelow - s.css.paddingBottom);

            if (!$C.is(":visible") || m.height != newH) {
                // size the Content element to fit new pane-size - will autoHide if not enough room
                setOuterHeight($C, newH, true); // true=autoHide
                m.height = newH; // save new height
            };

            if (state.initialized)
                _runCallbacks("onsizecontent_end", pane);

            function _below($E) {
                return max(s.css.paddingBottom, (parseInt($E.css("marginBottom"), 10) || 0));
            };

            function _measure() {
                var
					ignore = options[pane].contentIgnoreSelector
				, $Fs = $C.nextAll().not(".ui-layout-mask").not(ignore || ":lt(0)") // not :lt(0) = ALL
				, $Fs_vis = $Fs.filter(':visible')
				, $F = $Fs_vis.filter(':last')
                ;
                m = {
                    top: $C[0].offsetTop
				, height: $C.outerHeight()
				, numFooters: $Fs.length
				, hiddenFooters: $Fs.length - $Fs_vis.length
				, spaceBelow: 0 // correct if no content footer ($E)
                }
                m.spaceAbove = m.top; // just for state - not used in calc
                m.bottom = m.top + m.height;
                if ($F.length)
                    //spaceBelow = (LastFooter.top + LastFooter.height) [footerBottom] - Content.bottom + max(LastFooter.marginBottom, pane.paddingBotom)
                    m.spaceBelow = ($F[0].offsetTop + $F.outerHeight()) - m.bottom + _below($F);
                else // no footer - check marginBottom on Content element itself
                    m.spaceBelow = _below($C);
            };
        });
    }


        /**
         * Called every time a pane is opened, closed, or resized to slide the togglers to 'center' and adjust their length if necessary
         *
         * @see  initHandles(), open(), close(), resizeAll()
         * @param {(string|Object)=}		evt_or_panes	The pane(s) being resized
         */
    , sizeHandles = function (evt_or_panes) {
        var panes = evtPane.call(this, evt_or_panes)
        panes = panes ? panes.split(",") : _c.borderPanes;

        $.each(panes, function (i, pane) {
            var
				o = options[pane]
			, s = state[pane]
			, $P = $Ps[pane]
			, $R = $Rs[pane]
			, $T = $Ts[pane]
			, $TC
            ;
            if (!$P || !$R) return;

            var
				dir = _c[pane].dir
			, _state = (s.isClosed ? "_closed" : "_open")
			, spacing = o["spacing" + _state]
			, togAlign = o["togglerAlign" + _state]
			, togLen = o["togglerLength" + _state]
			, paneLen
			, left
			, offset
			, CSS = {}
            ;

            if (spacing === 0) {
                $R.hide();
                return;
            }
            else if (!s.noRoom && !s.isHidden) // skip if resizer was hidden for any reason
                $R.show(); // in case was previously hidden

            // Resizer Bar is ALWAYS same width/height of pane it is attached to
            if (dir === "horz") { // north/south
                //paneLen = $P.outerWidth(); // s.outerWidth || 
                paneLen = sC.innerWidth; // handle offscreen-panes
                s.resizerLength = paneLen;
                left = $.layout.cssNum($P, "left")
                $R.css({
                    width: cssW($R, paneLen) // account for borders & padding
				, height: cssH($R, spacing) // ditto
				, left: left > -9999 ? left : sC.inset.left // handle offscreen-panes
                });
            }
            else { // east/west
                paneLen = $P.outerHeight(); // s.outerHeight || 
                s.resizerLength = paneLen;
                $R.css({
                    height: cssH($R, paneLen) // account for borders & padding
				, width: cssW($R, spacing) // ditto
				, top: sC.inset.top + getPaneSize("north", true) // TODO: what if no North pane?
                    //,	top:	$.layout.cssNum($Ps["center"], "top")
                });
            }

            // remove hover classes
            removeHover(o, $R);

            if ($T) {
                if (togLen === 0 || (s.isSliding && o.hideTogglerOnSlide)) {
                    $T.hide(); // always HIDE the toggler when 'sliding'
                    return;
                }
                else
                    $T.show(); // in case was previously hidden

                if (!(togLen > 0) || togLen === "100%" || togLen > paneLen) {
                    togLen = paneLen;
                    offset = 0;
                }
                else { // calculate 'offset' based on options.PANE.togglerAlign_open/closed
                    if (isStr(togAlign)) {
                        switch (togAlign) {
                            case "top":
                            case "left": offset = 0;
                                break;
                            case "bottom":
                            case "right": offset = paneLen - togLen;
                                break;
                            case "middle":
                            case "center":
                            default: offset = round((paneLen - togLen) / 2); // 'default' catches typos
                        }
                    }
                    else { // togAlign = number
                        var x = parseInt(togAlign, 10); //
                        if (togAlign >= 0) offset = x;
                        else offset = paneLen - togLen + x; // NOTE: x is negative!
                    }
                }

                if (dir === "horz") { // north/south
                    var width = cssW($T, togLen);
                    $T.css({
                        width: width  // account for borders & padding
					, height: cssH($T, spacing) // ditto
					, left: offset // TODO: VERIFY that toggler  positions correctly for ALL values
					, top: 0
                    });
                    // CENTER the toggler content SPAN
                    $T.children(".content").each(function () {
                        $TC = $(this);
                        $TC.css("marginLeft", round((width - $TC.outerWidth()) / 2)); // could be negative
                    });
                }
                else { // east/west
                    var height = cssH($T, togLen);
                    $T.css({
                        height: height // account for borders & padding
					, width: cssW($T, spacing) // ditto
					, top: offset // POSITION the toggler
					, left: 0
                    });
                    // CENTER the toggler content SPAN
                    $T.children(".content").each(function () {
                        $TC = $(this);
                        $TC.css("marginTop", round((height - $TC.outerHeight()) / 2)); // could be negative
                    });
                }

                // remove ALL hover classes
                removeHover(0, $T);
            }

            // DONE measuring and sizing this resizer/toggler, so can be 'hidden' now
            if (!state.initialized && (o.initHidden || s.isHidden)) {
                $R.hide();
                if ($T) $T.hide();
            }
        });
    }


        /**
         * @param {(string|Object)}	evt_or_pane
         */
    , enableClosable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, $T = $Ts[pane]
		, o = options[pane]
        ;
        if (!$T) return;
        o.closable = true;
        $T.bind("click." + sID, function (evt) { evt.stopPropagation(); toggle(pane); })
			.css("visibility", "visible")
			.css("cursor", "pointer")
			.attr("title", state[pane].isClosed ? o.tips.Open : o.tips.Close) // may be blank
			.show();
    }
        /**
         * @param {(string|Object)}	evt_or_pane
         * @param {boolean=}			[hide=false]
         */
    , disableClosable = function (evt_or_pane, hide) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, $T = $Ts[pane]
        ;
        if (!$T) return;
        options[pane].closable = false;
        // is closable is disable, then pane MUST be open!
        if (state[pane].isClosed) open(pane, false, true);
        $T.unbind("." + sID)
			.css("visibility", hide ? "hidden" : "visible") // instead of hide(), which creates logic issues
			.css("cursor", "default")
			.attr("title", "");
    }


        /**
         * @param {(string|Object)}	evt_or_pane
         */
    , enableSlidable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, $R = $Rs[pane]
        ;
        if (!$R || !$R.data('draggable')) return;
        options[pane].slidable = true;
        if (state[pane].isClosed)
            bindStartSlidingEvents(pane, true);
    }
        /**
         * @param {(string|Object)}	evt_or_pane
         */
    , disableSlidable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, $R = $Rs[pane]
        ;
        if (!$R) return;
        options[pane].slidable = false;
        if (state[pane].isSliding)
            close(pane, false, true);
        else {
            bindStartSlidingEvents(pane, false);
            $R.css("cursor", "default")
				.attr("title", "");
            removeHover(null, $R[0]); // in case currently hovered
        }
    }


        /**
         * @param {(string|Object)}	evt_or_pane
         */
    , enableResizable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, $R = $Rs[pane]
		, o = options[pane]
        ;
        if (!$R || !$R.data('draggable')) return;
        o.resizable = true;
        $R.draggable("enable");
        if (!state[pane].isClosed)
            $R.css("cursor", o.resizerCursor)
			 	.attr("title", o.tips.Resize);
    }
        /**
         * @param {(string|Object)}	evt_or_pane
         */
    , disableResizable = function (evt_or_pane) {
        if (!isInitialized()) return;
        var pane = evtPane.call(this, evt_or_pane)
		, $R = $Rs[pane]
        ;
        if (!$R || !$R.data('draggable')) return;
        options[pane].resizable = false;
        $R.draggable("disable")
			.css("cursor", "default")
			.attr("title", "");
        removeHover(null, $R[0]); // in case currently hovered
    }


        /**
         * Move a pane from source-side (eg, west) to target-side (eg, east)
         * If pane exists on target-side, move that to source-side, ie, 'swap' the panes
         *
         * @param {(string|Object)}	evt_or_pane1	The pane/edge being swapped
         * @param {string}			pane2			ditto
         */
    , swapPanes = function (evt_or_pane1, pane2) {
        if (!isInitialized()) return;
        var pane1 = evtPane.call(this, evt_or_pane1);
        // change state.edge NOW so callbacks can know where pane is headed...
        state[pane1].edge = pane2;
        state[pane2].edge = pane1;
        // run these even if NOT state.initialized
        if (false === _runCallbacks("onswap_start", pane1)
		 || false === _runCallbacks("onswap_start", pane2)
		) {
            state[pane1].edge = pane1; // reset
            state[pane2].edge = pane2;
            return;
        }

        var
			oPane1 = copy(pane1)
		, oPane2 = copy(pane2)
		, sizes = {}
        ;
        sizes[pane1] = oPane1 ? oPane1.state.size : 0;
        sizes[pane2] = oPane2 ? oPane2.state.size : 0;

        // clear pointers & state
        $Ps[pane1] = false;
        $Ps[pane2] = false;
        state[pane1] = {};
        state[pane2] = {};

        // ALWAYS remove the resizer & toggler elements
        if ($Ts[pane1]) $Ts[pane1].remove();
        if ($Ts[pane2]) $Ts[pane2].remove();
        if ($Rs[pane1]) $Rs[pane1].remove();
        if ($Rs[pane2]) $Rs[pane2].remove();
        $Rs[pane1] = $Rs[pane2] = $Ts[pane1] = $Ts[pane2] = false;

        // transfer element pointers and data to NEW Layout keys
        move(oPane1, pane2);
        move(oPane2, pane1);

        // cleanup objects
        oPane1 = oPane2 = sizes = null;

        // make panes 'visible' again
        if ($Ps[pane1]) $Ps[pane1].css(_c.visible);
        if ($Ps[pane2]) $Ps[pane2].css(_c.visible);

        // fix any size discrepancies caused by swap
        resizeAll();

        // run these even if NOT state.initialized
        _runCallbacks("onswap_end", pane1);
        _runCallbacks("onswap_end", pane2);

        return;

        function copy(n) { // n = pane
            var
				$P = $Ps[n]
			, $C = $Cs[n]
            ;
            return !$P ? false : {
                pane: n
			, P: $P ? $P[0] : false
			, C: $C ? $C[0] : false
			, state: $.extend(true, {}, state[n])
			, options: $.extend(true, {}, options[n])
            }
        };

        function move(oPane, pane) {
            if (!oPane) return;
            var
				P = oPane.P
			, C = oPane.C
			, oldPane = oPane.pane
			, c = _c[pane]
			//	save pane-options that should be retained
			, s = $.extend(true, {}, state[pane])
			, o = options[pane]
			//	RETAIN side-specific FX Settings - more below
			, fx = { resizerCursor: o.resizerCursor }
			, re, size, pos
            ;
            $.each("fxName,fxSpeed,fxSettings".split(","), function (i, k) {
                fx[k + "_open"] = o[k + "_open"];
                fx[k + "_close"] = o[k + "_close"];
                fx[k + "_size"] = o[k + "_size"];
            });

            // update object pointers and attributes
            $Ps[pane] = $(P)
				.data({
				    layoutPane: Instance[pane]	// NEW pointer to pane-alias-object
				, layoutEdge: pane
				})
				.css(_c.hidden)
				.css(c.cssReq)
            ;
            $Cs[pane] = C ? $(C) : false;

            // set options and state
            options[pane] = $.extend(true, {}, oPane.options, fx);
            state[pane] = $.extend(true, {}, oPane.state);

            // change classNames on the pane, eg: ui-layout-pane-east ==> ui-layout-pane-west
            re = new RegExp(o.paneClass + "-" + oldPane, "g");
            P.className = P.className.replace(re, o.paneClass + "-" + pane);

            // ALWAYS regenerate the resizer & toggler elements
            initHandles(pane); // create the required resizer & toggler

            // if moving to different orientation, then keep 'target' pane size
            if (c.dir != _c[oldPane].dir) {
                size = sizes[pane] || 0;
                setSizeLimits(pane); // update pane-state
                size = max(size, state[pane].minSize);
                // use manualSizePane to disable autoResize - not useful after panes are swapped
                manualSizePane(pane, size, true, true); // true/true = skipCallback/noAnimation
            }
            else // move the resizer here
                $Rs[pane].css(c.side, sC.inset[c.side] + (state[pane].isVisible ? getPaneSize(pane) : 0));


            // ADD CLASSNAMES & SLIDE-BINDINGS
            if (oPane.state.isVisible && !s.isVisible)
                setAsOpen(pane, true); // true = skipCallback
            else {
                setAsClosed(pane);
                bindStartSlidingEvents(pane, true); // will enable events IF option is set
            }

            // DESTROY the object
            oPane = null;
        };
    }


        /**
         * INTERNAL method to sync pin-buttons when pane is opened or closed
         * Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
         *
         * @see  open(), setAsOpen(), setAsClosed()
         * @param {string}	pane   These are the params returned to callbacks by layout()
         * @param {boolean}	doPin  True means set the pin 'down', False means 'up'
         */
    , syncPinBtns = function (pane, doPin) {
        if ($.layout.plugins.buttons)
            $.each(state[pane].pins, function (i, selector) {
                $.layout.buttons.setPinState(Instance, $(selector), pane, doPin);
            });
    }

        ;	// END var DECLARATIONS

        /**
         * Capture keys when enableCursorHotkey - toggle pane if hotkey pressed
         *
         * @see  document.keydown()
         */
        function keyDown(evt) {
            if (!evt) return true;
            var code = evt.keyCode;
            if (code < 33) return true; // ignore special keys: ENTER, TAB, etc

            var
                PANE = {
                    38: "north" // Up Cursor	- $.ui.keyCode.UP
                , 40: "south" // Down Cursor	- $.ui.keyCode.DOWN
                , 37: "west"  // Left Cursor	- $.ui.keyCode.LEFT
                , 39: "east"  // Right Cursor	- $.ui.keyCode.RIGHT
                }
            , ALT = evt.altKey // no worky!
            , SHIFT = evt.shiftKey
            , CTRL = evt.ctrlKey
            , CURSOR = (CTRL && code >= 37 && code <= 40)
            , o, k, m, pane
            ;

            if (CURSOR && options[PANE[code]].enableCursorHotkey) // valid cursor-hotkey
                pane = PANE[code];
            else if (CTRL || SHIFT) // check to see if this matches a custom-hotkey
                $.each(_c.borderPanes, function (i, p) { // loop each pane to check its hotkey
                    o = options[p];
                    k = o.customHotkey;
                    m = o.customHotkeyModifier; // if missing or invalid, treated as "CTRL+SHIFT"
                    if ((SHIFT && m == "SHIFT") || (CTRL && m == "CTRL") || (CTRL && SHIFT)) { // Modifier matches
                        if (k && code === (isNaN(k) || k <= 9 ? k.toUpperCase().charCodeAt(0) : k)) { // Key matches
                            pane = p;
                            return false; // BREAK
                        }
                    }
                });

            // validate pane
            if (!pane || !$Ps[pane] || !options[pane].closable || state[pane].isHidden)
                return true;

            toggle(pane);

            evt.stopPropagation();
            evt.returnValue = false; // CANCEL key
            return false;
        };


        /*
         * ######################################
         *	UTILITY METHODS
         *	called externally or by initButtons
         * ######################################
         */

        /**
         * Change/reset a pane overflow setting & zIndex to allow popups/drop-downs to work
         *
         * @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
         */
        function allowOverflow(el) {
            if (!isInitialized()) return;
            if (this && this.tagName) el = this; // BOUND to element
            var $P;
            if (isStr(el))
                $P = $Ps[el];
            else if ($(el).data("layoutRole"))
                $P = $(el);
            else
                $(el).parents().each(function () {
                    if ($(this).data("layoutRole")) {
                        $P = $(this);
                        return false; // BREAK
                    }
                });
            if (!$P || !$P.length) return; // INVALID

            var
                pane = $P.data("layoutEdge")
            , s = state[pane]
            ;

            // if pane is already raised, then reset it before doing it again!
            // this would happen if allowOverflow is attached to BOTH the pane and an element 
            if (s.cssSaved)
                resetOverflow(pane); // reset previous CSS before continuing

            // if pane is raised by sliding or resizing, or its closed, then abort
            if (s.isSliding || s.isResizing || s.isClosed) {
                s.cssSaved = false;
                return;
            }

            var
                newCSS = { zIndex: (options.zIndexes.resizer_normal + 1) }
            , curCSS = {}
            , of = $P.css("overflow")
            , ofX = $P.css("overflowX")
            , ofY = $P.css("overflowY")
            ;
            // determine which, if any, overflow settings need to be changed
            if (of != "visible") {
                curCSS.overflow = of;
                newCSS.overflow = "visible";
            }
            if (ofX && !ofX.match(/(visible|auto)/)) {
                curCSS.overflowX = ofX;
                newCSS.overflowX = "visible";
            }
            if (ofY && !ofY.match(/(visible|auto)/)) {
                curCSS.overflowY = ofX;
                newCSS.overflowY = "visible";
            }

            // save the current overflow settings - even if blank!
            s.cssSaved = curCSS;

            // apply new CSS to raise zIndex and, if necessary, make overflow 'visible'
            $P.css(newCSS);

            // make sure the zIndex of all other panes is normal
            $.each(_c.allPanes, function (i, p) {
                if (p != pane) resetOverflow(p);
            });

        };
        /**
         * @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
         */
        function resetOverflow(el) {
            if (!isInitialized()) return;
            if (this && this.tagName) el = this; // BOUND to element
            var $P;
            if (isStr(el))
                $P = $Ps[el];
            else if ($(el).data("layoutRole"))
                $P = $(el);
            else
                $(el).parents().each(function () {
                    if ($(this).data("layoutRole")) {
                        $P = $(this);
                        return false; // BREAK
                    }
                });
            if (!$P || !$P.length) return; // INVALID

            var
                pane = $P.data("layoutEdge")
            , s = state[pane]
            , CSS = s.cssSaved || {}
            ;
            // reset the zIndex
            if (!s.isSliding && !s.isResizing)
                $P.css("zIndex", options.zIndexes.pane_normal);

            // reset Overflow - if necessary
            $P.css(CSS);

            // clear var
            s.cssSaved = false;
        };

        /*
         * #####################
         * CREATE/RETURN LAYOUT
         * #####################
         */

        // validate that container exists
        var $N = $(this).eq(0); // FIRST matching Container element
        if (!$N.length) {
            return _log(options.errors.containerMissing);
        };

        // Users retrieve Instance of a layout with: $N.layout() OR $N.data("layout")
        // return the Instance-pointer if layout has already been initialized
        if ($N.data("layoutContainer") && $N.data("layout"))
            return $N.data("layout"); // cached pointer

        // init global vars
        var
            $Ps = {}	// Panes x5		- set in initPanes()
        , $Cs = {}	// Content x5	- set in initPanes()
        , $Rs = {}	// Resizers x4	- set in initHandles()
        , $Ts = {}	// Togglers x4	- set in initHandles()
        , $Ms = $([])	// Masks - up to 2 masks per pane (IFRAME + DIV)
        //	aliases for code brevity
        , sC = state.container // alias for easy access to 'container dimensions'
        , sID = state.id // alias for unique layout ID/namespace - eg: "layout435"
        ;

        // create Instance object to expose data & option Properties, and primary action Methods
        var Instance = {
            //	layout data
            options: options			// property - options hash
        , state: state			// property - dimensions hash
            //	object pointers
        , container: $N				// property - object pointers for layout container
        , panes: $Ps				// property - object pointers for ALL Panes: panes.north, panes.center
        , contents: $Cs				// property - object pointers for ALL Content: contents.north, contents.center
        , resizers: $Rs				// property - object pointers for ALL Resizers, eg: resizers.north
        , togglers: $Ts				// property - object pointers for ALL Togglers, eg: togglers.north
            //	border-pane open/close
        , hide: hide			// method - ditto
        , show: show			// method - ditto
        , toggle: toggle			// method - pass a 'pane' ("north", "west", etc)
        , open: open			// method - ditto
        , close: close			// method - ditto
        , slideOpen: slideOpen		// method - ditto
        , slideClose: slideClose		// method - ditto
        , slideToggle: slideToggle		// method - ditto
            //	pane actions
        , setSizeLimits: setSizeLimits	// method - pass a 'pane' - update state min/max data
        , _sizePane: sizePane		// method -intended for user by plugins only!
        , sizePane: manualSizePane	// method - pass a 'pane' AND an 'outer-size' in pixels or percent, or 'auto'
        , sizeContent: sizeContent		// method - pass a 'pane'
        , swapPanes: swapPanes		// method - pass TWO 'panes' - will swap them
        , showMasks: showMasks		// method - pass a 'pane' OR list of panes - default = all panes with mask option set
        , hideMasks: hideMasks		// method - ditto'
            //	pane element methods
        , initContent: initContent		// method - ditto
        , addPane: addPane			// method - pass a 'pane'
        , removePane: removePane		// method - pass a 'pane' to remove from layout, add 'true' to delete the pane-elem
        , createChildren: createChildren	// method - pass a 'pane' and (optional) layout-options (OVERRIDES options[pane].children
        , refreshChildren: refreshChildren	// method - pass a 'pane' and a layout-instance
            //	special pane option setting
        , enableClosable: enableClosable	// method - pass a 'pane'
        , disableClosable: disableClosable	// method - ditto
        , enableSlidable: enableSlidable	// method - ditto
        , disableSlidable: disableSlidable	// method - ditto
        , enableResizable: enableResizable	// method - ditto
        , disableResizable: disableResizable// method - ditto
            //	utility methods for panes
        , allowOverflow: allowOverflow	// utility - pass calling element (this)
        , resetOverflow: resetOverflow	// utility - ditto
            //	layout control
        , destroy: destroy			// method - no parameters
        , initPanes: isInitialized	// method - no parameters
        , resizeAll: resizeAll		// method - no parameters
            //	callback triggering
        , runCallbacks: _runCallbacks	// method - pass evtName & pane (if a pane-event), eg: trigger("onopen", "west")
            //	alias collections of options, state and children - created in addPane and extended elsewhere
        , hasParentLayout: false			// set by initContainer()
        , children: children		// pointers to child-layouts, eg: Instance.children.west.layoutName
        , north: false			// alias group: { name: pane, pane: $Ps[pane], options: options[pane], state: state[pane], children: children[pane] }
        , south: false			// ditto
        , west: false			// ditto
        , east: false			// ditto
        , center: false			// ditto
        };

        // create the border layout NOW
        if (_create() === 'cancel') // onload_start callback returned false to CANCEL layout creation
            return null;
        else // true OR false -- if layout-elements did NOT init (hidden or do not exist), can auto-init later
            return Instance; // return the Instance object

    }


})(jQuery);




/**
 * jquery.layout.state 1.2
 * $Date: 2014-08-30 08:00:00 (Sat, 30 Aug 2014) $
 *
 * Copyright (c) 2014 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @requires: UI Layout 1.4.0 or higher
 * @requires: $.ui.cookie (above)
 *
 * @see: http://groups.google.com/group/jquery-ui-layout
 */
; (function ($) {

    if (!$.layout) return;


    /**
     *	UI COOKIE UTILITY
     *
     *	A $.cookie OR $.ui.cookie namespace *should be standard*, but until then...
     *	This creates $.ui.cookie so Layout does not need the cookie.jquery.js plugin
     *	NOTE: This utility is REQUIRED by the layout.state plugin
     *
     *	Cookie methods in Layout are created as part of State Management 
     */
    if (!$.ui) $.ui = {};
    $.ui.cookie = {

        // cookieEnabled is not in DOM specs, but DOES works in all browsers,including IE6
        acceptsCookies: !!navigator.cookieEnabled

    , read: function (name) {
        var
			c = document.cookie
		, cs = c ? c.split(';') : []
		, pair, data, i
        ;
        for (i = 0; pair = cs[i]; i++) {
            data = $.trim(pair).split('='); // name=value => [ name, value ]
            if (data[0] == name) // found the layout cookie
                return decodeURIComponent(data[1]);
        }
        return null;
    }

    , write: function (name, val, cookieOpts) {
        var params = ""
		, date = ""
		, clear = false
		, o = cookieOpts || {}
		, x = o.expires || null
		, t = $.type(x)
        ;
        if (t === "date")
            date = x;
        else if (t === "string" && x > 0) {
            x = parseInt(x, 10);
            t = "number";
        }
        if (t === "number") {
            date = new Date();
            if (x > 0)
                date.setDate(date.getDate() + x);
            else {
                date.setFullYear(1970);
                clear = true;
            }
        }
        if (date) params += ";expires=" + date.toUTCString();
        if (o.path) params += ";path=" + o.path;
        if (o.domain) params += ";domain=" + o.domain;
        if (o.secure) params += ";secure";
        document.cookie = name + "=" + (clear ? "" : encodeURIComponent(val)) + params; // write or clear cookie
    }

    , clear: function (name) {
        $.ui.cookie.write(name, "", { expires: -1 });
    }

    };
    // if cookie.jquery.js is not loaded, create an alias to replicate it
    // this may be useful to other plugins or code dependent on that plugin
    if (!$.cookie) $.cookie = function (k, v, o) {
        var C = $.ui.cookie;
        if (v === null)
            C.clear(k);
        else if (v === undefined)
            return C.read(k);
        else
            C.write(k, v, o);
    };



    /**
     *	State-management options stored in options.stateManagement, which includes a .cookie hash
     *	Default options saves ALL KEYS for ALL PANES, ie: pane.size, pane.isClosed, pane.isHidden
     *
     *	// STATE/COOKIE OPTIONS
     *	@example $(el).layout({
                    stateManagement: {
                        enabled:	true
                    ,	stateKeys:	"east.size,west.size,east.isClosed,west.isClosed"
                    ,	cookie:		{ name: "appLayout", path: "/" }
                    }
                })
     *	@example $(el).layout({ stateManagement__enabled: true }) // enable auto-state-management using cookies
     *	@example $(el).layout({ stateManagement__cookie: { name: "appLayout", path: "/" } })
     *	@example $(el).layout({ stateManagement__cookie__name: "appLayout", stateManagement__cookie__path: "/" })
     *
     *	// STATE/COOKIE METHODS
     *	@example myLayout.saveCookie( "west.isClosed,north.size,south.isHidden", {expires: 7} );
     *	@example myLayout.loadCookie();
     *	@example myLayout.deleteCookie();
     *	@example var JSON = myLayout.readState();	// CURRENT Layout State
     *	@example var JSON = myLayout.readCookie();	// SAVED Layout State (from cookie)
     *	@example var JSON = myLayout.state.stateData;	// LAST LOADED Layout State (cookie saved in layout.state hash)
     *
     *	CUSTOM STATE-MANAGEMENT (eg, saved in a database)
     *	@example var JSON = myLayout.readState( "west.isClosed,north.size,south.isHidden" );
     *	@example myLayout.loadState( JSON );
     */

    // tell Layout that the state plugin is available
    $.layout.plugins.stateManagement = true;

    //	Add State-Management options to layout.defaults
    $.layout.defaults.stateManagement = {
        enabled: false	// true = enable state-management, even if not using cookies
    , autoSave: true	// Save a state-cookie when page exits?
    , autoLoad: true	// Load the state-cookie when Layout inits?
    , animateLoad: true	// animate panes when loading state into an active layout
    , includeChildren: true	// recurse into child layouts to include their state as well
        // List state-data to save - must be pane-specific
    , stateKeys: "north.size,south.size,east.size,west.size," +
                    "north.isClosed,south.isClosed,east.isClosed,west.isClosed," +
                    "north.isHidden,south.isHidden,east.isHidden,west.isHidden"
    , cookie: {
        name: ""	// If not specified, will use Layout.name, else just "Layout"
        , domain: ""	// blank = current domain
        , path: ""	// blank = current page, "/" = entire website
        , expires: ""	// 'days' to keep cookie - leave blank for 'session cookie'
        , secure: false
    }
    };

    // Set stateManagement as a 'layout-option', NOT a 'pane-option'
    $.layout.optionsMap.layout.push("stateManagement");
    // Update config so layout does not move options into the pane-default branch (panes)
    $.layout.config.optionRootKeys.push("stateManagement");

    /*
     *	State Management methods
     */
    $.layout.state = {

        /**
         * Get the current layout state and save it to a cookie
         *
         * myLayout.saveCookie( keys, cookieOpts )
         *
         * @param {Object}			inst
         * @param {(string|Array)=}	keys
         * @param {Object=}			cookieOpts
         */
        saveCookie: function (inst, keys, cookieOpts) {
            var o = inst.options
            , sm = o.stateManagement
            , oC = $.extend(true, {}, sm.cookie, cookieOpts || null)
            , data = inst.state.stateData = inst.readState(keys || sm.stateKeys) // read current panes-state
            ;
            $.ui.cookie.write(oC.name || o.name || "Layout", $.layout.state.encodeJSON(data), oC);
            return $.extend(true, {}, data); // return COPY of state.stateData data
        }

        /**
         * Remove the state cookie
         *
         * @param {Object}	inst
         */
    , deleteCookie: function (inst) {
        var o = inst.options;
        $.ui.cookie.clear(o.stateManagement.cookie.name || o.name || "Layout");
    }

        /**
         * Read & return data from the cookie - as JSON
         *
         * @param {Object}	inst
         */
    , readCookie: function (inst) {
        var o = inst.options;
        var c = $.ui.cookie.read(o.stateManagement.cookie.name || o.name || "Layout");
        // convert cookie string back to a hash and return it
        return c ? $.layout.state.decodeJSON(c) : {};
    }

        /**
         * Get data from the cookie and USE IT to loadState
         *
         * @param {Object}	inst
         */
    , loadCookie: function (inst) {
        var c = $.layout.state.readCookie(inst); // READ the cookie
        if (c && !$.isEmptyObject(c)) {
            inst.state.stateData = $.extend(true, {}, c); // SET state.stateData
            inst.loadState(c); // LOAD the retrieved state
        }
        return c;
    }

        /**
         * Update layout options from the cookie, if one exists
         *
         * @param {Object}		inst
         * @param {Object=}		stateData
         * @param {boolean=}	animate
         */
    , loadState: function (inst, data, opts) {
        if (!$.isPlainObject(data) || $.isEmptyObject(data)) return;

        // normalize data & cache in the state object
        data = inst.state.stateData = $.layout.transformData(data); // panes = default subkey

        // add missing/default state-restore options
        var smo = inst.options.stateManagement;
        opts = $.extend({
            animateLoad: false //smo.animateLoad
		, includeChildren: smo.includeChildren
        }, opts);

        if (!inst.state.initialized) {
            /*
			 *	layout NOT initialized, so just update its options
			 */
            // MUST remove pane.children keys before applying to options
            // use a copy so we don't remove keys from original data
            var o = $.extend(true, {}, data);
            //delete o.center; // center has no state-data - only children
            $.each($.layout.config.allPanes, function (idx, pane) {
                if (o[pane]) delete o[pane].children;
            });
            // update CURRENT layout-options with saved state data
            $.extend(true, inst.options, o);
        }
        else {
            /*
			 *	layout already initialized, so modify layout's configuration
			 */
            var noAnimate = !opts.animateLoad
			, o, c, h, state, open
            ;
            $.each($.layout.config.borderPanes, function (idx, pane) {
                o = data[pane];
                if (!$.isPlainObject(o)) return; // no key, skip pane

                s = o.size;
                c = o.initClosed;
                h = o.initHidden;
                ar = o.autoResize
                state = inst.state[pane];
                open = state.isVisible;

                // reset autoResize
                if (ar)
                    state.autoResize = ar;
                // resize BEFORE opening
                if (!open)
                    inst._sizePane(pane, s, false, false, false); // false=skipCallback/noAnimation/forceResize
                // open/close as necessary - DO NOT CHANGE THIS ORDER!
                if (h === true) inst.hide(pane, noAnimate);
                else if (c === true) inst.close(pane, false, noAnimate);
                else if (c === false) inst.open(pane, false, noAnimate);
                else if (h === false) inst.show(pane, false, noAnimate);
                // resize AFTER any other actions
                if (open)
                    inst._sizePane(pane, s, false, false, noAnimate); // animate resize if option passed
            });

            /*
			 *	RECURSE INTO CHILD-LAYOUTS
			 */
            if (opts.includeChildren) {
                var paneStateChildren, childState;
                $.each(inst.children, function (pane, paneChildren) {
                    paneStateChildren = data[pane] ? data[pane].children : 0;
                    if (paneStateChildren && paneChildren) {
                        $.each(paneChildren, function (stateKey, child) {
                            childState = paneStateChildren[stateKey];
                            if (child && childState)
                                child.loadState(childState);
                        });
                    }
                });
            }
        }
    }

        /**
         * Get the *current layout state* and return it as a hash
         *
         * @param {Object=}		inst	// Layout instance to get state for
         * @param {object=}		[opts]	// State-Managements override options
         */
    , readState: function (inst, opts) {
        // backward compatility
        if ($.type(opts) === 'string') opts = { keys: opts };
        if (!opts) opts = {};
        var sm = inst.options.stateManagement
		, ic = opts.includeChildren
		, recurse = ic !== undefined ? ic : sm.includeChildren
		, keys = opts.stateKeys || sm.stateKeys
		, alt = { isClosed: 'initClosed', isHidden: 'initHidden' }
		, state = inst.state
		, panes = $.layout.config.allPanes
		, data = {}
		, pair, pane, key, val
		, ps, pC, child, array, count, branch
        ;
        if ($.isArray(keys)) keys = keys.join(",");
        // convert keys to an array and change delimiters from '__' to '.'
        keys = keys.replace(/__/g, ".").split(',');
        // loop keys and create a data hash
        for (var i = 0, n = keys.length; i < n; i++) {
            pair = keys[i].split(".");
            pane = pair[0];
            key = pair[1];
            if ($.inArray(pane, panes) < 0) continue; // bad pane!
            val = state[pane][key];
            if (val == undefined) continue;
            if (key == "isClosed" && state[pane]["isSliding"])
                val = true; // if sliding, then *really* isClosed
            (data[pane] || (data[pane] = {}))[alt[key] ? alt[key] : key] = val;
        }

        // recurse into the child-layouts for each pane
        if (recurse) {
            $.each(panes, function (idx, pane) {
                pC = inst.children[pane];
                ps = state.stateData[pane];
                if ($.isPlainObject(pC) && !$.isEmptyObject(pC)) {
                    // ensure a key exists for this 'pane', eg: branch = data.center
                    branch = data[pane] || (data[pane] = {});
                    if (!branch.children) branch.children = {};
                    $.each(pC, function (key, child) {
                        // ONLY read state from an initialize layout
                        if (child.state.initialized)
                            branch.children[key] = $.layout.state.readState(child);
                            // if we have PREVIOUS (onLoad) state for this child-layout, KEEP IT!
                        else if (ps && ps.children && ps.children[key]) {
                            branch.children[key] = $.extend(true, {}, ps.children[key]);
                        }
                    });
                }
            });
        }

        return data;
    }

        /**
         *	Stringify a JSON hash so can save in a cookie or db-field
         */
    , encodeJSON: function (json) {
        var local = window.JSON || {};
        return (local.stringify || stringify)(json);

        function stringify(h) {
            var D = [], i = 0, k, v, t // k = key, v = value
			, a = $.isArray(h)
            ;
            for (k in h) {
                v = h[k];
                t = typeof v;
                if (t == 'string')		// STRING - add quotes
                    v = '"' + v + '"';
                else if (t == 'object')	// SUB-KEY - recurse into it
                    v = parse(v);
                D[i++] = (!a ? '"' + k + '":' : '') + v;
            }
            return (a ? '[' : '{') + D.join(',') + (a ? ']' : '}');
        };
    }

        /**
         *	Convert stringified JSON back to a hash object
         *	@see		$.parseJSON(), adding in jQuery 1.4.1
         */
    , decodeJSON: function (str) {
        try { return $.parseJSON ? $.parseJSON(str) : window["eval"]("(" + str + ")") || {}; }
        catch (e) { return {}; }
    }


    , _create: function (inst) {
        var s = $.layout.state
		, o = inst.options
		, sm = o.stateManagement
        ;
        //	ADD State-Management plugin methods to inst
        $.extend(inst, {
            //	readCookie - update options from cookie - returns hash of cookie data
            readCookie: function () { return s.readCookie(inst); }
            //	deleteCookie
       , deleteCookie: function () { s.deleteCookie(inst); }
            //	saveCookie - optionally pass keys-list and cookie-options (hash)
       , saveCookie: function (keys, cookieOpts) { return s.saveCookie(inst, keys, cookieOpts); }
            //	loadCookie - readCookie and use to loadState() - returns hash of cookie data
       , loadCookie: function () { return s.loadCookie(inst); }
            //	loadState - pass a hash of state to use to update options
       , loadState: function (stateData, opts) { s.loadState(inst, stateData, opts); }
            //	readState - returns hash of current layout-state
       , readState: function (keys) { return s.readState(inst, keys); }
            //	add JSON utility methods too...
       , encodeJSON: s.encodeJSON
       , decodeJSON: s.decodeJSON
        });

        // init state.stateData key, even if plugin is initially disabled
        inst.state.stateData = {};

        // autoLoad MUST BE one of: data-array, data-hash, callback-function, or TRUE
        if (!sm.autoLoad) return;

        //	When state-data exists in the autoLoad key USE IT,
        //	even if stateManagement.enabled == false
        if ($.isPlainObject(sm.autoLoad)) {
            if (!$.isEmptyObject(sm.autoLoad)) {
                inst.loadState(sm.autoLoad);
            }
        }
        else if (sm.enabled) {
            // update the options from cookie or callback
            // if options is a function, call it to get stateData
            if ($.isFunction(sm.autoLoad)) {
                var d = {};
                try {
                    d = sm.autoLoad(inst, inst.state, inst.options, inst.options.name || ''); // try to get data from fn
                } catch (e) { }
                if (d && $.isPlainObject(d) && !$.isEmptyObject(d))
                    inst.loadState(d);
            }
            else // any other truthy value will trigger loadCookie
                inst.loadCookie();
        }
    }

    , _unload: function (inst) {
        var sm = inst.options.stateManagement;
        if (sm.enabled && sm.autoSave) {
            // if options is a function, call it to save the stateData
            if ($.isFunction(sm.autoSave)) {
                try {
                    sm.autoSave(inst, inst.state, inst.options, inst.options.name || ''); // try to get data from fn
                } catch (e) { }
            }
            else // any truthy value will trigger saveCookie
                inst.saveCookie();
        }
    }

    };

    // add state initialization method to Layout's onCreate array of functions
    $.layout.onCreate.push($.layout.state._create);
    $.layout.onUnload.push($.layout.state._unload);

})(jQuery);



/**
 * @preserve jquery.layout.buttons 1.0
 * $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $
 *
 * Copyright (c) 2011 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @dependancies: UI Layout 1.3.0.rc30.1 or higher
 *
 * @support: http://groups.google.com/group/jquery-ui-layout
 *
 * Docs: [ to come ]
 * Tips: [ to come ]
 */
; (function ($) {

    if (!$.layout) return;


    // tell Layout that the state plugin is available
    $.layout.plugins.buttons = true;

    //	Add State-Management options to layout.defaults
    $.layout.defaults.autoBindCustomButtons = false;
    // Set stateManagement as a layout-option, NOT a pane-option
    $.layout.optionsMap.layout.push("autoBindCustomButtons");

    /*
     *	Button methods
     */
    $.layout.buttons = {
        // set data used by multiple methods below
        config: {
            borderPanes: "north,south,west,east"
        }

        /**
        * Searches for .ui-layout-button-xxx elements and auto-binds them as layout-buttons
        *
        * @see  _create()
        */
    , init: function (inst) {
        var pre = "ui-layout-button-"
		, layout = inst.options.name || ""
		, name;
        $.each("toggle,open,close,pin,toggle-slide,open-slide".split(","), function (i, action) {
            $.each($.layout.buttons.config.borderPanes.split(","), function (ii, pane) {
                $("." + pre + action + "-" + pane).each(function () {
                    // if button was previously 'bound', data.layoutName was set, but is blank if layout has no 'name'
                    name = $(this).data("layoutName") || $(this).attr("layoutName");
                    if (name == undefined || name === layout)
                        inst.bindButton(this, action, pane);
                });
            });
        });
    }

        /**
        * Helper function to validate params received by addButton utilities
        *
        * Two classes are added to the element, based on the buttonClass...
        * The type of button is appended to create the 2nd className:
        *  - ui-layout-button-pin
        *  - ui-layout-pane-button-toggle
        *  - ui-layout-pane-button-open
        *  - ui-layout-pane-button-close
        *
        * @param  {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
        * @param  {string}   			pane 		Name of the pane the button is for: 'north', 'south', etc.
        * @return {Array.<Object>}		If both params valid, the element matching 'selector' in a jQuery wrapper - otherwise returns null
        */
    , get: function (inst, selector, pane, action) {
        var $E = $(selector)
		, o = inst.options
        //,	err	= o.showErrorMessages
        ;
        if ($E.length && $.layout.buttons.config.borderPanes.indexOf(pane) >= 0) {
            var btn = o[pane].buttonClass + "-" + action;
            $E.addClass(btn + " " + btn + "-" + pane)
				.data("layoutName", o.name); // add layout identifier - even if blank!
        }
        return $E;
    }


        /**
        * NEW syntax for binding layout-buttons - will eventually replace addToggle, addOpen, etc.
        *
        * @param {(string|!Object)}	sel		jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
        * @param {string}			action
        * @param {string}			pane
        */
    , bind: function (inst, sel, action, pane) {
        var _ = $.layout.buttons;
        switch (action.toLowerCase()) {
            case "toggle": _.addToggle(inst, sel, pane); break;
            case "open": _.addOpen(inst, sel, pane); break;
            case "close": _.addClose(inst, sel, pane); break;
            case "pin": _.addPin(inst, sel, pane); break;
            case "toggle-slide": _.addToggle(inst, sel, pane, true); break;
            case "open-slide": _.addOpen(inst, sel, pane, true); break;
        }
        return inst;
    }

        /**
        * Add a custom Toggler button for a pane
        *
        * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
        * @param {string}  			pane 		Name of the pane the button is for: 'north', 'south', etc.
        * @param {boolean=}			slide 		true = slide-open, false = pin-open
        */
    , addToggle: function (inst, selector, pane, slide) {
        $.layout.buttons.get(inst, selector, pane, "toggle")
			.click(function (evt) {
			    inst.toggle(pane, !!slide);
			    evt.stopPropagation();
			});
        return inst;
    }

        /**
        * Add a custom Open button for a pane
        *
        * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
        * @param {string}			pane 		Name of the pane the button is for: 'north', 'south', etc.
        * @param {boolean=}			slide 		true = slide-open, false = pin-open
        */
    , addOpen: function (inst, selector, pane, slide) {
        $.layout.buttons.get(inst, selector, pane, "open")
			.attr("title", inst.options[pane].tips.Open)
			.click(function (evt) {
			    inst.open(pane, !!slide);
			    evt.stopPropagation();
			});
        return inst;
    }

        /**
        * Add a custom Close button for a pane
        *
        * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
        * @param {string}   		pane 		Name of the pane the button is for: 'north', 'south', etc.
        */
    , addClose: function (inst, selector, pane) {
        $.layout.buttons.get(inst, selector, pane, "close")
			.attr("title", inst.options[pane].tips.Close)
			.click(function (evt) {
			    inst.close(pane);
			    evt.stopPropagation();
			});
        return inst;
    }

        /**
        * Add a custom Pin button for a pane
        *
        * Four classes are added to the element, based on the paneClass for the associated pane...
        * Assuming the default paneClass and the pin is 'up', these classes are added for a west-pane pin:
        *  - ui-layout-pane-pin
        *  - ui-layout-pane-west-pin
        *  - ui-layout-pane-pin-up
        *  - ui-layout-pane-west-pin-up
        *
        * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
        * @param {string}   		pane 		Name of the pane the pin is for: 'north', 'south', etc.
        */
    , addPin: function (inst, selector, pane) {
        var $E = $.layout.buttons.get(inst, selector, pane, "pin");
        if ($E.length) {
            var s = inst.state[pane];
            $E.click(function (evt) {
                $.layout.buttons.setPinState(inst, $(this), pane, (s.isSliding || s.isClosed));
                if (s.isSliding || s.isClosed) inst.open(pane); // change from sliding to open
                else inst.close(pane); // slide-closed
                evt.stopPropagation();
            });
            // add up/down pin attributes and classes
            $.layout.buttons.setPinState(inst, $E, pane, (!s.isClosed && !s.isSliding));
            // add this pin to the pane data so we can 'sync it' automatically
            // PANE.pins key is an array so we can store multiple pins for each pane
            s.pins.push(selector); // just save the selector string
        }
        return inst;
    }

        /**
        * Change the class of the pin button to make it look 'up' or 'down'
        *
        * @see  addPin(), syncPins()
        * @param {Array.<Object>}	$Pin	The pin-span element in a jQuery wrapper
        * @param {string}	pane	These are the params returned to callbacks by layout()
        * @param {boolean}	doPin	true = set the pin 'down', false = set it 'up'
        */
    , setPinState: function (inst, $Pin, pane, doPin) {
        var updown = $Pin.attr("pin");
        if (updown && doPin === (updown == "down")) return; // already in correct state
        var
			po = inst.options[pane]
		, lang = po.tips
		, pin = po.buttonClass + "-pin"
		, side = pin + "-" + pane
		, UP = pin + "-up " + side + "-up"
		, DN = pin + "-down " + side + "-down"
        ;
        $Pin
			.attr("pin", doPin ? "down" : "up") // logic
			.attr("title", doPin ? lang.Unpin : lang.Pin)
			.removeClass(doPin ? UP : DN)
			.addClass(doPin ? DN : UP)
        ;
    }

        /**
        * INTERNAL function to sync 'pin buttons' when pane is opened or closed
        * Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
        *
        * @see  open(), close()
        * @param {string}	pane   These are the params returned to callbacks by layout()
        * @param {boolean}	doPin  True means set the pin 'down', False means 'up'
        */
    , syncPinBtns: function (inst, pane, doPin) {
        // REAL METHOD IS _INSIDE_ LAYOUT - THIS IS HERE JUST FOR REFERENCE
        $.each(state[pane].pins, function (i, selector) {
            $.layout.buttons.setPinState(inst, $(selector), pane, doPin);
        });
    }


    , _load: function (inst) {
        //	ADD Button methods to Layout Instance
        $.extend(inst, {
            bindButton: function (selector, action, pane) { return $.layout.buttons.bind(inst, selector, action, pane); }
            //	DEPRECATED METHODS...
		, addToggleBtn: function (selector, pane, slide) { return $.layout.buttons.addToggle(inst, selector, pane, slide); }
		, addOpenBtn: function (selector, pane, slide) { return $.layout.buttons.addOpen(inst, selector, pane, slide); }
		, addCloseBtn: function (selector, pane) { return $.layout.buttons.addClose(inst, selector, pane); }
		, addPinBtn: function (selector, pane) { return $.layout.buttons.addPin(inst, selector, pane); }
        });

        // init state array to hold pin-buttons
        for (var i = 0; i < 4; i++) {
            var pane = $.layout.buttons.config.borderPanes[i];
            inst.state[pane].pins = [];
        }

        // auto-init buttons onLoad if option is enabled
        if (inst.options.autoBindCustomButtons)
            $.layout.buttons.init(inst);
    }

    , _unload: function (inst) {
        // TODO: unbind all buttons???
    }

    };

    // add initialization method to Layout's onLoad array of functions
    $.layout.onLoad.push($.layout.buttons._load);
    //$.layout.onUnload.push( $.layout.buttons._unload );

})(jQuery);




/**
 * jquery.layout.browserZoom 1.0
 * $Date: 2011-12-29 08:00:00 (Thu, 29 Dec 2011) $
 *
 * Copyright (c) 2012 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @requires: UI Layout 1.3.0.rc30.1 or higher
 *
 * @see: http://groups.google.com/group/jquery-ui-layout
 *
 * TODO: Extend logic to handle other problematic zooming in browsers
 * TODO: Add hotkey/mousewheel bindings to _instantly_ respond to these zoom event
 */
(function ($) {

    // tell Layout that the plugin is available
    $.layout.plugins.browserZoom = true;

    $.layout.defaults.browserZoomCheckInterval = 1000;
    $.layout.optionsMap.layout.push("browserZoomCheckInterval");

    /*
     *	browserZoom methods
     */
    $.layout.browserZoom = {

        _init: function (inst) {
            // abort if browser does not need this check
            if ($.layout.browserZoom.ratio() !== false)
                $.layout.browserZoom._setTimer(inst);
        }

    , _setTimer: function (inst) {
        // abort if layout destroyed or browser does not need this check
        if (inst.destroyed) return;
        var o = inst.options
		, s = inst.state
		//	don't need check if inst has parentLayout, but check occassionally in case parent destroyed!
		//	MINIMUM 100ms interval, for performance
		, ms = inst.hasParentLayout ? 5000 : Math.max(o.browserZoomCheckInterval, 100)
        ;
        // set the timer
        setTimeout(function () {
            if (inst.destroyed || !o.resizeWithWindow) return;
            var d = $.layout.browserZoom.ratio();
            if (d !== s.browserZoom) {
                s.browserZoom = d;
                inst.resizeAll();
            }
            // set a NEW timeout
            $.layout.browserZoom._setTimer(inst);
        }
		, ms);
    }

    , ratio: function () {
        var w = window
		, s = screen
		, d = document
		, dE = d.documentElement || d.body
		, b = $.layout.browser
		, v = b.version
		, r, sW, cW
        ;
        // we can ignore all browsers that fire window.resize event onZoom
        if (!b.msie || v > 8)
            return false; // don't need to track zoom
        if (s.deviceXDPI && s.systemXDPI) // syntax compiler hack
            return calc(s.deviceXDPI, s.systemXDPI);
        // everything below is just for future reference!
        if (b.webkit && (r = d.body.getBoundingClientRect))
            return calc((r.left - r.right), d.body.offsetWidth);
        if (b.webkit && (sW = w.outerWidth))
            return calc(sW, w.innerWidth);
        if ((sW = s.width) && (cW = dE.clientWidth))
            return calc(sW, cW);
        return false; // no match, so cannot - or don't need to - track zoom

        function calc(x, y) { return (parseInt(x, 10) / parseInt(y, 10) * 100).toFixed(); }
    }

    };
    // add initialization method to Layout's onLoad array of functions
    $.layout.onReady.push($.layout.browserZoom._init);


})(jQuery);




/**
 *	UI Layout Plugin: Slide-Offscreen Animation
 *
 *	Prevent panes from being 'hidden' so that an iframes/objects 
 *	does not reload/refresh when pane 'opens' again.
 *	This plug-in adds a new animation called "slideOffscreen".
 *	It is identical to the normal "slide" effect, but avoids hiding the element
 *
 *	Requires Layout 1.3.0.RC30.1 or later for Close offscreen
 *	Requires Layout 1.3.0.RC30.5 or later for Hide, initClosed & initHidden offscreen
 *
 *	Version:	1.1 - 2012-11-18
 *	Author:		Kevin Dalman (kevin@jquery-dev.com)
 *	@preserve	jquery.layout.slideOffscreen-1.1.js
 */
; (function ($) {

    // Add a new "slideOffscreen" effect
    if ($.effects) {

        // add an option so initClosed and initHidden will work
        $.layout.defaults.panes.useOffscreenClose = false; // user must enable when needed
        /* set the new animation as the default for all panes
        $.layout.defaults.panes.fxName = "slideOffscreen";
        */

        if ($.layout.plugins)
            $.layout.plugins.effects.slideOffscreen = true;

        // dupe 'slide' effect defaults as new effect defaults
        $.layout.effects.slideOffscreen = $.extend(true, {}, $.layout.effects.slide);

        // add new effect to jQuery UI
        $.effects.slideOffscreen = function (o) {
            return this.queue(function () {

                var fx = $.effects
                , opt = o.options
                , $el = $(this)
                , pane = $el.data('layoutEdge')
                , state = $el.data('parentLayout').state
                , dist = state[pane].size
                , s = this.style
                , props = ['top', 'bottom', 'left', 'right']
                    // Set options
                , mode = fx.setMode($el, opt.mode || 'show') // Set Mode
                , show = (mode == 'show')
                , dir = opt.direction || 'left' // Default Direction
                , ref = (dir == 'up' || dir == 'down') ? 'top' : 'left'
                , pos = (dir == 'up' || dir == 'left')
                , offscrn = $.layout.config.offscreenCSS || {}
                , keyLR = $.layout.config.offscreenReset
                , keyTB = 'offscreenResetTop' // only used internally
                , animation = {}
                ;
                // Animation settings
                animation[ref] = (show ? (pos ? '+=' : '-=') : (pos ? '-=' : '+=')) + dist;

                if (show) { // show() animation, so save top/bottom but retain left/right set when 'hidden'
                    $el.data(keyTB, { top: s.top, bottom: s.bottom });

                    // set the top or left offset in preparation for animation
                    // Note: ALL animations work by shifting the top or left edges
                    if (pos) { // top (north) or left (west)
                        $el.css(ref, isNaN(dist) ? "-" + dist : -dist); // Shift outside the left/top edge
                    }
                    else { // bottom (south) or right (east) - shift all the way across container
                        if (dir === 'right')
                            $el.css({ left: state.container.layoutWidth, right: 'auto' });
                        else // dir === bottom
                            $el.css({ top: state.container.layoutHeight, bottom: 'auto' });
                    }
                    // restore the left/right setting if is a top/bottom animation
                    if (ref === 'top')
                        $el.css($el.data(keyLR) || {});
                }
                else { // hide() animation, so save ALL CSS
                    $el.data(keyTB, { top: s.top, bottom: s.bottom });
                    $el.data(keyLR, { left: s.left, right: s.right });
                }

                // Animate
                $el.show().animate(animation, {
                    queue: false, duration: o.duration, easing: opt.easing, complete: function () {
                        // Restore top/bottom
                        if ($el.data(keyTB))
                            $el.css($el.data(keyTB)).removeData(keyTB);
                        if (show) // Restore left/right too
                            $el.css($el.data(keyLR) || {}).removeData(keyLR);
                        else // Move the pane off-screen (left: -99999, right: 'auto')
                            $el.css(offscrn);

                        if (o.callback) o.callback.apply(this, arguments); // Callback
                        $el.dequeue();
                    }
                });

            });
        };

    }

})(jQuery);

/*
 ### jQuery XML to JSON Plugin v1.3 - 2013-02-18 ###
 * http://www.fyneworks.com/ - diego@fyneworks.com
	* Licensed under http://en.wikipedia.org/wiki/MIT_License
 ###
 Website: http://www.fyneworks.com/jquery/xml-to-json/
*//*
 # INSPIRED BY: http://www.terracoder.com/
           AND: http://www.thomasfrank.se/xml_to_json.html
											AND: http://www.kawa.net/works/js/xml/objtree-e.html
*//*
 This simple script converts XML (document of code) into a JSON object. It is the combination of 2
 'xml to json' great parsers (see below) which allows for both 'simple' and 'extended' parsing modes.
*/
// Avoid collisions
; if (window.jQuery) (function ($) {
  // Add function to jQuery namespace
  $.extend({
    // converts xml documents and xml text to json object
    xml2json: function (xml, extended) {
      if (!xml) return {}; // quick fail

      //### PARSER LIBRARY
      // Core function
      function parseXML(node, simple) {
        if (!node) return null;
        var txt = '', obj = null, att = null;
        var nt = node.nodeType, nn = jsVar(node.localName || node.nodeName);
        var nv = node.text || node.nodeValue || '';
        /*DBG*/ //if(window.console) console.log(['x2j',nn,nt,nv.length+' bytes']);
        if (node.childNodes) {
          if (node.childNodes.length > 0) {
            /*DBG*/ //if(window.console) console.log(['x2j',nn,'CHILDREN',node.childNodes]);
            $.each(node.childNodes, function (n, cn) {
              var cnt = cn.nodeType, cnn = jsVar(cn.localName || cn.nodeName);
              var cnv = cn.text || cn.nodeValue || '';
              /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>a',cnn,cnt,cnv]);
              if (cnt == 8) {
                /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>b',cnn,'COMMENT (ignore)']);
                return; // ignore comment node
              }
              else if (cnt == 3 || cnt == 4 || !cnn) {
                // ignore white-space in between tags
                if (cnv.match(/^\s+$/)) {
                  /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>c',cnn,'WHITE-SPACE (ignore)']);
                  return;
                };
                /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>d',cnn,'TEXT']);
                txt += cnv.replace(/^\s+/, '').replace(/\s+$/, '');
                // make sure we ditch trailing spaces from markup
              }
              else {
                /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>e',cnn,'OBJECT']);
                obj = obj || {};
                if (obj[cnn]) {
                  /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>f',cnn,'ARRAY']);

                  // http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
                  if (!obj[cnn].length) obj[cnn] = myArr(obj[cnn]);
                  obj[cnn] = myArr(obj[cnn]);

                  obj[cnn][obj[cnn].length] = parseXML(cn, true/* simple */);
                  obj[cnn].length = obj[cnn].length;
                }
                else {
                  /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>g',cnn,'dig deeper...']);
                  obj[cnn] = parseXML(cn);
                };
              };
            });
          };//node.childNodes.length>0
        };//node.childNodes
        if (node.attributes) {
          if (node.attributes.length > 0) {
            /*DBG*/ //if(window.console) console.log(['x2j',nn,'ATTRIBUTES',node.attributes])
            att = {}; obj = obj || {};
            $.each(node.attributes, function (a, at) {
              var atn = jsVar(at.name), atv = at.value;
              att[atn] = atv;
              if (obj[atn]) {
                /*DBG*/ //if(window.console) console.log(['x2j',nn,'attr>',atn,'ARRAY']);

                // http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
                //if(!obj[atn].length) obj[atn] = myArr(obj[atn]);//[ obj[ atn ] ];
                obj[cnn] = myArr(obj[cnn]);

                obj[atn][obj[atn].length] = atv;
                obj[atn].length = obj[atn].length;
              }
              else {
                /*DBG*/ //if(window.console) console.log(['x2j',nn,'attr>',atn,'TEXT']);
                obj[atn] = atv;
              };
            });
            //obj['attributes'] = att;
          };//node.attributes.length>0
        };//node.attributes
        if (obj) {
          obj = $.extend((txt != '' ? new String(txt) : {}),/* {text:txt},*/ obj || {}/*, att || {}*/);
          //txt = (obj.text) ? (typeof(obj.text)=='object' ? obj.text : [obj.text || '']).concat([txt]) : txt;
          txt = (obj.text) ? ([obj.text || '']).concat([txt]) : txt;
          if (txt) obj.text = txt;
          txt = '';
        };
        var out = obj || txt;
        //console.log([extended, simple, out]);
        if (extended) {
          if (txt) out = {};//new String(out);
          txt = out.text || txt || '';
          if (txt) out.text = txt;
          if (!simple) out = myArr(out);
        };
        return out;
      };// parseXML
      // Core Function End
      // Utility functions
      var jsVar = function (s) { return String(s || '').replace(/-/g, "_"); };

      // NEW isNum function: 01/09/2010
      // Thanks to Emile Grau, GigaTecnologies S.L., www.gigatransfer.com, www.mygigamail.com
      function isNum(s) {
        // based on utility function isNum from xml2json plugin (http://www.fyneworks.com/ - diego@fyneworks.com)
        // few bugs corrected from original function :
        // - syntax error : regexp.test(string) instead of string.test(reg)
        // - regexp modified to accept  comma as decimal mark (latin syntax : 25,24 )
        // - regexp modified to reject if no number before decimal mark  : ".7" is not accepted
        // - string is "trimmed", allowing to accept space at the beginning and end of string
        var regexp = /^((-)?([0-9]+)(([\.\,]{0,1})([0-9]+))?$)/
        return (typeof s == "number") || regexp.test(String((s && typeof s == "string") ? jQuery.trim(s) : ''));
      };
      // OLD isNum function: (for reference only)
      //var isNum = function(s){ return (typeof s == "number") || String((s && typeof s == "string") ? s : '').test(/^((-)?([0-9]*)((\.{0,1})([0-9]+))?$)/); };

      var myArr = function (o) {
        // http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
        //if(!o.length) o = [ o ]; o.length=o.length;
        if (!$.isArray(o)) o = [o]; o.length = o.length;

        // here is where you can attach additional functionality, such as searching and sorting...
        return o;
      };
      // Utility functions End
      //### PARSER LIBRARY END

      // Convert plain text to xml
      if (typeof xml == 'string') xml = $.text2xml(xml);

      // Quick fail if not xml (or if this is a node)
      if (!xml.nodeType) return;
      if (xml.nodeType == 3 || xml.nodeType == 4) return xml.nodeValue;

      // Find xml root node
      var root = (xml.nodeType == 9) ? xml.documentElement : xml;

      // Convert xml to json
      var out = parseXML(root, true /* simple */);

      // Clean-up memory
      xml = null; root = null;

      // Send output
      return out;
    },

    // Convert text to XML DOM
    text2xml: function (str) {
      // NOTE: I'd like to use jQuery for this, but jQuery makes all tags uppercase
      //return $(xml)[0];

      /* prior to jquery 1.9 */
      /*
      var out;
      try{
       var xml = ((!$.support.opacity && !$.support.style))?new ActiveXObject("Microsoft.XMLDOM"):new DOMParser();
       xml.async = false;
      }catch(e){ throw new Error("XML Parser could not be instantiated") };
      try{
       if((!$.support.opacity && !$.support.style)) out = (xml.loadXML(str))?xml:false;
       else out = xml.parseFromString(str, "text/xml");
      }catch(e){ throw new Error("Error parsing XML string") };
      return out;
      */

      /* jquery 1.9+ */
      return $.parseXML(str);
    }
  }); // extend $
})(jQuery);
(function(n,t){function v(n,t,r){var e=n.children(),o=!1,u,s,f;for(n.empty(),u=0,s=e.length;u<s;u++)if(f=e.eq(u),n.append(f),r&&n.append(r),i(n,t)){f.remove();o=!0;break}else r&&r.detach();return o}function o(t,r,u,f,e){var s=!1,h="table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, blockquote, select, optgroup, option, textarea, script, style",c="script";return t.contents().detach().each(function(){var a=this,l=n(a);if(typeof a=="undefined"||a.nodeType==3&&n.trim(a.data).length==0)return!0;if(l.is(c))t.append(l);else{if(s)return!0;t.append(l);e&&t[t.is(h)?"after":"append"](e);i(u,f)&&(s=a.nodeType==3?y(l,r,u,f,e):o(l,r,u,f,e),s||(l.detach(),s=!0));s||e&&e.detach()}}),s}function y(t,u,e,o,c){var l=t[0],nt,k,d;if(!l)return!1;var y=h(l),tt=y.indexOf(" ")!==-1?" ":"",p=o.wrap=="letter"?"":tt,a=y.split(p),g=-1,w=-1,b=0,v=a.length-1;for(o.fallbackToLetter&&b==0&&v==0&&(p="",a=y.split(p),v=a.length-1);b<=v&&!(b==0&&v==0);){if(nt=Math.floor((b+v)/2),nt==w)break;w=nt;f(l,a.slice(0,w+1).join(p)+o.ellipsis);i(e,o)?(v=w,o.fallbackToLetter&&b==0&&v==0&&(p="",a=a[0].split(p),g=-1,w=-1,b=0,v=a.length-1)):(g=w,b=w)}return g==-1||a.length==1&&a[0].length==0?(k=t.parent(),t.detach(),d=c&&c.closest(k).length?c.length:0,k.contents().length>d?l=r(k.contents().eq(-1-d),u):(l=r(k,u,!0),d||k.detach()),l&&(y=s(h(l),o),f(l,y),d&&c&&n(l).parent().append(c))):(y=s(a.slice(0,g+1).join(p),o),f(l,y)),!0}function i(n,t){return n.innerHeight()>t.maxHeight}function s(t,i){while(n.inArray(t.slice(-1),i.lastCharacter.remove)>-1)t=t.slice(0,-1);return n.inArray(t.slice(-1),i.lastCharacter.noEllipsis)<0&&(t+=i.ellipsis),t}function u(n){return{width:n.innerWidth(),height:n.innerHeight()}}function f(n,t){n.innerText?n.innerText=t:n.nodeValue?n.nodeValue=t:n.textContent&&(n.textContent=t)}function h(n){return n.innerText?n.innerText:n.nodeValue?n.nodeValue:n.textContent?n.textContent:""}function c(n){do n=n.previousSibling;while(n&&n.nodeType!==1&&n.nodeType!==3);return n}function r(t,i,u){var e=t&&t[0],f;if(e){if(!u){if(e.nodeType===3)return e;if(n.trim(t.text()))return r(t.contents().last(),i)}for(f=c(e);!f;){if(t=t.parent(),t.is(i)||!t.length)return!1;f=c(t[0])}if(f)return r(n(f),i)}return!1}function p(t,i){return t?typeof t=="string"?(t=n(t,i),t.length?t:!1):t.jquery?t:!1:!1}function w(n){for(var t,r=n.innerHeight(),u=["paddingTop","paddingBottom"],i=0,f=u.length;i<f;i++)t=parseInt(n.css(u[i]),10),isNaN(t)&&(t=0),r-=t;return r}var e,l,a;n.fn.dotdotdot||(n.fn.dotdotdot=function(t){var r;if(this.length==0)return n.fn.dotdotdot.debug('No element found for "'+this.selector+'".'),this;if(this.length>1)return this.each(function(){n(this).dotdotdot(t)});r=this;r.data("dotdotdot")&&r.trigger("destroy.dot");r.data("dotdotdot-style",r.attr("style")||"");r.css("word-wrap","break-word");r.css("white-space")==="nowrap"&&r.css("white-space","normal");r.bind_events=function(){return r.bind("update.dot",function(t,u){t.preventDefault();t.stopPropagation();f.maxHeight=typeof f.height=="number"?f.height:w(r);f.maxHeight+=f.tolerance;typeof u!="undefined"&&((typeof u=="string"||u instanceof HTMLElement)&&(u=n("<div />").append(u).contents()),u instanceof n&&(c=u));h=r.wrapInner('<div class="dotdotdot" />').children();h.contents().detach().end().append(c.clone(!0)).find("br").replaceWith("  <br />  ").end().css({height:"auto",width:"auto",border:"none",padding:0,margin:0});var e=!1,l=!1;return s.afterElement&&(e=s.afterElement.clone(!0),e.show(),s.afterElement.detach()),i(h,f)&&(l=f.wrap=="children"?v(h,f,e):o(h,r,h,f,e)),h.replaceWith(h.contents()),h=null,n.isFunction(f.callback)&&f.callback.call(r[0],l,c),s.isTruncated=l,l}).bind("isTruncated.dot",function(n,t){return n.preventDefault(),n.stopPropagation(),typeof t=="function"&&t.call(r[0],s.isTruncated),s.isTruncated}).bind("originalContent.dot",function(n,t){return n.preventDefault(),n.stopPropagation(),typeof t=="function"&&t.call(r[0],c),c}).bind("destroy.dot",function(n){n.preventDefault();n.stopPropagation();r.unwatch().unbind_events().contents().detach().end().append(c).attr("style",r.data("dotdotdot-style")||"").data("dotdotdot",!1)}),r};r.unbind_events=function(){return r.unbind(".dot"),r};r.watch=function(){if(r.unwatch(),f.watch=="window"){var t=n(window),i=t.width(),e=t.height();t.bind("resize.dot"+s.dotId,function(){i==t.width()&&e==t.height()&&f.windowResizeFix||(i=t.width(),e=t.height(),l&&clearInterval(l),l=setTimeout(function(){r.trigger("update.dot")},10))})}else a=u(r),l=setInterval(function(){var n=u(r);(a.width!=n.width||a.height!=n.height)&&(r.trigger("update.dot"),a=u(r))},0);return r};r.unwatch=function(){return n(window).unbind("resize.dot"+s.dotId),l&&clearInterval(l),r};var c=r.contents(),f=n.extend(!0,{},n.fn.dotdotdot.defaults,t),s={},a={},l=null,h=null;return f.lastCharacter.remove instanceof Array||(f.lastCharacter.remove=n.fn.dotdotdot.defaultArrays.lastCharacter.remove),f.lastCharacter.noEllipsis instanceof Array||(f.lastCharacter.noEllipsis=n.fn.dotdotdot.defaultArrays.lastCharacter.noEllipsis),s.afterElement=p(f.after,r),s.isTruncated=!1,s.dotId=e++,r.data("dotdotdot",!0).bind_events().trigger("update.dot"),f.watch&&r.watch(),r},n.fn.dotdotdot.defaults={ellipsis:"... ",wrap:"word",fallbackToLetter:!0,lastCharacter:{},tolerance:0,callback:null,after:null,height:null,watch:!1,windowResizeFix:!0},n.fn.dotdotdot.defaultArrays={lastCharacter:{remove:[" ","",",",";",".","!","?"],noEllipsis:[]}},n.fn.dotdotdot.debug=function(){},e=1,l=n.fn.html,n.fn.html=function(i){return i!=t&&!n.isFunction(i)&&this.data("dotdotdot")?this.trigger("update",[i]):l.apply(this,arguments)},a=n.fn.text,n.fn.text=function(i){return i!=t&&!n.isFunction(i)&&this.data("dotdotdot")?(i=n("<div />").text(i).html(),this.trigger("update",[i])):a.apply(this,arguments)})})(jQuery);
//# sourceMappingURL=jquery.dotdotdot.min.js.map

/*
 * jsTree 1.0-rc3
 * http://jstree.com/
 *
 * Copyright (c) 2010 Ivan Bozhanov (vakata.com)
 *
 * Licensed same as jquery - under the terms of either the MIT License or the GPL Version 2 License
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * $Date: 2011-02-09 01:17:14 +0200 (, 09  2011) $
 * $Revision: 236 $
 */

/*jslint browser: true, onevar: true, undef: true, bitwise: true, strict: true */
/*global window : false, clearInterval: false, clearTimeout: false, document: false, setInterval: false, setTimeout: false, jQuery: false, navigator: false, XSLTProcessor: false, DOMParser: false, XMLSerializer: false*/

"use strict";

// top wrapper to prevent multiple inclusion (is this OK?)
(function () { if(jQuery && jQuery.jstree) { return; }
	var is_ie6 = false, is_ie7 = false, is_ff2 = false;

/* 
 * jsTree core
 */
(function ($) {
	// Common functions not related to jsTree 
	// decided to move them to a `vakata` "namespace"
	$.vakata = {};
	// CSS related functions
	$.vakata.css = {
		get_css : function(rule_name, delete_flag, sheet) {
			rule_name = rule_name.toLowerCase();
			var css_rules = sheet.cssRules || sheet.rules,
				j = 0;
			do {
				if(css_rules.length && j > css_rules.length + 5) { return false; }
				if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {
					if(delete_flag === true) {
						if(sheet.removeRule) { sheet.removeRule(j); }
						if(sheet.deleteRule) { sheet.deleteRule(j); }
						return true;
					}
					else { return css_rules[j]; }
				}
			}
			while (css_rules[++j]);
			return false;
		},
		add_css : function(rule_name, sheet) {
			if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
			if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
			return $.vakata.css.get_css(rule_name);
		},
		remove_css : function(rule_name, sheet) { 
			return $.vakata.css.get_css(rule_name, true, sheet); 
		},
		add_sheet : function(opts) {
			var tmp = false, is_new = true;
			if(opts.str) {
				if(opts.title) { tmp = $("style[id='" + opts.title + "-stylesheet']")[0]; }
				if(tmp) { is_new = false; }
				else {
					tmp = document.createElement("style");
					tmp.setAttribute('type',"text/css");
					if(opts.title) { tmp.setAttribute("id", opts.title + "-stylesheet"); }
				}
				if(tmp.styleSheet) {
					if(is_new) { 
						document.getElementsByTagName("head")[0].appendChild(tmp); 
						tmp.styleSheet.cssText = opts.str; 
					}
					else {
						tmp.styleSheet.cssText = tmp.styleSheet.cssText + " " + opts.str; 
					}
				}
				else {
					tmp.appendChild(document.createTextNode(opts.str));
					document.getElementsByTagName("head")[0].appendChild(tmp);
				}
				return tmp.sheet || tmp.styleSheet;
			}
			if(opts.url) {
				if(document.createStyleSheet) {
					try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
				}
				else {
					tmp			= document.createElement('link');
					tmp.rel		= 'stylesheet';
					tmp.type	= 'text/css';
					tmp.media	= "all";
					tmp.href	= opts.url;
					document.getElementsByTagName("head")[0].appendChild(tmp);
					return tmp.styleSheet;
				}
			}
		}
	};

	// private variables 
	var instances = [],			// instance array (used by $.jstree.reference/create/focused)
		focused_instance = -1,	// the index in the instance array of the currently focused instance
		plugins = {},			// list of included plugins
		prepared_move = {};		// for the move_node function

	// jQuery plugin wrapper (thanks to jquery UI widget function)
	$.fn.jstree = function (settings) {
		var isMethodCall = (typeof settings == 'string'), // is this a method call like $().jstree("open_node")
			args = Array.prototype.slice.call(arguments, 1), 
			returnValue = this;

		// if a method call execute the method on all selected instances
		if(isMethodCall) {
			if(settings.substring(0, 1) == '_') { return returnValue; }
			this.each(function() {
				var instance = instances[$.data(this, "jstree_instance_id")],
					methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;
					if(typeof methodValue !== "undefined" && (settings.indexOf("is_") === 0 || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }
			});
		}
		else {
			this.each(function() {
				// extend settings and allow for multiple hashes and $.data
				var instance_id = $.data(this, "jstree_instance_id"),
					a = [],
					b = settings ? $.extend({}, true, settings) : {},
					c = $(this), 
					s = false, 
					t = [];
				a = a.concat(args);
				if(c.data("jstree")) { a.push(c.data("jstree")); }
				b = a.length ? $.extend.apply(null, [true, b].concat(a)) : b;

				// if an instance already exists, destroy it first
				if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }
				// push a new empty object to the instances array
				instance_id = parseInt(instances.push({}),10) - 1;
				// store the jstree instance id to the container element
				$.data(this, "jstree_instance_id", instance_id);
				// clean up all plugins
				b.plugins = $.isArray(b.plugins) ? b.plugins : $.jstree.defaults.plugins.slice();
				b.plugins.unshift("core");
				// only unique plugins
				b.plugins = b.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");

				// extend defaults with passed data
				s = $.extend(true, {}, $.jstree.defaults, b);
				s.plugins = b.plugins;
				$.each(plugins, function (i, val) { 
					if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } 
					else { t.push(i); }
				});
				s.plugins = t;

				// push the new object to the instances array (at the same time set the default classes to the container) and init
				instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); 
				// init all activated plugins for this instance
				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });
				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });
				// initialize the instance
				setTimeout(function() { if(instances[instance_id]) { instances[instance_id].init(); } }, 0);
			});
		}
		// return the jquery selection (or if it was a method call that returned a value - the returned value)
		return returnValue;
	};
	// object to store exposed functions and objects
	$.jstree = {
		defaults : {
			plugins : []
		},
		_focused : function () { return instances[focused_instance] || null; },
		_reference : function (needle) { 
			// get by instance id
			if(instances[needle]) { return instances[needle]; }
			// get by DOM (if still no luck - return null
			var o = $(needle); 
			if(!o.length && typeof needle === "string") { o = $("#" + needle); }
			if(!o.length) { return null; }
			return instances[o.closest(".jstree").data("jstree_instance_id")] || null; 
		},
		_instance : function (index, container, settings) { 
			// for plugins to store data in
			this.data = { core : {} };
			this.get_settings	= function () { return $.extend(true, {}, settings); };
			this._get_settings	= function () { return settings; };
			this.get_index		= function () { return index; };
			this.get_container	= function () { return container; };
			this.get_container_ul = function () { return container.children("ul:eq(0)"); };
			this._set_settings	= function (s) { 
				settings = $.extend(true, {}, settings, s);
			};
		},
		_fn : { },
		plugin : function (pname, pdata) {
			pdata = $.extend({}, {
				__init		: $.noop, 
				__destroy	: $.noop,
				_fn			: {},
				defaults	: false
			}, pdata);
			plugins[pname] = pdata;

			$.jstree.defaults[pname] = pdata.defaults;
			$.each(pdata._fn, function (i, val) {
				val.plugin		= pname;
				val.old			= $.jstree._fn[i];
				$.jstree._fn[i] = function () {
					var rslt,
						func = val,
						args = Array.prototype.slice.call(arguments),
						evnt = new $.Event("before.jstree"),
						rlbk = false;

					if(this.data.core.locked === true && i !== "unlock" && i !== "is_locked") { return; }

					// Check if function belongs to the included plugins of this instance
					do {
						if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }
						func = func.old;
					} while(func);
					if(!func) { return; }

					// context and function to trigger events, then finally call the function
					if(i.indexOf("_") === 0) {
						rslt = func.apply(this, args);
					}
					else {
						rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args, "plugin" : func.plugin });
						if(rslt === false) { return; }
						if(typeof rslt !== "undefined") { args = rslt; }

						rslt = func.apply(
							$.extend({}, this, { 
								__callback : function (data) { 
									this.get_container().triggerHandler( i + '.jstree', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });
								},
								__rollback : function () { 
									rlbk = this.get_rollback();
									return rlbk;
								},
								__call_old : function (replace_arguments) {
									return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
								}
							}), args);
					}

					// return the result
					return rslt;
				};
				$.jstree._fn[i].old = val.old;
				$.jstree._fn[i].plugin = pname;
			});
		},
		rollback : function (rb) {
			if(rb) {
				if(!$.isArray(rb)) { rb = [ rb ]; }
				$.each(rb, function (i, val) {
					instances[val.i].set_rollback(val.h, val.d);
				});
			}
		}
	};
	// set the prototype for all instances
	$.jstree._fn = $.jstree._instance.prototype = {};

	// load the css when DOM is ready
	$(function() {
		// code is copied from jQuery ($.browser is deprecated + there is a bug in IE)
		var u = navigator.userAgent.toLowerCase(),
			v = (u.match( /.+?(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
			css_string = '' + 
				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
				'.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; } ' + 
				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
				'.jstree > ul > li { margin-left:0px; } ' + 
				'.jstree-rtl > ul > li { margin-right:0px; } ' + 
				'.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
				'.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
				'.jstree a:focus { outline: none; } ' + 
				'.jstree a > ins { height:16px; width:16px; } ' + 
				'.jstree a > .jstree-icon { margin-right:3px; } ' + 
				'.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } ' + 
				'li.jstree-open > ul { display:block; } ' + 
				'li.jstree-closed > ul { display:none; } ';
		// Correct IE 6 (does not support the > CSS selector)
		if(/msie/.test(u) && parseInt(v, 10) == 6) { 
			is_ie6 = true;

			// fix image flicker and lack of caching
			try {
				document.execCommand("BackgroundImageCache", false, true);
			} catch (err) { }

			css_string += '' + 
				'.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
				'.jstree li li { margin-left:18px; } ' + 
				'.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
				'li.jstree-open ul { display:block; } ' + 
				'li.jstree-closed ul { display:none !important; } ' + 
				'.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } ' + 
				'.jstree li a ins { height:16px; width:16px; margin-right:3px; } ' + 
				'.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } ';
		}
		// Correct IE 7 (shifts anchor nodes onhover)
		if(/msie/.test(u) && parseInt(v, 10) == 7) { 
			is_ie7 = true;
			css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
		}
		// correct ff2 lack of display:inline-block
		if(!/compatible/.test(u) && /mozilla/.test(u) && parseFloat(v, 10) < 1.9) {
			is_ff2 = true;
			css_string += '' + 
				'.jstree ins { display:-moz-inline-box; } ' + 
				'.jstree li { line-height:12px; } ' + // WHY??
				'.jstree a { display:-moz-inline-box; } ' + 
				'.jstree .jstree-no-icons .jstree-checkbox { display:-moz-inline-stack !important; } ';
				/* this shouldn't be here as it is theme specific */
		}
		// the default stylesheet
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});

	// core functions (open, close, create, update, delete)
	$.jstree.plugin("core", {
		__init : function () {
			this.data.core.locked = false;
			this.data.core.to_open = this.get_settings().core.initially_open;
			this.data.core.to_load = this.get_settings().core.initially_load;
		},
		defaults : { 
			html_titles	: false,
			animation	: 200,
			initially_open : [],
			initially_load : [],
			open_parents : true,
			notify_plugins : true,
			rtl			: false,
			load_open	: false,
			strings		: {
				loading		: "Loading ...",
				new_node	: "New node",
				multiple_selection : "Multiple selection"
			}
		},
		_fn : { 
			init	: function () { 
				this.set_focus(); 
				if(this._get_settings().core.rtl) {
					this.get_container().addClass("jstree-rtl").css("direction", "rtl");
				}
				this.get_container().html("<ul><li class='jstree-last jstree-leaf'><ins>&#160;</ins><a class='jstree-loading' href='#'><ins class='jstree-icon'>&#160;</ins>" + this._get_string("loading") + "</a></li></ul>");
				this.data.core.li_height = this.get_container_ul().find("li.jstree-closed, li.jstree-leaf").eq(0).height() || 18;

				this.get_container()
					.delegate("li > ins", "click.jstree", $.proxy(function (event) {
							var trgt = $(event.target);
							// if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
							this.toggle_node(trgt);
						}, this))
					.bind("mousedown.jstree", $.proxy(function () { 
							this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
						}, this))
					.bind("dblclick.jstree", function (event) { 
						var sel;
						if(document.selection && document.selection.empty) { document.selection.empty(); }
						else {
							if(window.getSelection) {
								sel = window.getSelection();
								try { 
									sel.removeAllRanges();
									sel.collapse();
								} catch (err) { }
							}
						}
					});
				if(this._get_settings().core.notify_plugins) {
					this.get_container()
						.bind("load_node.jstree", $.proxy(function (e, data) { 
								var o = this._get_node(data.rslt.obj),
									t = this;
								if(o === -1) { o = this.get_container_ul(); }
								if(!o.length) { return; }
								o.find("li").each(function () {
									var th = $(this);
									if(th.data("jstree")) {
										$.each(th.data("jstree"), function (plugin, values) {
											if(t.data[plugin] && $.isFunction(t["_" + plugin + "_notify"])) {
												t["_" + plugin + "_notify"].call(t, th, values);
											}
										});
									}
								});
							}, this));
				}
				if(this._get_settings().core.load_open) {
					this.get_container()
						.bind("load_node.jstree", $.proxy(function (e, data) { 
								var o = this._get_node(data.rslt.obj),
									t = this;
								if(o === -1) { o = this.get_container_ul(); }
								if(!o.length) { return; }
								o.find("li.jstree-open:not(:has(ul))").each(function () {
									t.load_node(this, $.noop, $.noop);
								});
							}, this));
				}
				this.__callback();
				this.load_node(-1, function () { this.loaded(); this.reload_nodes(); });
			},
			destroy	: function () { 
				var i,
					n = this.get_index(),
					s = this._get_settings(),
					_this = this;

				$.each(s.plugins, function (i, val) {
					try { plugins[val].__destroy.apply(_this); } catch(err) { }
				});
				this.__callback();
				// set focus to another instance if this one is focused
				if(this.is_focused()) { 
					for(i in instances) { 
						if(instances.hasOwnProperty(i) && i != n) { 
							instances[i].set_focus(); 
							break; 
						} 
					}
				}
				// if no other instance found
				if(n === focused_instance) { focused_instance = -1; }
				// remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events
				this.get_container()
					.unbind(".jstree")
					.undelegate(".jstree")
					.removeData("jstree_instance_id")
					.find("[class^='jstree']")
						.andSelf()
						.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
				$(document)
					.unbind(".jstree-" + n)
					.undelegate(".jstree-" + n);
				// remove the actual data
				instances[n] = null;
				delete instances[n];
			},

			_core_notify : function (n, data) {
				if(data.opened) {
					this.open_node(n, false, true);
				}
			},

			lock : function () {
				this.data.core.locked = true;
				this.get_container().children("ul").addClass("jstree-locked").css("opacity","0.7");
				this.__callback({});
			},
			unlock : function () {
				this.data.core.locked = false;
				this.get_container().children("ul").removeClass("jstree-locked").css("opacity","1");
				this.__callback({});
			},
			is_locked : function () { return this.data.core.locked; },
			save_opened : function () {
				var _this = this;
				this.data.core.to_open = [];
				this.get_container_ul().find("li.jstree-open").each(function () { 
					if(this.id) { _this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); }
				});
				this.__callback(_this.data.core.to_open);
			},
			save_loaded : function () { },
			reload_nodes : function (is_callback) {
				var _this = this,
					done = true,
					current = [],
					remaining = [];
				if(!is_callback) { 
					this.data.core.reopen = false; 
					this.data.core.refreshing = true; 
					this.data.core.to_open = $.map($.makeArray(this.data.core.to_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					this.data.core.to_load = $.map($.makeArray(this.data.core.to_load), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					if(this.data.core.to_open.length) {
						this.data.core.to_load = this.data.core.to_load.concat(this.data.core.to_open);
					}
				}
				if(this.data.core.to_load.length) {
					$.each(this.data.core.to_load, function (i, val) {
						if(val == "#") { return true; }
						if($(val).length) { current.push(val); }
						else { remaining.push(val); }
					});
					if(current.length) {
						this.data.core.to_load = remaining;
						$.each(current, function (i, val) { 
							if(!_this._is_loaded(val)) {
								_this.load_node(val, function () { _this.reload_nodes(true); }, function () { _this.reload_nodes(true); });
								done = false;
							}
						});
					}
				}
				if(this.data.core.to_open.length) {
					$.each(this.data.core.to_open, function (i, val) {
						_this.open_node(val, false, true); 
					});
				}
				if(done) { 
					// TODO: find a more elegant approach to syncronizing returning requests
					if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }
					this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);
					this.data.core.refreshing = false;
					this.reopen();
				}
			},
			reopen : function () {
				var _this = this;
				if(this.data.core.to_open.length) {
					$.each(this.data.core.to_open, function (i, val) {
						_this.open_node(val, false, true); 
					});
				}
				this.__callback({});
			},
			refresh : function (obj) {
				var _this = this;
				this.save_opened();
				if(!obj) { obj = -1; }
				obj = this._get_node(obj);
				if(!obj) { obj = -1; }
				if(obj !== -1) { obj.children("UL").remove(); }
				else { this.get_container_ul().empty(); }
				this.load_node(obj, function () { _this.__callback({ "obj" : obj}); _this.reload_nodes(); });
			},
			// Dummy function to fire after the first load (so that there is a jstree.loaded event)
			loaded	: function () { 
				this.__callback(); 
			},
			// deal with focus
			set_focus	: function () { 
				if(this.is_focused()) { return; }
				var f = $.jstree._focused();
				if(f) { f.unset_focus(); }

				this.get_container().addClass("jstree-focused"); 
				focused_instance = this.get_index(); 
				this.__callback();
			},
			is_focused	: function () { 
				return focused_instance == this.get_index(); 
			},
			unset_focus	: function () {
				if(this.is_focused()) {
					this.get_container().removeClass("jstree-focused"); 
					focused_instance = -1; 
				}
				this.__callback();
			},

			// traverse
			_get_node		: function (obj) { 
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj == -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			_get_next		: function (obj, strict) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }
				if(!obj.length) { return false; }
				if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }

				if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
				else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
				else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
			},
			_get_prev		: function (obj, strict) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
				if(!obj.length) { return false; }
				if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }

				if(obj.prev("li").length) {
					obj = obj.prev("li").eq(0);
					while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
					return obj;
				}
				else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
			},
			_get_parent		: function (obj) {
				obj = this._get_node(obj);
				if(obj == -1 || !obj.length) { return false; }
				var o = obj.parentsUntil(".jstree", "li:eq(0)");
				return o.length ? o : -1;
			},
			_get_children	: function (obj) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }
				if(!obj.length) { return false; }
				return obj.children("ul:eq(0)").children("li");
			},
			get_path		: function (obj, id_mode) {
				var p = [],
					_this = this;
				obj = this._get_node(obj);
				if(obj === -1 || !obj || !obj.length) { return false; }
				obj.parentsUntil(".jstree", "li").each(function () {
					p.push( id_mode ? this.id : _this.get_text(this) );
				});
				p.reverse();
				p.push( id_mode ? obj.attr("id") : this.get_text(obj) );
				return p;
			},

			// string functions
			_get_string : function (key) {
				return this._get_settings().core.strings[key] || key;
			},

			is_open		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
			is_closed	: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
			is_leaf		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
			correct_state	: function (obj) {
				obj = this._get_node(obj);
				if(!obj || obj === -1) { return false; }
				obj.removeClass("jstree-closed jstree-open").addClass("jstree-leaf").children("ul").remove();
				this.__callback({ "obj" : obj });
			},
			// open/close
			open_node	: function (obj, callback, skip_animation) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }
				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
					t = this;
				if(!this._is_loaded(obj)) {
					obj.children("a").addClass("jstree-loading");
					this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);
				}
				else {
					if(this._get_settings().core.open_parents) {
						obj.parentsUntil(".jstree",".jstree-closed").each(function () {
							t.open_node(this, false, true);
						});
					}
					if(s) { obj.children("ul").css("display","none"); }
					obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");
					if(s) { obj.children("ul").stop(true, true).slideDown(s, function () { this.style.display = ""; t.after_open(obj); }); }
					else { t.after_open(obj); }
					this.__callback({ "obj" : obj });
					if(callback) { callback.call(); }
				}
			},
			after_open	: function (obj) { this.__callback({ "obj" : obj }); },
			close_node	: function (obj, skip_animation) {
				obj = this._get_node(obj);
				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
					t = this;
				if(!obj.length || !obj.hasClass("jstree-open")) { return false; }
				if(s) { obj.children("ul").attr("style","display:block !important"); }
				obj.removeClass("jstree-open").addClass("jstree-closed");
				if(s) { obj.children("ul").stop(true, true).slideUp(s, function () { this.style.display = ""; t.after_close(obj); }); }
				else { t.after_close(obj); }
				this.__callback({ "obj" : obj });
			},
			after_close	: function (obj) { this.__callback({ "obj" : obj }); },
			toggle_node	: function (obj) {
				obj = this._get_node(obj);
				if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }
				if(obj.hasClass("jstree-open")) { return this.close_node(obj); }
			},
			open_all	: function (obj, do_animation, original_obj) {
				obj = obj ? this._get_node(obj) : -1;
				if(!obj || obj === -1) { obj = this.get_container_ul(); }
				if(original_obj) { 
					obj = obj.find("li.jstree-closed");
				}
				else {
					original_obj = obj;
					if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").andSelf(); }
					else { obj = obj.find("li.jstree-closed"); }
				}
				var _this = this;
				obj.each(function () { 
					var __this = this; 
					if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, do_animation, original_obj); }, !do_animation); }
					else { _this.open_node(this, false, !do_animation); }
				});
				// so that callback is fired AFTER all nodes are open
				if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
			},
			close_all	: function (obj, do_animation) {
				var _this = this;
				obj = obj ? this._get_node(obj) : this.get_container();
				if(!obj || obj === -1) { obj = this.get_container_ul(); }
				obj.find("li.jstree-open").andSelf().each(function () { _this.close_node(this, !do_animation); });
				this.__callback({ "obj" : obj });
			},
			clean_node	: function (obj) {
				obj = obj && obj != -1 ? $(obj) : this.get_container_ul();
				obj = obj.is("li") ? obj.find("li").andSelf() : obj.find("li");
				obj.removeClass("jstree-last")
					.filter("li:last-child").addClass("jstree-last").end()
					.filter(":has(li)")
						.not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");
				obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();
				this.__callback({ "obj" : obj });
			},
			// rollback
			get_rollback : function () { 
				this.__callback();
				return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; 
			},
			set_rollback : function (html, data) {
				this.get_container().empty().append(html);
				this.data = data;
				this.__callback();
			},
			// Dummy functions to be overwritten by any datastore plugin included
			load_node	: function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },
			_is_loaded	: function (obj) { return true; },

			// Basic operations: create
			create_node	: function (obj, position, js, callback, is_loaded) {
				obj = this._get_node(obj);
				position = typeof position === "undefined" ? "last" : position;
				var d = $("<li />"),
					s = this._get_settings().core,
					tmp;

				if(obj !== -1 && !obj.length) { return false; }
				if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }

				this.__rollback();

				if(typeof js === "string") { js = { "data" : js }; }
				if(!js) { js = {}; }
				if(js.attr) { d.attr(js.attr); }
				if(js.metadata) { d.data(js.metadata); }
				if(js.state) { d.addClass("jstree-" + js.state); }
				if(!js.data) { js.data = this._get_string("new_node"); }
				if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
				$.each(js.data, function (i, m) {
					tmp = $("<a />");
					if($.isFunction(m)) { m = m.call(this, js); }
					if(typeof m == "string") { tmp.attr('href','#')[ s.html_titles ? "html" : "text" ](m); }
					else {
						if(!m.attr) { m.attr = {}; }
						if(!m.attr.href) { m.attr.href = '#'; }
						tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);
						if(m.language) { tmp.addClass(m.language); }
					}
					tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
					if(!m.icon && js.icon) { m.icon = js.icon; }
					if(m.icon) { 
						if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
						else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
					}
					d.append(tmp);
				});
				d.prepend("<ins class='jstree-icon'>&#160;</ins>");
				if(obj === -1) {
					obj = this.get_container();
					if(position === "before") { position = "first"; }
					if(position === "after") { position = "last"; }
				}
				switch(position) {
					case "before": obj.before(d); tmp = this._get_parent(obj); break;
					case "after" : obj.after(d);  tmp = this._get_parent(obj); break;
					case "inside":
					case "first" :
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						obj.children("ul").prepend(d);
						tmp = obj;
						break;
					case "last":
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						obj.children("ul").append(d);
						tmp = obj;
						break;
					default:
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						if(!position) { position = 0; }
						tmp = obj.children("ul").children("li").eq(position);
						if(tmp.length) { tmp.before(d); }
						else { obj.children("ul").append(d); }
						tmp = obj;
						break;
				}
				if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }
				this.clean_node(tmp);
				this.__callback({ "obj" : d, "parent" : tmp });
				if(callback) { callback.call(this, d); }
				return d;
			},
			// Basic operations: rename (deal with text)
			get_text	: function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				var s = this._get_settings().core.html_titles;
				obj = obj.children("a:eq(0)");
				if(s) {
					obj = obj.clone();
					obj.children("INS").remove();
					return obj.html();
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					return obj.nodeValue;
				}
			},
			set_text	: function (obj, val) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				obj = obj.children("a:eq(0)");
				if(this._get_settings().core.html_titles) {
					var tmp = obj.children("INS").clone();
					obj.html(val).prepend(tmp);
					this.__callback({ "obj" : obj, "name" : val });
					return true;
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					this.__callback({ "obj" : obj, "name" : val });
					return (obj.nodeValue = val);
				}
			},
			rename_node : function (obj, val) {
				obj = this._get_node(obj);
				this.__rollback();
				if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }
			},
			// Basic operations: deleting nodes
			delete_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				this.__rollback();
				var p = this._get_parent(obj), prev = $([]), t = this;
				obj.each(function () {
					prev = prev.add(t._get_prev(this));
				});
				obj = obj.detach();
				if(p !== -1 && p.find("> ul > li").length === 0) {
					p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");
				}
				this.clean_node(p);
				this.__callback({ "obj" : obj, "prev" : prev, "parent" : p });
				return obj;
			},
			prepare_move : function (o, r, pos, cb, is_cb) {
				var p = {};

				p.ot = $.jstree._reference(o) || this;
				p.o = p.ot._get_node(o);
				p.r = r === - 1 ? -1 : this._get_node(r);
				p.p = (typeof pos === "undefined" || pos === false) ? "last" : pos; // TODO: move to a setting
				if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {
					this.__callback(prepared_move);
					if(cb) { cb.call(this, prepared_move); }
					return;
				}
				p.ot = $.jstree._reference(p.o) || this;
				p.rt = $.jstree._reference(p.r) || this; // r === -1 ? p.ot : $.jstree._reference(p.r) || this
				if(p.r === -1 || !p.r) {
					p.cr = -1;
					switch(p.p) {
						case "first":
						case "before":
						case "inside":
							p.cp = 0; 
							break;
						case "after":
						case "last":
							p.cp = p.rt.get_container().find(" > ul > li").length; 
							break;
						default:
							p.cp = p.p;
							break;
					}
				}
				else {
					if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
						return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });
					}
					switch(p.p) {
						case "before":
							p.cp = p.r.index();
							p.cr = p.rt._get_parent(p.r);
							break;
						case "after":
							p.cp = p.r.index() + 1;
							p.cr = p.rt._get_parent(p.r);
							break;
						case "inside":
						case "first":
							p.cp = 0;
							p.cr = p.r;
							break;
						case "last":
							p.cp = p.r.find(" > ul > li").length; 
							p.cr = p.r;
							break;
						default: 
							p.cp = p.p;
							p.cr = p.r;
							break;
					}
				}
				p.np = p.cr == -1 ? p.rt.get_container() : p.cr;
				p.op = p.ot._get_parent(p.o);
				p.cop = p.o.index();
				if(p.op === -1) { p.op = p.ot ? p.ot.get_container() : this.get_container(); }
				if(!/^(before|after)$/.test(p.p) && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp++; }
				//if(p.p === "before" && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp--; }
				p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
				prepared_move = p;
				this.__callback(prepared_move);
				if(cb) { cb.call(this, prepared_move); }
			},
			check_move : function () {
				var obj = prepared_move, ret = true, r = obj.r === -1 ? this.get_container() : obj.r;
				if(!obj || !obj.o || obj.or[0] === obj.o[0]) { return false; }
				if(obj.op && obj.np && obj.op[0] === obj.np[0] && obj.cp - 1 === obj.o.index()) { return false; }
				obj.o.each(function () { 
					if(r.parentsUntil(".jstree", "li").andSelf().index(this) !== -1) { ret = false; return false; }
				});
				return ret;
			},
			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
				if(!is_prepared) { 
					return this.prepare_move(obj, ref, position, function (p) {
						this.move_node(p, false, false, is_copy, true, skip_check);
					});
				}
				if(is_copy) { 
					prepared_move.cy = true;
				}
				if(!skip_check && !this.check_move()) { return false; }

				this.__rollback();
				var o = false;
				if(is_copy) {
					o = obj.o.clone(true);
					o.find("*[id]").andSelf().each(function () {
						if(this.id) { this.id = "copy_" + this.id; }
					});
				}
				else { o = obj.o; }

				if(obj.or.length) { obj.or.before(o); }
				else { 
					if(!obj.np.children("ul").length) { $("<ul />").appendTo(obj.np); }
					obj.np.children("ul:eq(0)").append(o); 
				}

				try { 
					obj.ot.clean_node(obj.op);
					obj.rt.clean_node(obj.np);
					if(!obj.op.find("> ul > li").length) {
						obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();
					}
				} catch (e) { }

				if(is_copy) { 
					prepared_move.cy = true;
					prepared_move.oc = o; 
				}
				this.__callback(prepared_move);
				return prepared_move;
			},
			_get_move : function () { return prepared_move; }
		}
	});
})(jQuery);
//*/

/* 
 * jsTree ui plugin
 * This plugins handles selecting/deselecting/hovering/dehovering nodes
 */
(function ($) {
	var scrollbar_width, e1, e2;
	$(function() {
		if (/msie/.test(navigator.userAgent.toLowerCase())) {
			e1 = $('<textarea cols="10" rows="2"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
			e2 = $('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
			scrollbar_width = e1.width() - e2.width();
			e1.add(e2).remove();
		} 
		else {
			e1 = $('<div />').css({ width: 100, height: 100, overflow: 'auto', position: 'absolute', top: -1000, left: 0 })
					.prependTo('body').append('<div />').find('div').css({ width: '100%', height: 200 });
			scrollbar_width = 100 - e1.width();
			e1.parent().remove();
		}
	});
	$.jstree.plugin("ui", {
		__init : function () { 
			this.data.ui.selected = $(); 
			this.data.ui.last_selected = false; 
			this.data.ui.hovered = null;
			this.data.ui.to_select = this.get_settings().ui.initially_select;

			this.get_container()
				.delegate("a", "click.jstree", $.proxy(function (event) {
						event.preventDefault();
						event.currentTarget.blur();
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.select_node(event.currentTarget, true, event);
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (event) {
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.hover_node(event.target);
						}
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (event) {
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.dehover_node(event.target);
						}
					}, this))
				.bind("reopen.jstree", $.proxy(function () { 
						this.reselect();
					}, this))
				.bind("get_rollback.jstree", $.proxy(function () { 
						this.dehover_node();
						this.save_selected();
					}, this))
				.bind("set_rollback.jstree", $.proxy(function () { 
						this.reselect();
					}, this))
				.bind("close_node.jstree", $.proxy(function (event, data) { 
						var s = this._get_settings().ui,
							obj = this._get_node(data.rslt.obj),
							clk = (obj && obj.length) ? obj.children("ul").find("a.jstree-clicked") : $(),
							_this = this;
						if(s.selected_parent_close === false || !clk.length) { return; }
						clk.each(function () { 
							_this.deselect_node(this);
							if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }
						});
					}, this))
				.bind("delete_node.jstree", $.proxy(function (event, data) { 
						var s = this._get_settings().ui.select_prev_on_delete,
							obj = this._get_node(data.rslt.obj),
							clk = (obj && obj.length) ? obj.find("a.jstree-clicked") : [],
							_this = this;
						clk.each(function () { _this.deselect_node(this); });
						if(s && clk.length) { 
							data.rslt.prev.each(function () { 
								if(this.parentNode) { _this.select_node(this); return false; /* if return false is removed all prev nodes will be selected */}
							});
						}
					}, this))
				.bind("move_node.jstree", $.proxy(function (event, data) { 
						if(data.rslt.cy) { 
							data.rslt.oc.find("a.jstree-clicked").removeClass("jstree-clicked");
						}
					}, this));
		},
		defaults : {
			select_limit : -1, // 0, 1, 2 ... or -1 for unlimited
			select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt
			select_range_modifier : "shift",
			selected_parent_close : "select_parent", // false, "deselect", "select_parent"
			selected_parent_open : true,
			select_prev_on_delete : true,
			disable_selecting_children : false,
			initially_select : []
		},
		_fn : { 
			_get_node : function (obj, allow_multiple) {
				if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj == -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			_ui_notify : function (n, data) {
				if(data.selected) {
					this.select_node(n, false);
				}
			},
			save_selected : function () {
				var _this = this;
				this.data.ui.to_select = [];
				this.data.ui.selected.each(function () { if(this.id) { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); } });
				this.__callback(this.data.ui.to_select);
			},
			reselect : function () {
				var _this = this,
					s = this.data.ui.to_select;
				s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
				// this.deselect_all(); WHY deselect, breaks plugin state notifier?
				$.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });
				this.data.ui.selected = this.data.ui.selected.filter(function () { return this.parentNode; });
				this.__callback();
			},
			refresh : function (obj) {
				this.save_selected();
				return this.__call_old();
			},
			hover_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				//if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }
				if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
				this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
				this._fix_scroll(obj);
				this.__callback({ "obj" : obj });
			},
			dehover_node : function () {
				var obj = this.data.ui.hovered, p;
				if(!obj || !obj.length) { return false; }
				p = obj.children("a").removeClass("jstree-hovered").parent();
				if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
				this.__callback({ "obj" : obj });
			},
			select_node : function (obj, check, e) {
				obj = this._get_node(obj);
				if(obj == -1 || !obj || !obj.length) { return false; }
				var s = this._get_settings().ui,
					is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),
					is_range = (s.select_range_modifier !== false && e && e[s.select_range_modifier + "Key"] && this.data.ui.last_selected && this.data.ui.last_selected[0] !== obj[0] && this.data.ui.last_selected.parent()[0] === obj.parent()[0]),
					is_selected = this.is_selected(obj),
					proceed = true,
					t = this;
				if(check) {
					if(s.disable_selecting_children && is_multiple && 
						(
							(obj.parentsUntil(".jstree","li").children("a.jstree-clicked").length) ||
							(obj.children("ul").find("a.jstree-clicked:eq(0)").length)
						)
					) {
						return false;
					}
					proceed = false;
					switch(!0) {
						case (is_range):
							this.data.ui.last_selected.addClass("jstree-last-selected");
							obj = obj[ obj.index() < this.data.ui.last_selected.index() ? "nextUntil" : "prevUntil" ](".jstree-last-selected").andSelf();
							if(s.select_limit == -1 || obj.length < s.select_limit) {
								this.data.ui.last_selected.removeClass("jstree-last-selected");
								this.data.ui.selected.each(function () {
									if(this !== t.data.ui.last_selected[0]) { t.deselect_node(this); }
								});
								is_selected = false;
								proceed = true;
							}
							else {
								proceed = false;
							}
							break;
						case (is_selected && !is_multiple): 
							this.deselect_all();
							is_selected = false;
							proceed = true;
							break;
						case (!is_selected && !is_multiple): 
							if(s.select_limit == -1 || s.select_limit > 0) {
								this.deselect_all();
								proceed = true;
							}
							break;
						case (is_selected && is_multiple): 
							this.deselect_node(obj);
							break;
						case (!is_selected && is_multiple): 
							if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { 
								proceed = true;
							}
							break;
					}
				}
				if(proceed && !is_selected) {
					if(!is_range) { this.data.ui.last_selected = obj; }
					obj.children("a").addClass("jstree-clicked");
					if(s.selected_parent_open) {
						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });
					}
					this.data.ui.selected = this.data.ui.selected.add(obj);
					this._fix_scroll(obj.eq(0));
					this.__callback({ "obj" : obj, "e" : e });
				}
			},
			_fix_scroll : function (obj) {
				var c = this.get_container()[0], t;
				if(c.scrollHeight > c.offsetHeight) {
					obj = this._get_node(obj);
					if(!obj || obj === -1 || !obj.length || !obj.is(":visible")) { return; }
					t = obj.offset().top - this.get_container().offset().top;
					if(t < 0) { 
						c.scrollTop = c.scrollTop + t - 1; 
					}
					if(t + this.data.core.li_height + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0) > c.offsetHeight) { 
						c.scrollTop = c.scrollTop + (t - c.offsetHeight + this.data.core.li_height + 1 + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0)); 
					}
				}
			},
			deselect_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(this.is_selected(obj)) {
					obj.children("a").removeClass("jstree-clicked");
					this.data.ui.selected = this.data.ui.selected.not(obj);
					if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
					this.__callback({ "obj" : obj });
				}
			},
			toggle_select : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(this.is_selected(obj)) { this.deselect_node(obj); }
				else { this.select_node(obj); }
			},
			is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },
			get_selected : function (context) { 
				return context ? $(context).find("a.jstree-clicked").parent() : this.data.ui.selected; 
			},
			deselect_all : function (context) {
				var ret = context ? $(context).find("a.jstree-clicked").parent() : this.get_container().find("a.jstree-clicked").parent();
				ret.children("a.jstree-clicked").removeClass("jstree-clicked");
				this.data.ui.selected = $([]);
				this.data.ui.last_selected = false;
				this.__callback({ "obj" : ret });
			}
		}
	});
	// include the selection plugin by default
	$.jstree.defaults.plugins.push("ui");
})(jQuery);
//*/

/* 
 * jsTree CRRM plugin
 * Handles creating/renaming/removing/moving nodes by user interaction.
 */
(function ($) {
	$.jstree.plugin("crrm", { 
		__init : function () {
			this.get_container()
				.bind("move_node.jstree", $.proxy(function (e, data) {
					if(this._get_settings().crrm.move.open_onmove) {
						var t = this;
						data.rslt.np.parentsUntil(".jstree").andSelf().filter(".jstree-closed").each(function () {
							t.open_node(this, false, true);
						});
					}
				}, this));
		},
		defaults : {
			input_width_limit : 200,
			move : {
				always_copy			: false, // false, true or "multitree"
				open_onmove			: true,
				default_position	: "last",
				check_move			: function (m) { return true; }
			}
		},
		_fn : {
			_show_input : function (obj, callback) {
				obj = this._get_node(obj);
				var rtl = this._get_settings().core.rtl,
					w = this._get_settings().crrm.input_width_limit,
					w1 = obj.children("ins").width(),
					w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
					t = this.get_text(obj),
					h1 = $("<div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
					h2 = obj.css("position","relative").append(
					$("<input />", { 
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"position" : "absolute",
							"left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
							"right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
							"top" : "0px",
							"height" : (this.data.core.li_height - 2) + "px",
							"lineHeight" : (this.data.core.li_height - 2) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : $.proxy(function () {
							var i = obj.children(".jstree-rename-input"),
								v = i.val();
							if(v === "") { v = t; }
							h1.remove();
							i.remove(); // rollback purposes
							this.set_text(obj,t); // rollback purposes
							this.rename_node(obj, v);
							callback.call(this, obj, v, t);
							obj.css("position","");
						}, this),
						"keyup" : function (event) {
							var key = event.keyCode || event.which;
							if(key == 27) { this.value = t; this.blur(); return; }
							else if(key == 13) { this.blur(); return; }
							else {
								h2.width(Math.min(h1.text("pW" + this.value).width(),w));
							}
						},
						"keypress" : function(event) {
							var key = event.keyCode || event.which;
							if(key == 13) { return false; }
						}
					})
				).children(".jstree-rename-input"); 
				this.set_text(obj, "");
				h1.css({
						fontFamily		: h2.css('fontFamily')		|| '',
						fontSize		: h2.css('fontSize')		|| '',
						fontWeight		: h2.css('fontWeight')		|| '',
						fontStyle		: h2.css('fontStyle')		|| '',
						fontStretch		: h2.css('fontStretch')		|| '',
						fontVariant		: h2.css('fontVariant')		|| '',
						letterSpacing	: h2.css('letterSpacing')	|| '',
						wordSpacing		: h2.css('wordSpacing')		|| ''
				});
				h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
			},
			rename : function (obj, oldname, newname) {
				obj = this._get_node(obj);
				this.__rollback();
				var f = this.__callback;
                if (oldname && newname) {
                    this.set_text(obj, newname);
                    f.call(this, { "obj" : obj, "new_name" : newname, "old_name" : oldname });
                } else {
				    this._show_input(obj, function (obj, new_name, old_name) { 
					    f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });
				    });
                }
			},
			create : function (obj, position, js, callback, skip_rename) {
				var t, _this = this;
				obj = this._get_node(obj);
				if(!obj) { obj = -1; }
				this.__rollback();
				t = this.create_node(obj, position, js, function (t) {
					var p = this._get_parent(t),
						pos = $(t).index();
					if(callback) { callback.call(this, t); }
					if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }
					if(!skip_rename) { 
						this._show_input(t, function (obj, new_name, old_name) { 
							_this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });
						});
					}
					else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }
				});
				return t;
			},
			remove : function (obj) {
				obj = this._get_node(obj, true);
				var p = this._get_parent(obj), prev = this._get_prev(obj);
				this.__rollback();
				obj = this.delete_node(obj);
				if(obj !== false) { this.__callback({ "obj" : obj, "prev" : prev, "parent" : p }); }
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var s = this._get_settings().crrm.move;
				if(!s.check_move.call(this, this._get_move())) { return false; }
				return true;
			},
			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
				var s = this._get_settings().crrm.move;
				if(!is_prepared) { 
					if(typeof position === "undefined") { position = s.default_position; }
					if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }
					return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
				}
				// if the move is already prepared
				if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {
					is_copy = true;
				}
				this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
			},

			cut : function (obj) {
				obj = this._get_node(obj, true);
				if(!obj || !obj.length) { return false; }
				this.data.crrm.cp_nodes = false;
				this.data.crrm.ct_nodes = obj;
				this.__callback({ "obj" : obj });
			},
			copy : function (obj) {
				obj = this._get_node(obj, true);
				if(!obj || !obj.length) { return false; }
				this.data.crrm.ct_nodes = false;
				this.data.crrm.cp_nodes = obj;
				this.__callback({ "obj" : obj });
			},
			paste : function (obj) { 
				obj = this._get_node(obj);
				if(!obj || !obj.length) { return false; }
				var nodes = this.data.crrm.ct_nodes ? this.data.crrm.ct_nodes : this.data.crrm.cp_nodes;
				if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }
				if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); this.data.crrm.ct_nodes = false; }
				if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }
				this.__callback({ "obj" : obj, "nodes" : nodes });
			}
		}
	});
	// include the crr plugin by default
	// $.jstree.defaults.plugins.push("crrm");
})(jQuery);
//*/

/* 
 * jsTree themes plugin
 * Handles loading and setting themes, as well as detecting path to themes, etc.
 */
(function ($) {
	var themes_loaded = [];
	// this variable stores the path to the themes folder - if left as false - it will be autodetected
	$.jstree._themes = false;
	$.jstree.plugin("themes", {
		__init : function () { 
			this.get_container()
				.bind("init.jstree", $.proxy(function () {
						var s = this._get_settings().themes;
						this.data.themes.dots = s.dots; 
						this.data.themes.icons = s.icons; 
						this.set_theme(s.theme, s.url);
					}, this))
				.bind("loaded.jstree", $.proxy(function () {
						// bound here too, as simple HTML tree's won't honor dots & icons otherwise
						if(!this.data.themes.dots) { this.hide_dots(); }
						else { this.show_dots(); }
						if(!this.data.themes.icons) { this.hide_icons(); }
						else { this.show_icons(); }
					}, this));
		},
		defaults : { 
			theme : "default", 
			url : false,
			dots : true,
			icons : true
		},
		_fn : {
			set_theme : function (theme_name, theme_url) {
				if(!theme_name) { return false; }
				if(!theme_url) { theme_url = $.jstree._themes + theme_name + '/style.css'; }
				if($.inArray(theme_url, themes_loaded) == -1) {
					$.vakata.css.add_sheet({ "url" : theme_url });
					themes_loaded.push(theme_url);
				}
				if(this.data.themes.theme != theme_name) {
					this.get_container().removeClass('jstree-' + this.data.themes.theme);
					this.data.themes.theme = theme_name;
				}
				this.get_container().addClass('jstree-' + theme_name);
				if(!this.data.themes.dots) { this.hide_dots(); }
				else { this.show_dots(); }
				if(!this.data.themes.icons) { this.hide_icons(); }
				else { this.show_icons(); }
				this.__callback();
			},
			get_theme	: function () { return this.data.themes.theme; },

			show_dots	: function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
			hide_dots	: function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
			toggle_dots	: function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },

			show_icons	: function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
			hide_icons	: function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
			toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }
		}
	});
	// autodetect themes path
	$(function () {
		if($.jstree._themes === false) {
			$("script").each(function () { 
				if(this.src.toString().match(/jquery\.jstree[^\/]*?\.js(\?.*)?$/)) { 
					$.jstree._themes = this.src.toString().replace(/jquery\.jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
					return false; 
				}
			});
		}
		if($.jstree._themes === false) { $.jstree._themes = "themes/"; }
	});
	// include the themes plugin by default
	$.jstree.defaults.plugins.push("themes");
})(jQuery);
//*/

/*
 * jsTree hotkeys plugin
 * Enables keyboard navigation for all tree instances
 * Depends on the jstree ui & jquery hotkeys plugins
 */
(function ($) {
	var bound = [];
	function exec(i, event) {
		var f = $.jstree._focused(), tmp;
		if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { 
			tmp = f._get_settings().hotkeys[i];
			if(tmp) { return tmp.call(f, event); }
		}
	}
	$.jstree.plugin("hotkeys", {
		__init : function () {
			if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }
			if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }
			$.each(this._get_settings().hotkeys, function (i, v) {
				if(v !== false && $.inArray(i, bound) == -1) {
					$(document).bind("keydown", i, function (event) { return exec(i, event); });
					bound.push(i);
				}
			});
			this.get_container()
				.bind("lock.jstree", $.proxy(function () {
						if(this.data.hotkeys.enabled) { this.data.hotkeys.enabled = false; this.data.hotkeys.revert = true; }
					}, this))
				.bind("unlock.jstree", $.proxy(function () {
						if(this.data.hotkeys.revert) { this.data.hotkeys.enabled = true; }
					}, this));
			this.enable_hotkeys();
		},
		defaults : {
			"up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"ctrl+up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"shift+up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"ctrl+down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"shift+down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"ctrl+left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"shift+left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"ctrl+right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"shift+right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"space" : function () { 
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } 
				return false; 
			},
			"ctrl+space" : function (event) { 
				event.type = "click";
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
				return false; 
			},
			"shift+space" : function (event) { 
				event.type = "click";
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
				return false; 
			},
			"f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },
			"del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }
		},
		_fn : {
			enable_hotkeys : function () {
				this.data.hotkeys.enabled = true;
			},
			disable_hotkeys : function () {
				this.data.hotkeys.enabled = false;
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree JSON plugin
 * The JSON data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.jstree.plugin("json_data", {
		__init : function() {
			var s = this._get_settings().json_data;
			if(s.progressive_unload) {
				this.get_container().bind("after_close.jstree", function (e, data) {
					data.rslt.obj.children("ul").remove();
				});
			}
		},
		defaults : { 
			// `data` can be a function:
			//  * accepts two arguments - node being loaded and a callback to pass the result to
			//  * will be executed in the current tree's scope & ajax won't be supported
			data : false, 
			ajax : false,
			correct_state : true,
			progressive_render : false,
			progressive_unload : false
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				var s = this._get_settings().json_data;
				obj = this._get_node(obj); 
				return obj == -1 || !obj || (!s.ajax && !s.progressive_render && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").length > 0;
			},
			refresh : function (obj) {
				obj = this._get_node(obj);
				var s = this._get_settings().json_data;
				if(obj && obj !== -1 && s.progressive_unload && ($.isFunction(s.data) || !!s.ajax)) {
					obj.removeData("jstree_children");
				}
				return this.__call_old();
			},
			load_node_json : function (obj, s_call, e_call) {
				var s = this.get_settings().json_data, d,
					error_func = function () {},
					success_func = function () {};
				obj = this._get_node(obj);

				if(obj && obj !== -1 && (s.progressive_render || s.progressive_unload) && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree_children")) {
					d = this._parse_json(obj.data("jstree_children"), obj);
					if(d) {
						obj.append(d);
						if(!s.progressive_unload) { obj.removeData("jstree_children"); }
					}
					this.clean_node(obj);
					if(s_call) { s_call.call(this); }
					return;
				}

				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
					// function option added here for easier model integration (also supporting async - see callback)
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							d = this._parse_json(d, obj);
							if(!d) { 
								if(obj === -1 || !obj) {
									if(s.correct_state) { this.get_container().children("ul").empty(); }
								}
								else {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { this.correct_state(obj); }
								}
								if(e_call) { e_call.call(this); }
							}
							else {
								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
						}, this));
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							d = this._parse_json(s.data, obj);
							if(d) {
								this.get_container().children("ul").empty().append(d.children());
								this.clean_node();
							}
							else { 
								if(s.correct_state) { this.get_container().children("ul").empty(); }
							}
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						error_func = function (x, t, e) {
							var ef = this.get_settings().json_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj != -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							var sf = this.get_settings().json_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "") || (!$.isArray(d) && !$.isPlainObject(d))) {
								return error_func.call(this, x, t, "");
							}
							d = this._parse_json(d, obj);
							if(d) {
								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj === -1 || !obj) {
									if(s.correct_state) { 
										this.get_container().children("ul").empty(); 
										if(s_call) { s_call.call(this); }
									}
								}
								else {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "json"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			},
			_parse_json : function (js, obj, is_callback) {
				var d = false, 
					p = this._get_settings(),
					s = p.json_data,
					t = p.core.html_titles,
					tmp, i, j, ul1, ul2;

				if(!js) { return d; }
				if(s.progressive_unload && obj && obj !== -1) { 
					obj.data("jstree_children", d);
				}
				if($.isArray(js)) {
					d = $();
					if(!js.length) { return false; }
					for(i = 0, j = js.length; i < j; i++) {
						tmp = this._parse_json(js[i], obj, true);
						if(tmp.length) { d = d.add(tmp); }
					}
				}
				else {
					if(typeof js == "string") { js = { data : js }; }
					if(!js.data && js.data !== "") { return d; }
					d = $("<li />");
					if(js.attr) { d.attr(js.attr); }
					if(js.metadata) { d.data(js.metadata); }
					if(js.state) { d.addClass("jstree-" + js.state); }
					if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
					$.each(js.data, function (i, m) {
						tmp = $("<a />");
						if($.isFunction(m)) { m = m.call(this, js); }
						if(typeof m == "string") { tmp.attr('href','#')[ t ? "html" : "text" ](m); }
						else {
							if(!m.attr) { m.attr = {}; }
							if(!m.attr.href) { m.attr.href = '#'; }
							tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);
							if(m.language) { tmp.addClass(m.language); }
						}
						tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
						if(!m.icon && js.icon) { m.icon = js.icon; }
						if(m.icon) { 
							if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
							else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
						}
						d.append(tmp);
					});
					d.prepend("<ins class='jstree-icon'>&#160;</ins>");
					if(js.children) { 
						if(s.progressive_render && js.state !== "open") {
							d.addClass("jstree-closed").data("jstree_children", js.children);
						}
						else {
							if(s.progressive_unload) { d.data("jstree_children", js.children); }
							if($.isArray(js.children) && js.children.length) {
								tmp = this._parse_json(js.children, obj, true);
								if(tmp.length) {
									ul2 = $("<ul />");
									ul2.append(tmp);
									d.append(ul2);
								}
							}
						}
					}
				}
				if(!is_callback) {
					ul1 = $("<ul />");
					ul1.append(d);
					d = ul1;
				}
				return d;
			},
			get_json : function (obj, li_attr, a_attr, is_callback) {
				var result = [], 
					s = this._get_settings(), 
					_this = this,
					tmp1, tmp2, li, a, t, lang;
				obj = this._get_node(obj);
				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
				if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }
				a_attr = $.isArray(a_attr) ? a_attr : [ ];

				obj.each(function () {
					li = $(this);
					tmp1 = { data : [] };
					if(li_attr.length) { tmp1.attr = { }; }
					$.each(li_attr, function (i, v) { 
						tmp2 = li.attr(v); 
						if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*/ig,'').length) {
							tmp1.attr[v] = (" " + tmp2).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,""); 
						}
					});
					if(li.hasClass("jstree-open")) { tmp1.state = "open"; }
					if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }
					if(li.data()) { tmp1.metadata = li.data(); }
					a = li.children("a");
					a.each(function () {
						t = $(this);
						if(
							a_attr.length || 
							$.inArray("languages", s.plugins) !== -1 || 
							t.children("ins").get(0).style.backgroundImage.length || 
							(t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').length)
						) { 
							lang = false;
							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
								$.each(s.languages, function (l, lv) {
									if(t.hasClass(lv)) {
										lang = lv;
										return false;
									}
								});
							}
							tmp2 = { attr : { }, title : _this.get_text(t, lang) }; 
							$.each(a_attr, function (k, z) {
								tmp2.attr[z] = (" " + (t.attr(z) || "")).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
							});
							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
								$.each(s.languages, function (k, z) {
									if(t.hasClass(z)) { tmp2.language = z; return true; }
								});
							}
							if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
								tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
							}
							if(t.children("ins").get(0).style.backgroundImage.length) {
								tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");
							}
						}
						else {
							tmp2 = _this.get_text(t);
						}
						if(a.length > 1) { tmp1.data.push(tmp2); }
						else { tmp1.data = tmp2; }
					});
					li = li.find("> ul > li");
					if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }
					result.push(tmp1);
				});
				return result;
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree languages plugin
 * Adds support for multiple language versions in one tree
 * This basically allows for many titles coexisting in one node, but only one of them being visible at any given time
 * This is useful for maintaining the same structure in many languages (hence the name of the plugin)
 */
(function ($) {
	$.jstree.plugin("languages", {
		__init : function () { this._load_css();  },
		defaults : [],
		_fn : {
			set_lang : function (i) { 
				var langs = this._get_settings().languages,
					st = false,
					selector = ".jstree-" + this.get_index() + ' a';
				if(!$.isArray(langs) || langs.length === 0) { return false; }
				if($.inArray(i,langs) == -1) {
					if(!!langs[i]) { i = langs[i]; }
					else { return false; }
				}
				if(i == this.data.languages.current_language) { return true; }
				st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, this.data.languages.language_css);
				if(st !== false) { st.style.display = "none"; }
				st = $.vakata.css.get_css(selector + "." + i, false, this.data.languages.language_css);
				if(st !== false) { st.style.display = ""; }
				this.data.languages.current_language = i;
				this.__callback(i);
				return true;
			},
			get_lang : function () {
				return this.data.languages.current_language;
			},
			_get_string : function (key, lang) {
				var langs = this._get_settings().languages,
					s = this._get_settings().core.strings;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
				}
				if(s[lang] && s[lang][key]) { return s[lang][key]; }
				if(s[key]) { return s[key]; }
				return key;
			},
			get_text : function (obj, lang) {
				obj = this._get_node(obj) || this.data.ui.last_selected;
				if(!obj.size()) { return false; }
				var langs = this._get_settings().languages,
					s = this._get_settings().core.html_titles;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
					obj = obj.children("a." + lang);
				}
				else { obj = obj.children("a:eq(0)"); }
				if(s) {
					obj = obj.clone();
					obj.children("INS").remove();
					return obj.html();
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					return obj.nodeValue;
				}
			},
			set_text : function (obj, val, lang) {
				obj = this._get_node(obj) || this.data.ui.last_selected;
				if(!obj.size()) { return false; }
				var langs = this._get_settings().languages,
					s = this._get_settings().core.html_titles,
					tmp;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
					obj = obj.children("a." + lang);
				}
				else { obj = obj.children("a:eq(0)"); }
				if(s) {
					tmp = obj.children("INS").clone();
					obj.html(val).prepend(tmp);
					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
					return true;
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
					return (obj.nodeValue = val);
				}
			},
			_load_css : function () {
				var langs = this._get_settings().languages,
					str = "/* languages css */",
					selector = ".jstree-" + this.get_index() + ' a',
					ln;
				if($.isArray(langs) && langs.length) {
					this.data.languages.current_language = langs[0];
					for(ln = 0; ln < langs.length; ln++) {
						str += selector + "." + langs[ln] + " {";
						if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }
						str += " } ";
					}
					this.data.languages.language_css = $.vakata.css.add_sheet({ 'str' : str, 'title' : "jstree-languages" });
				}
			},
			create_node : function (obj, position, js, callback) {
				var t = this.__call_old(true, obj, position, js, function (t) {
					var langs = this._get_settings().languages,
						a = t.children("a"),
						ln;
					if($.isArray(langs) && langs.length) {
						for(ln = 0; ln < langs.length; ln++) {
							if(!a.is("." + langs[ln])) {
								t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));
							}
						}
						a.not("." + langs.join(", .")).remove();
					}
					if(callback) { callback.call(this, t); }
				});
				return t;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree cookies plugin
 * Stores the currently opened/selected nodes in a cookie and then restores them
 * Depends on the jquery.cookie plugin
 */
(function ($) {
	$.jstree.plugin("cookies", {
		__init : function () {
			if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }

			var s = this._get_settings().cookies,
				tmp;
			if(!!s.save_loaded) {
				tmp = $.cookie(s.save_loaded);
				if(tmp && tmp.length) { this.data.core.to_load = tmp.split(","); }
			}
			if(!!s.save_opened) {
				tmp = $.cookie(s.save_opened);
				if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }
			}
			if(!!s.save_selected) {
				tmp = $.cookie(s.save_selected);
				if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }
			}
			this.get_container()
				.one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {
					this.get_container()
						.bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { 
								if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }
							}, this));
				}, this));
		},
		defaults : {
			save_loaded		: "jstree_load",
			save_opened		: "jstree_open",
			save_selected	: "jstree_select",
			auto_save		: true,
			cookie_options	: {}
		},
		_fn : {
			save_cookie : function (c) {
				if(this.data.core.refreshing) { return; }
				var s = this._get_settings().cookies;
				if(!c) { // if called manually and not by event
					if(s.save_loaded) {
						this.save_loaded();
						$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options);
					}
					if(s.save_opened) {
						this.save_opened();
						$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);
					}
					if(s.save_selected && this.data.ui) {
						this.save_selected();
						$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);
					}
					return;
				}
				switch(c) {
					case "open_node":
					case "close_node":
						if(!!s.save_opened) { 
							this.save_opened(); 
							$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); 
						}
						if(!!s.save_loaded) { 
							this.save_loaded(); 
							$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options); 
						}
						break;
					case "select_node":
					case "deselect_node":
						if(!!s.save_selected && this.data.ui) { 
							this.save_selected(); 
							$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); 
						}
						break;
				}
			}
		}
	});
	// include cookies by default
	// $.jstree.defaults.plugins.push("cookies");
})(jQuery);
//*/

/*
 * jsTree sort plugin
 * Sorts items alphabetically (or using any other function)
 */
(function ($) {
	$.jstree.plugin("sort", {
		__init : function () {
			this.get_container()
				.bind("load_node.jstree", $.proxy(function (e, data) {
						var obj = this._get_node(data.rslt.obj);
						obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");
						this.sort(obj);
					}, this))
				.bind("rename_node.jstree create_node.jstree create.jstree", $.proxy(function (e, data) {
						this.sort(data.rslt.obj.parent());
					}, this))
				.bind("move_node.jstree", $.proxy(function (e, data) {
						var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;
						this.sort(m.children("ul"));
					}, this));
		},
		defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },
		_fn : {
			sort : function (obj) {
				var s = this._get_settings().sort,
					t = this;
				obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
				obj.find("> li > ul").each(function() { t.sort($(this)); });
				this.clean_node(obj);
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree DND plugin
 * Drag and drop plugin for moving/copying nodes
 */
(function ($) {
	var o = false,
		r = false,
		m = false,
		ml = false,
		sli = false,
		sti = false,
		dir1 = false,
		dir2 = false,
		last_pos = false;
	$.vakata.dnd = {
		is_down : false,
		is_drag : false,
		helper : false,
		scroll_spd : 10,
		init_x : 0,
		init_y : 0,
		threshold : 5,
		helper_left : 5,
		helper_top : 10,
		user_data : {},

		drag_start : function (e, data, html) { 
			if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }
			try {
				e.currentTarget.unselectable = "on";
				e.currentTarget.onselectstart = function() { return false; };
				if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
			} catch(err) { }
			$.vakata.dnd.init_x = e.pageX;
			$.vakata.dnd.init_y = e.pageY;
			$.vakata.dnd.user_data = data;
			$.vakata.dnd.is_down = true;
			$.vakata.dnd.helper = $("<div id='vakata-dragged' />").html(html); //.fadeTo(10,0.25);
			$(document).bind("mousemove", $.vakata.dnd.drag);
			$(document).bind("mouseup", $.vakata.dnd.drag_stop);
			return false;
		},
		drag : function (e) { 
			if(!$.vakata.dnd.is_down) { return; }
			if(!$.vakata.dnd.is_drag) {
				if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { 
					$.vakata.dnd.helper.appendTo("body");
					$.vakata.dnd.is_drag = true;
					$(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
				}
				else { return; }
			}

			// maybe use a scrolling parent element instead of document?
			if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a
				var d = $(document), t = d.scrollTop(), l = d.scrollLeft();
				if(e.pageY - t < 20) { 
					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
					if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
				}
				if($(window).height() - (e.pageY - t) < 20) {
					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
					if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
				}

				if(e.pageX - l < 20) {
					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
					if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
				}
				if($(window).width() - (e.pageX - l) < 20) {
					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
					if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
				}
			}

			$.vakata.dnd.helper.css({ left : (e.pageX + $.vakata.dnd.helper_left) + "px", top : (e.pageY + $.vakata.dnd.helper_top) + "px" });
			$(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
		},
		drag_stop : function (e) {
			if(sli) { clearInterval(sli); }
			if(sti) { clearInterval(sti); }
			$(document).unbind("mousemove", $.vakata.dnd.drag);
			$(document).unbind("mouseup", $.vakata.dnd.drag_stop);
			$(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
			$.vakata.dnd.helper.remove();
			$.vakata.dnd.init_x = 0;
			$.vakata.dnd.init_y = 0;
			$.vakata.dnd.user_data = {};
			$.vakata.dnd.is_down = false;
			$.vakata.dnd.is_drag = false;
		}
	};
	$(function() {
		var css_string = '#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });
	});

	$.jstree.plugin("dnd", {
		__init : function () {
			this.data.dnd = {
				active : false,
				after : false,
				inside : false,
				before : false,
				off : false,
				prepared : false,
				w : 0,
				to1 : false,
				to2 : false,
				cof : false,
				cw : false,
				ch : false,
				i1 : false,
				i2 : false,
				mto : false
			};
			this.get_container()
				.bind("mouseenter.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(this.data.themes) {
								m.attr("class", "jstree-" + this.data.themes.theme); 
								if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
								$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);
							}
							//if($(e.currentTarget).find("> ul > li").length === 0) {
							if(e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree
								var tr = $.jstree._reference(e.target), dc;
								if(tr.data.dnd.foreign) {
									dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
									if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {
										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
									}
								}
								else {
									tr.prepare_move(o, tr.get_container(), "last");
									if(tr.check_move()) {
										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
									}
								}
							}
						}
					}, this))
				.bind("mouseup.jstree", $.proxy(function (e) {
						//if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && $(e.currentTarget).find("> ul > li").length === 0) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree
							var tr = $.jstree._reference(e.currentTarget), dc;
							if(tr.data.dnd.foreign) {
								dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
								if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {
									tr._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
								}
							}
							else {
								tr.move_node(o, tr.get_container(), "last", e[tr._get_settings().dnd.copy_modifier + "Key"]);
							}
						}
					}, this))
				.bind("mouseleave.jstree", $.proxy(function (e) {
						if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {
							return false; 
						}
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
							if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
							if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
							if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
							if($.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
							}
						}
					}, this))
				.bind("mousemove.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							var cnt = this.get_container()[0];

							// Horizontal scroll
							if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else if(e.pageX - 24 < this.data.dnd.cof.left) {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
							}

							// Vertical scroll
							if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else if(e.pageY - 24 < this.data.dnd.cof.top) {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
							}

						}
					}, this))
				.bind("scroll.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && m && ml) {
							m.hide();
							ml.hide();
						}
					}, this))
				.delegate("a", "mousedown.jstree", $.proxy(function (e) { 
						if(e.which === 1) {
							this.start_drag(e.currentTarget, e);
							return false;
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							this.dnd_enter(e.currentTarget);
						}
					}, this))
				.delegate("a", "mousemove.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(!r || !r.length || r.children("a")[0] !== e.currentTarget) {
								this.dnd_enter(e.currentTarget);
							}
							if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }
							this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;
							if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }
							this.dnd_show();
						}
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {
								return false; 
							}
								if(m) { m.hide(); }
								if(ml) { ml.hide(); }
							/*
							var ec = $(e.currentTarget).closest("li"), 
								er = $(e.relatedTarget).closest("li");
							if(er[0] !== ec.prev()[0] && er[0] !== ec.next()[0]) {
								if(m) { m.hide(); }
								if(ml) { ml.hide(); }
							}
							*/
							this.data.dnd.mto = setTimeout( 
								(function (t) { return function () { t.dnd_leave(e); }; })(this),
							0);
						}
					}, this))
				.delegate("a", "mouseup.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							this.dnd_finish(e);
						}
					}, this));

			$(document)
				.bind("drag_stop.vakata", $.proxy(function () {
						if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
						if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
						if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
						if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
						this.data.dnd.after		= false;
						this.data.dnd.before	= false;
						this.data.dnd.inside	= false;
						this.data.dnd.off		= false;
						this.data.dnd.prepared	= false;
						this.data.dnd.w			= false;
						this.data.dnd.to1		= false;
						this.data.dnd.to2		= false;
						this.data.dnd.i1		= false;
						this.data.dnd.i2		= false;
						this.data.dnd.active	= false;
						this.data.dnd.foreign	= false;
						if(m) { m.css({ "top" : "-2000px" }); }
						if(ml) { ml.css({ "top" : "-2000px" }); }
					}, this))
				.bind("drag_start.vakata", $.proxy(function (e, data) {
						if(data.data.jstree) { 
							var et = $(data.event.target);
							if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {
								this.dnd_enter(et);
							}
						}
					}, this));
				/*
				.bind("keydown.jstree-" + this.get_index() + " keyup.jstree-" + this.get_index(), $.proxy(function(e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && !this.data.dnd.foreign) {
							var h = $.vakata.dnd.helper.children("ins");
							if(e[this._get_settings().dnd.copy_modifier + "Key"] && h.hasClass("jstree-ok")) {
								h.parent().html(h.parent().html().replace(/ \(Copy\)$/, "") + " (Copy)");
							} 
							else {
								h.parent().html(h.parent().html().replace(/ \(Copy\)$/, ""));
							}
						}
					}, this)); */



			var s = this._get_settings().dnd;
			if(s.drag_target) {
				$(document)
					.delegate(s.drag_target, "mousedown.jstree-" + this.get_index(), $.proxy(function (e) {
						o = e.target;
						$.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class='jstree-icon'></ins>" + $(e.target).text() );
						if(this.data.themes) { 
							if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }
							if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
						}
						$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
						var cnt = this.get_container();
						this.data.dnd.cof = cnt.offset();
						this.data.dnd.cw = parseInt(cnt.width(),10);
						this.data.dnd.ch = parseInt(cnt.height(),10);
						this.data.dnd.foreign = true;
						e.preventDefault();
					}, this));
			}
			if(s.drop_target) {
				$(document)
					.delegate(s.drop_target, "mouseenter.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target), "e" : e })) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
							}
						}, this))
					.delegate(s.drop_target, "mouseleave.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
							}
						}, this))
					.delegate(s.drop_target, "mouseup.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
								this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target), "e" : e });
							}
						}, this));
			}
		},
		defaults : {
			copy_modifier	: "ctrl",
			check_timeout	: 100,
			open_timeout	: 500,
			drop_target		: ".jstree-drop",
			drop_check		: function (data) { return true; },
			drop_finish		: $.noop,
			drag_target		: ".jstree-draggable",
			drag_finish		: $.noop,
			drag_check		: function (data) { return { after : false, before : false, inside : true }; }
		},
		_fn : {
			dnd_prepare : function () {
				if(!r || !r.length) { return; }
				this.data.dnd.off = r.offset();
				if(this._get_settings().core.rtl) {
					this.data.dnd.off.right = this.data.dnd.off.left + r.width();
				}
				if(this.data.dnd.foreign) {
					var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });
					this.data.dnd.after = a.after;
					this.data.dnd.before = a.before;
					this.data.dnd.inside = a.inside;
					this.data.dnd.prepared = true;
					return this.dnd_show();
				}
				this.prepare_move(o, r, "before");
				this.data.dnd.before = this.check_move();
				this.prepare_move(o, r, "after");
				this.data.dnd.after = this.check_move();
				if(this._is_loaded(r)) {
					this.prepare_move(o, r, "inside");
					this.data.dnd.inside = this.check_move();
				}
				else {
					this.data.dnd.inside = false;
				}
				this.data.dnd.prepared = true;
				return this.dnd_show();
			},
			dnd_show : function () {
				if(!this.data.dnd.prepared) { return; }
				var o = ["before","inside","after"],
					r = false,
					rtl = this._get_settings().core.rtl,
					pos;
				if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }
				else if(this.data.dnd.w <= this.data.core.li_height*2/3) {
					o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];
				}
				else { o = ["after","inside","before"]; }
				$.each(o, $.proxy(function (i, val) { 
					if(this.data.dnd[val]) {
						$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
						r = val;
						return false;
					}
				}, this));
				if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }
				
				pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);
				switch(r) {
					case "before":
						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();
						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top - 1) + "px" }).show(); }
						break;
					case "after":
						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 6) + "px" }).show();
						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 1) + "px" }).show(); }
						break;
					case "inside":
						m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();
						if(ml) { ml.hide(); }
						break;
					default:
						m.hide();
						if(ml) { ml.hide(); }
						break;
				}
				last_pos = r;
				return r;
			},
			dnd_open : function () {
				this.data.dnd.to2 = false;
				this.open_node(r, $.proxy(this.dnd_prepare,this), true);
			},
			dnd_finish : function (e) {
				if(this.data.dnd.foreign) {
					if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {
						this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r, "p" : last_pos });
					}
				}
				else {
					this.dnd_prepare();
					this.move_node(o, r, last_pos, e[this._get_settings().dnd.copy_modifier + "Key"]);
				}
				o = false;
				r = false;
				m.hide();
				if(ml) { ml.hide(); }
			},
			dnd_enter : function (obj) {
				if(this.data.dnd.mto) { 
					clearTimeout(this.data.dnd.mto);
					this.data.dnd.mto = false;
				}
				var s = this._get_settings().dnd;
				this.data.dnd.prepared = false;
				r = this._get_node(obj);
				if(s.check_timeout) { 
					// do the calculations after a minimal timeout (users tend to drag quickly to the desired location)
					if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
					this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); 
				}
				else { 
					this.dnd_prepare(); 
				}
				if(s.open_timeout) { 
					if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
					if(r && r.length && r.hasClass("jstree-closed")) { 
						// if the node is closed - open it, then recalculate
						this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);
					}
				}
				else {
					if(r && r.length && r.hasClass("jstree-closed")) { 
						this.dnd_open();
					}
				}
			},
			dnd_leave : function (e) {
				this.data.dnd.after		= false;
				this.data.dnd.before	= false;
				this.data.dnd.inside	= false;
				$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
				m.hide();
				if(ml) { ml.hide(); }
				if(r && r[0] === e.target.parentNode) {
					if(this.data.dnd.to1) {
						clearTimeout(this.data.dnd.to1);
						this.data.dnd.to1 = false;
					}
					if(this.data.dnd.to2) {
						clearTimeout(this.data.dnd.to2);
						this.data.dnd.to2 = false;
					}
				}
			},
			start_drag : function (obj, e) {
				o = this._get_node(obj);
				if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }
				var dt = o.length > 1 ? this._get_string("multiple_selection") : this.get_text(o),
					cnt = this.get_container();
				if(!this._get_settings().core.html_titles) { dt = dt.replace(/</ig,"&lt;").replace(/>/ig,"&gt;"); }
				$.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class='jstree-icon'></ins>" + dt );
				if(this.data.themes) { 
					if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }
					if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
					$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
				}
				this.data.dnd.cof = cnt.offset();
				this.data.dnd.cw = parseInt(cnt.width(),10);
				this.data.dnd.ch = parseInt(cnt.height(),10);
				this.data.dnd.active = true;
			}
		}
	});
	$(function() {
		var css_string = '' + 
			'#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; ' + 
			' -moz-border-radius:4px; border-radius:4px; -webkit-border-radius:4px; ' +
			'} ' + 
			'#vakata-dragged .jstree-ok { background:green; } ' + 
			'#vakata-dragged .jstree-invalid { background:red; } ' + 
			'#jstree-marker { padding:0; margin:0; font-size:12px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10001; background-repeat:no-repeat; display:none; background-color:transparent; text-shadow:1px 1px 1px white; color:black; line-height:10px; } ' + 
			'#jstree-marker-line { padding:0; margin:0; line-height:0%; font-size:1px; overflow:hidden; height:1px; width:100px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:#456c43; ' + 
			' cursor:pointer; border:1px solid #eeeeee; border-left:0; -moz-box-shadow: 0px 0px 2px #666; -webkit-box-shadow: 0px 0px 2px #666; box-shadow: 0px 0px 2px #666; ' + 
			' -moz-border-radius:1px; border-radius:1px; -webkit-border-radius:1px; ' +
			'}' + 
			'';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
		m = $("<div />").attr({ id : "jstree-marker" }).hide().html("&raquo;")
			.bind("mouseleave mouseenter", function (e) { 
				m.hide();
				ml.hide();
				e.preventDefault(); 
				e.stopImmediatePropagation(); 
				return false; 
			})
			.appendTo("body");
		ml = $("<div />").attr({ id : "jstree-marker-line" }).hide()
			.bind("mouseup", function (e) { 
				if(r && r.length) { 
					r.children("a").trigger(e); 
					e.preventDefault(); 
					e.stopImmediatePropagation(); 
					return false; 
				} 
			})
			.bind("mouseleave", function (e) { 
				var rt = $(e.relatedTarget);
				if(rt.is(".jstree") || rt.closest(".jstree").length === 0) {
					if(r && r.length) { 
						r.children("a").trigger(e); 
						m.hide();
						ml.hide();
						e.preventDefault(); 
						e.stopImmediatePropagation(); 
						return false; 
					}
				}
			})
			.appendTo("body");
		$(document).bind("drag_start.vakata", function (e, data) {
			if(data.data.jstree) { m.show(); if(ml) { ml.show(); } }
		});
		$(document).bind("drag_stop.vakata", function (e, data) {
			if(data.data.jstree) { m.hide(); if(ml) { ml.hide(); } }
		});
	});
})(jQuery);
//*/

/*
 * jsTree checkbox plugin
 * Inserts checkboxes in front of every node
 * Depends on the ui plugin
 * DOES NOT WORK NICELY WITH MULTITREE DRAG'N'DROP
 */
(function ($) {
	$.jstree.plugin("checkbox", {
		__init : function () {
			this.data.checkbox.noui = this._get_settings().checkbox.override_ui;
			if(this.data.ui && this.data.checkbox.noui) {
				this.select_node = this.deselect_node = this.deselect_all = $.noop;
				this.get_selected = this.get_checked;
			}

			this.get_container()
				.bind("open_node.jstree create_node.jstree clean_node.jstree refresh.jstree", $.proxy(function (e, data) { 
						this._prepare_checkboxes(data.rslt.obj);
					}, this))
				.bind("loaded.jstree", $.proxy(function (e) {
						this._prepare_checkboxes();
					}, this))
				.delegate( (this.data.ui && this.data.checkbox.noui ? "a" : "ins.jstree-checkbox") , "click.jstree", $.proxy(function (e) {
						e.preventDefault();
						if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }
						else { this.check_node(e.target); }
						if(this.data.ui && this.data.checkbox.noui) {
							this.save_selected();
							if(this.data.cookies) { this.save_cookie("select_node"); }
						}
						else {
							e.stopImmediatePropagation();
							return false;
						}
					}, this));
		},
		defaults : {
			override_ui : false,
			two_state : false,
			real_checkboxes : false,
			checked_parent_open : true,
			real_checkboxes_names : function (n) { return [ ("check_" + (n[0].id || Math.ceil(Math.random() * 10000))) , 1]; }
		},
		__destroy : function () {
			this.get_container()
				.find("input.jstree-real-checkbox").removeClass("jstree-real-checkbox").end()
				.find("ins.jstree-checkbox").remove();
		},
		_fn : {
			_checkbox_notify : function (n, data) {
				if(data.checked) {
					this.check_node(n, false);
				}
			},
			_prepare_checkboxes : function (obj) {
				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);
				if(obj === false) { return; } // added for removing root nodes
				var c, _this = this, t, ts = this._get_settings().checkbox.two_state, rc = this._get_settings().checkbox.real_checkboxes, rcn = this._get_settings().checkbox.real_checkboxes_names;
				obj.each(function () {
					t = $(this);
					c = t.is("li") && (t.hasClass("jstree-checked") || (rc && t.children(":checked").length)) ? "jstree-checked" : "jstree-unchecked";
					t.find("li").andSelf().each(function () {
						var $t = $(this), nm;
						$t.children("a" + (_this.data.languages ? "" : ":eq(0)") ).not(":has(.jstree-checkbox)").prepend("<ins class='jstree-checkbox'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass( ts ? "jstree-unchecked" : c );
						if(rc) {
							if(!$t.children(":checkbox").length) {
								nm = rcn.call(_this, $t);
								$t.prepend("<input type='checkbox' class='jstree-real-checkbox' id='" + nm[0] + "' name='" + nm[0] + "' value='" + nm[1] + "' />");
							}
							else {
								$t.children(":checkbox").addClass("jstree-real-checkbox");
							}
						}
						if(!ts) {
							if(c === "jstree-checked" || $t.hasClass("jstree-checked") || $t.children(':checked').length) {
								$t.find("li").andSelf().addClass("jstree-checked").children(":checkbox").prop("checked", true);
							}
						}
						else {
							if($t.hasClass("jstree-checked") || $t.children(':checked').length) {
								$t.addClass("jstree-checked").children(":checkbox").prop("checked", true);
							}
						}
					});
				});
				if(!ts) {
					obj.find(".jstree-checked").parent().parent().each(function () { _this._repair_state(this); }); 
				}
			},
			change_state : function (obj, state) {
				obj = this._get_node(obj);
				var coll = false, rc = this._get_settings().checkbox.real_checkboxes;
				if(!obj || obj === -1) { return false; }
				state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");
				if(this._get_settings().checkbox.two_state) {
					if(state) { 
						obj.removeClass("jstree-checked").addClass("jstree-unchecked"); 
						if(rc) { obj.children(":checkbox").prop("checked", false); }
					}
					else { 
						obj.removeClass("jstree-unchecked").addClass("jstree-checked"); 
						if(rc) { obj.children(":checkbox").prop("checked", true); }
					}
				}
				else {
					if(state) { 
						coll = obj.find("li").andSelf();
						if(!coll.filter(".jstree-checked, .jstree-undetermined").length) { return false; }
						coll.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); 
						if(rc) { coll.children(":checkbox").prop("checked", false); }
					}
					else { 
						coll = obj.find("li").andSelf();
						if(!coll.filter(".jstree-unchecked, .jstree-undetermined").length) { return false; }
						coll.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); 
						if(rc) { coll.children(":checkbox").prop("checked", true); }
						if(this.data.ui) { this.data.ui.last_selected = obj; }
						this.data.checkbox.last_selected = obj;
					}
					obj.parentsUntil(".jstree", "li").each(function () {
						var $this = $(this);
						if(state) {
							if($this.children("ul").children("li.jstree-checked, li.jstree-undetermined").length) {
								$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
								if(rc) { $this.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
								return false;
							}
							else {
								$this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");
								if(rc) { $this.children(":checkbox").prop("checked", false); }
							}
						}
						else {
							if($this.children("ul").children("li.jstree-unchecked, li.jstree-undetermined").length) {
								$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
								if(rc) { $this.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
								return false;
							}
							else {
								$this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");
								if(rc) { $this.children(":checkbox").prop("checked", true); }
							}
						}
					});
				}
				if(this.data.ui && this.data.checkbox.noui) { this.data.ui.selected = this.get_checked(); }
				this.__callback(obj);
				return true;
			},
			check_node : function (obj) {
				if(this.change_state(obj, false)) { 
					obj = this._get_node(obj);
					if(this._get_settings().checkbox.checked_parent_open) {
						var t = this;
						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });
					}
					this.__callback({ "obj" : obj }); 
				}
			},
			uncheck_node : function (obj) {
				if(this.change_state(obj, true)) { this.__callback({ "obj" : this._get_node(obj) }); }
			},
			check_all : function () {
				var _this = this, 
					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");
				coll.each(function () {
					_this.change_state(this, false);
				});
				this.__callback();
			},
			uncheck_all : function () {
				var _this = this,
					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");
				coll.each(function () {
					_this.change_state(this, true);
				});
				this.__callback();
			},

			is_checked : function(obj) {
				obj = this._get_node(obj);
				return obj.length ? obj.is(".jstree-checked") : false;
			},
			get_checked : function (obj, get_all) {
				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-checked") : obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");
			},
			get_unchecked : function (obj, get_all) { 
				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-unchecked") : obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");
			},

			show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },
			hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },

			_repair_state : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return; }
				if(this._get_settings().checkbox.two_state) {
					obj.find('li').andSelf().not('.jstree-checked').removeClass('jstree-undetermined').addClass('jstree-unchecked').children(':checkbox').prop('checked', true);
					return;
				}
				var rc = this._get_settings().checkbox.real_checkboxes,
					a = obj.find("> ul > .jstree-checked").length,
					b = obj.find("> ul > .jstree-undetermined").length,
					c = obj.find("> ul > li").length;
				if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.change_state(obj, false); } }
				else if(a === 0 && b === 0) { this.change_state(obj, true); }
				else if(a === c) { this.change_state(obj, false); }
				else { 
					obj.parentsUntil(".jstree","li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
					if(rc) { obj.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
				}
			},
			reselect : function () {
				if(this.data.ui && this.data.checkbox.noui) { 
					var _this = this,
						s = this.data.ui.to_select;
					s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					this.deselect_all();
					$.each(s, function (i, val) { _this.check_node(val); });
					this.__callback();
				}
				else { 
					this.__call_old(); 
				}
			},
			save_loaded : function () {
				var _this = this;
				this.data.core.to_load = [];
				this.get_container_ul().find("li.jstree-closed.jstree-undetermined").each(function () {
					if(this.id) { _this.data.core.to_load.push("#" + this.id); }
				});
			}
		}
	});
	$(function() {
		var css_string = '.jstree .jstree-real-checkbox { display:none; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/* 
 * jsTree XML plugin
 * The XML data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.vakata.xslt = function (xml, xsl, callback) {
		var rs = "", xm, xs, processor, support;
		// TODO: IE9 no XSLTProcessor, no document.recalc
		if(document.recalc) {
			xm = document.createElement('xml');
			xs = document.createElement('xml');
			xm.innerHTML = xml;
			xs.innerHTML = xsl;
			$("body").append(xm).append(xs);
			setTimeout( (function (xm, xs, callback) {
				return function () {
					callback.call(null, xm.transformNode(xs.XMLDocument));
					setTimeout( (function (xm, xs) { return function () { $(xm).remove(); $(xs).remove(); }; })(xm, xs), 200);
				};
			})(xm, xs, callback), 100);
			return true;
		}
		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor === "undefined") {
			xml = new DOMParser().parseFromString(xml, "text/xml");
			xsl = new DOMParser().parseFromString(xsl, "text/xml");
			// alert(xml.transformNode());
			// callback.call(null, new XMLSerializer().serializeToString(rs));
			
		}
		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {
			processor = new XSLTProcessor();
			support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;
			if(!support) { return false; }
			xml = new DOMParser().parseFromString(xml, "text/xml");
			xsl = new DOMParser().parseFromString(xsl, "text/xml");
			if($.isFunction(processor.transformDocument)) {
				rs = document.implementation.createDocument("", "", null);
				processor.transformDocument(xml, xsl, rs, null);
				callback.call(null, new XMLSerializer().serializeToString(rs));
				return true;
			}
			else {
				processor.importStylesheet(xsl);
				rs = processor.transformToFragment(xml, document);
				callback.call(null, $("<div />").append(rs).html());
				return true;
			}
		}
		return false;
	};
	var xsl = {
		'nest' : '<' + '?xml version="1.0" encoding="utf-8" ?>' + 
			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' + 
			'<xsl:template match="/">' + 
			'	<xsl:call-template name="nodes">' + 
			'		<xsl:with-param name="node" select="/root" />' + 
			'	</xsl:call-template>' + 
			'</xsl:template>' + 
			'<xsl:template name="nodes">' + 
			'	<xsl:param name="node" />' + 
			'	<ul>' + 
			'	<xsl:for-each select="$node/item">' + 
			'		<xsl:variable name="children" select="count(./item) &gt; 0" />' + 
			'		<li>' + 
			'			<xsl:attribute name="class">' + 
			'				<xsl:if test="position() = last()">jstree-last </xsl:if>' + 
			'				<xsl:choose>' + 
			'					<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
			'					<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
			'					<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
			'				</xsl:choose>' + 
			'				<xsl:value-of select="@class" />' + 
			'			</xsl:attribute>' + 
			'			<xsl:for-each select="@*">' + 
			'				<xsl:if test="name() != \'class\' and name() != \'state\' and name() != \'hasChildren\'">' + 
			'					<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'				</xsl:if>' + 
			'			</xsl:for-each>' + 
			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
			'			<xsl:for-each select="content/name">' + 
			'				<a>' + 
			'				<xsl:attribute name="href">' + 
			'					<xsl:choose>' + 
			'					<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
			'					<xsl:otherwise>#</xsl:otherwise>' + 
			'					</xsl:choose>' + 
			'				</xsl:attribute>' + 
			'				<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
			'				<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
			'				<xsl:for-each select="@*">' + 
			'					<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
			'						<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'					</xsl:if>' + 
			'				</xsl:for-each>' + 
			'					<ins>' + 
			'						<xsl:attribute name="class">jstree-icon ' + 
			'							<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
			'						</xsl:attribute>' + 
			'						<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
			'						<xsl:text>&#xa0;</xsl:text>' + 
			'					</ins>' + 
			'					<xsl:copy-of select="./child::node()" />' + 
			'				</a>' + 
			'			</xsl:for-each>' + 
			'			<xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>' + 
			'		</li>' + 
			'	</xsl:for-each>' + 
			'	</ul>' + 
			'</xsl:template>' + 
			'</xsl:stylesheet>',

		'flat' : '<' + '?xml version="1.0" encoding="utf-8" ?>' + 
			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' + 
			'<xsl:template match="/">' + 
			'	<ul>' + 
			'	<xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
			'		<xsl:call-template name="nodes">' + 
			'			<xsl:with-param name="node" select="." />' + 
			'			<xsl:with-param name="is_last" select="number(position() = last())" />' + 
			'		</xsl:call-template>' + 
			'	</xsl:for-each>' + 
			'	</ul>' + 
			'</xsl:template>' + 
			'<xsl:template name="nodes">' + 
			'	<xsl:param name="node" />' + 
			'	<xsl:param name="is_last" />' + 
			'	<xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' + 
			'	<li>' + 
			'	<xsl:attribute name="class">' + 
			'		<xsl:if test="$is_last = true()">jstree-last </xsl:if>' + 
			'		<xsl:choose>' + 
			'			<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
			'			<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
			'			<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
			'		</xsl:choose>' + 
			'		<xsl:value-of select="@class" />' + 
			'	</xsl:attribute>' + 
			'	<xsl:for-each select="@*">' + 
			'		<xsl:if test="name() != \'parent_id\' and name() != \'hasChildren\' and name() != \'class\' and name() != \'state\'">' + 
			'		<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'		</xsl:if>' + 
			'	</xsl:for-each>' + 
			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
			'	<xsl:for-each select="content/name">' + 
			'		<a>' + 
			'		<xsl:attribute name="href">' + 
			'			<xsl:choose>' + 
			'			<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
			'			<xsl:otherwise>#</xsl:otherwise>' + 
			'			</xsl:choose>' + 
			'		</xsl:attribute>' + 
			'		<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
			'		<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
			'		<xsl:for-each select="@*">' + 
			'			<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
			'				<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'			</xsl:if>' + 
			'		</xsl:for-each>' + 
			'			<ins>' + 
			'				<xsl:attribute name="class">jstree-icon ' + 
			'					<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
			'				</xsl:attribute>' + 
			'				<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
			'				<xsl:text>&#xa0;</xsl:text>' + 
			'			</ins>' + 
			'			<xsl:copy-of select="./child::node()" />' + 
			'		</a>' + 
			'	</xsl:for-each>' + 
			'	<xsl:if test="$children">' + 
			'		<ul>' + 
			'		<xsl:for-each select="//item[@parent_id=$node/attribute::id]">' + 
			'			<xsl:call-template name="nodes">' + 
			'				<xsl:with-param name="node" select="." />' + 
			'				<xsl:with-param name="is_last" select="number(position() = last())" />' + 
			'			</xsl:call-template>' + 
			'		</xsl:for-each>' + 
			'		</ul>' + 
			'	</xsl:if>' + 
			'	</li>' + 
			'</xsl:template>' + 
			'</xsl:stylesheet>'
	},
	escape_xml = function(string) {
		return string
			.toString()
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&apos;');
	};
	$.jstree.plugin("xml_data", {
		defaults : { 
			data : false,
			ajax : false,
			xsl : "flat",
			clean_node : false,
			correct_state : true,
			get_skip_empty : false,
			get_include_preamble : true
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				var s = this._get_settings().xml_data;
				obj = this._get_node(obj);
				return obj == -1 || !obj || (!s.ajax && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
			},
			load_node_xml : function (obj, s_call, e_call) {
				var s = this.get_settings().xml_data,
					error_func = function () {},
					success_func = function () {};

				obj = this._get_node(obj);
				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							this.parse_xml(d, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
									else {
										if(obj && obj !== -1) { 
											obj.children("a.jstree-loading").removeClass("jstree-loading");
											obj.removeData("jstree_is_loading");
											if(s.correct_state) { 
												this.correct_state(obj);
												if(s_call) { s_call.call(this); } 
											}
										}
										else {
											if(s.correct_state) { 
												this.get_container().children("ul").empty();
												if(s_call) { s_call.call(this); } 
											}
										}
									}
								}
							}, this));
						}, this));
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							this.parse_xml(s.data, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										this.get_container().children("ul").empty().append(d.children());
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
								}
								else { 
									if(s.correct_state) { 
										this.get_container().children("ul").empty(); 
										if(s_call) { s_call.call(this); }
									}
								}
							}, this));
						}
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						error_func = function (x, t, e) {
							var ef = this.get_settings().xml_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj !== -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							d = x.responseText;
							var sf = this.get_settings().xml_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
								return error_func.call(this, x, t, "");
							}
							this.parse_xml(d, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
									else {
										if(obj && obj !== -1) { 
											obj.children("a.jstree-loading").removeClass("jstree-loading");
											obj.removeData("jstree_is_loading");
											if(s.correct_state) { 
												this.correct_state(obj);
												if(s_call) { s_call.call(this); } 
											}
										}
										else {
											if(s.correct_state) { 
												this.get_container().children("ul").empty();
												if(s_call) { s_call.call(this); } 
											}
										}
									}
								}
							}, this));
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			},
			parse_xml : function (xml, callback) {
				var s = this._get_settings().xml_data;
				$.vakata.xslt(xml, xsl[s.xsl], callback);
			},
			get_xml : function (tp, obj, li_attr, a_attr, is_callback) {
				var result = "", 
					s = this._get_settings(), 
					_this = this,
					tmp1, tmp2, li, a, lang;
				if(!tp) { tp = "flat"; }
				if(!is_callback) { is_callback = 0; }
				obj = this._get_node(obj);
				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
				if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }

				a_attr = $.isArray(a_attr) ? a_attr : [ ];

				if(!is_callback) { 
					if(s.xml_data.get_include_preamble) { 
						result += '<' + '?xml version="1.0" encoding="UTF-8"?' + '>'; 
					}
					result += "<root>"; 
				}
				obj.each(function () {
					result += "<item";
					li = $(this);
					$.each(li_attr, function (i, v) { 
						var t = li.attr(v);
						if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {
							result += " " + v + "=\"" + escape_xml((" " + (t || "")).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\""; 
						}
					});
					if(li.hasClass("jstree-open")) { result += " state=\"open\""; }
					if(li.hasClass("jstree-closed")) { result += " state=\"closed\""; }
					if(tp === "flat") { result += " parent_id=\"" + escape_xml(is_callback) + "\""; }
					result += ">";
					result += "<content>";
					a = li.children("a");
					a.each(function () {
						tmp1 = $(this);
						lang = false;
						result += "<name";
						if($.inArray("languages", s.plugins) !== -1) {
							$.each(s.languages, function (k, z) {
								if(tmp1.hasClass(z)) { result += " lang=\"" + escape_xml(z) + "\""; lang = z; return false; }
							});
						}
						if(a_attr.length) { 
							$.each(a_attr, function (k, z) {
								var t = tmp1.attr(z);
								if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {
									result += " " + z + "=\"" + escape_xml((" " + t || "").replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\"";
								}
							});
						}
						if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
							result += ' icon="' + escape_xml(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + '"';
						}
						if(tmp1.children("ins").get(0).style.backgroundImage.length) {
							result += ' icon="' + escape_xml(tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","").replace(/'/ig,"").replace(/"/ig,"")) + '"';
						}
						result += ">";
						result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";
						result += "</name>";
					});
					result += "</content>";
					tmp2 = li[0].id || true;
					li = li.find("> ul > li");
					if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }
					else { tmp2 = ""; }
					if(tp == "nest") { result += tmp2; }
					result += "</item>";
					if(tp == "flat") { result += tmp2; }
				});
				if(!is_callback) { result += "</root>"; }
				return result;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree search plugin
 * Enables both sync and async search on the tree
 * DOES NOT WORK WITH JSON PROGRESSIVE RENDER
 */
(function ($) {
	$.expr[':'].jstree_contains = function(a,i,m){
		return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
	$.expr[':'].jstree_title_contains = function(a,i,m) {
		return (a.getAttribute("title") || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
	$.jstree.plugin("search", {
		__init : function () {
			this.data.search.str = "";
			this.data.search.result = $();
			if(this._get_settings().search.show_only_matches) {
				this.get_container()
					.bind("search.jstree", function (e, data) {
						$(this).children("ul").find("li").hide().removeClass("jstree-last");
						data.rslt.nodes.parentsUntil(".jstree").andSelf().show()
							.filter("ul").each(function () { $(this).children("li:visible").eq(-1).addClass("jstree-last"); });
					})
					.bind("clear_search.jstree", function () {
						$(this).children("ul").find("li").css("display","").end().end().jstree("clean_node", -1);
					});
			}
		},
		defaults : {
			ajax : false,
			search_method : "jstree_contains", // for case insensitive - jstree_contains
			show_only_matches : false
		},
		_fn : {
			search : function (str, skip_async) {
				if($.trim(str) === "") { this.clear_search(); return; }
				var s = this.get_settings().search, 
					t = this,
					error_func = function () { },
					success_func = function () { };
				this.data.search.str = str;

				if(!skip_async && s.ajax !== false && this.get_container_ul().find("li.jstree-closed:not(:has(ul)):eq(0)").length > 0) {
					this.search.supress_callback = true;
					error_func = function () { };
					success_func = function (d, t, x) {
						var sf = this.get_settings().search.ajax.success; 
						if(sf) { d = sf.call(this,d,t,x) || d; }
						this.data.search.to_open = d;
						this._search_open();
					};
					s.ajax.context = this;
					s.ajax.error = error_func;
					s.ajax.success = success_func;
					if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }
					if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }
					if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }
					if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }
					$.ajax(s.ajax);
					return;
				}
				if(this.data.search.result.length) { this.clear_search(); }
				this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.search_method) + "(" + this.data.search.str + ")");
				this.data.search.result.addClass("jstree-search").parent().parents(".jstree-closed").each(function () {
					t.open_node(this, false, true);
				});
				this.__callback({ nodes : this.data.search.result, str : str });
			},
			clear_search : function (str) {
				this.data.search.result.removeClass("jstree-search");
				this.__callback(this.data.search.result);
				this.data.search.result = $();
			},
			_search_open : function (is_callback) {
				var _this = this,
					done = true,
					current = [],
					remaining = [];
				if(this.data.search.to_open.length) {
					$.each(this.data.search.to_open, function (i, val) {
						if(val == "#") { return true; }
						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
						else { remaining.push(val); }
					});
					if(current.length) {
						this.data.search.to_open = remaining;
						$.each(current, function (i, val) { 
							_this.open_node(val, function () { _this._search_open(true); }); 
						});
						done = false;
					}
				}
				if(done) { this.search(this.data.search.str, true); }
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree contextmenu plugin
 */
(function ($) {
	$.vakata.context = {
		hide_on_mouseleave : false,

		cnt		: $("<div id='vakata-contextmenu' />"),
		vis		: false,
		tgt		: false,
		par		: false,
		func	: false,
		data	: false,
		rtl		: false,
		show	: function (s, t, x, y, d, p, rtl) {
			$.vakata.context.rtl = !!rtl;
			var html = $.vakata.context.parse(s), h, w;
			if(!html) { return; }
			$.vakata.context.vis = true;
			$.vakata.context.tgt = t;
			$.vakata.context.par = p || t || null;
			$.vakata.context.data = d || null;
			$.vakata.context.cnt
				.html(html)
				.css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });

			if($.vakata.context.hide_on_mouseleave) {
				$.vakata.context.cnt
					.one("mouseleave", function(e) { $.vakata.context.hide(); });
			}

			h = $.vakata.context.cnt.height();
			w = $.vakata.context.cnt.width();
			if(x + w > $(document).width()) { 
				x = $(document).width() - (w + 5); 
				$.vakata.context.cnt.find("li > ul").addClass("right"); 
			}
			if(y + h > $(document).height()) { 
				y = y - (h + t[0].offsetHeight); 
				$.vakata.context.cnt.find("li > ul").addClass("bottom"); 
			}

			$.vakata.context.cnt
				.css({ "left" : x, "top" : y })
				.find("li:has(ul)")
					.bind("mouseenter", function (e) { 
						var w = $(document).width(),
							h = $(document).height(),
							ul = $(this).children("ul").show(); 
						if(w !== $(document).width()) { ul.toggleClass("right"); }
						if(h !== $(document).height()) { ul.toggleClass("bottom"); }
					})
					.bind("mouseleave", function (e) { 
						$(this).children("ul").hide(); 
					})
					.end()
				.css({ "visibility" : "visible" })
				.show();
			$(document).triggerHandler("context_show.vakata");
		},
		hide	: function () {
			$.vakata.context.vis = false;
			$.vakata.context.cnt.attr("class","").css({ "visibility" : "hidden" });
			$(document).triggerHandler("context_hide.vakata");
		},
		parse	: function (s, is_callback) {
			if(!s) { return false; }
			var str = "",
				tmp = false,
				was_sep = true;
			if(!is_callback) { $.vakata.context.func = {}; }
			str += "<ul>";
			$.each(s, function (i, val) {
				if(!val) { return true; }
				$.vakata.context.func[i] = val.action;
				if(!was_sep && val.separator_before) {
					str += "<li class='vakata-separator vakata-separator-before'></li>";
				}
				was_sep = false;
				str += "<li class='" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "'><ins ";
				if(val.icon && val.icon.indexOf("/") === -1) { str += " class='" + val.icon + "' "; }
				if(val.icon && val.icon.indexOf("/") !== -1) { str += " style='background:url(" + val.icon + ") center center no-repeat;' "; }
				str += ">&#160;</ins><a href='#' rel='" + i + "'>";
				if(val.submenu) {
					str += "<span style='float:" + ($.vakata.context.rtl ? "left" : "right") + ";'>&raquo;</span>";
				}
				str += val.label + "</a>";
				if(val.submenu) {
					tmp = $.vakata.context.parse(val.submenu, true);
					if(tmp) { str += tmp; }
				}
				str += "</li>";
				if(val.separator_after) {
					str += "<li class='vakata-separator vakata-separator-after'></li>";
					was_sep = true;
				}
			});
			str = str.replace(/<li class\='vakata-separator vakata-separator-after'\><\/li\>$/,"");
			str += "</ul>";
			$(document).triggerHandler("context_parse.vakata");
			return str.length > 10 ? str : false;
		},
		exec	: function (i) {
			if($.isFunction($.vakata.context.func[i])) {
				// if is string - eval and call it!
				$.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);
				return true;
			}
			else { return false; }
		}
	};
	$(function () {
		var css_string = '' + 
			'#vakata-contextmenu { display:block; visibility:hidden; left:0; top:-200px; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } ' + 
			'#vakata-contextmenu ul { min-width:180px; *width:180px; } ' + 
			'#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } ' + 
			'#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } ' + 
			'#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } ' + 
			'#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } ' + 
			'#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } ' + 
			'#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } ' + 
			'#vakata-contextmenu .right { right:100%; left:auto; } ' + 
			'#vakata-contextmenu .bottom { bottom:-1px; top:auto; } ' + 
			'#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });
		$.vakata.context.cnt
			.delegate("a","click", function (e) { e.preventDefault(); })
			.delegate("a","mouseup", function (e) {
				if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {
					$.vakata.context.hide();
				}
				else { $(this).blur(); }
			})
			.delegate("a","mouseover", function () {
				$.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");
			})
			.appendTo("body");
		$(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });
		if(typeof $.hotkeys !== "undefined") {
			$(document)
				.bind("keydown", "up", function (e) { 
					if($.vakata.context.vis) { 
						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();
						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }
						o.addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "down", function (e) { 
					if($.vakata.context.vis) { 
						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();
						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }
						o.addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "right", function (e) { 
					if($.vakata.context.vis) { 
						$.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "left", function (e) { 
					if($.vakata.context.vis) { 
						$.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "esc", function (e) { 
					$.vakata.context.hide(); 
					e.preventDefault();
				})
				.bind("keydown", "space", function (e) { 
					$.vakata.context.cnt.find(".vakata-hover").last().children("a").click();
					e.preventDefault();
				});
		}
	});

	$.jstree.plugin("contextmenu", {
		__init : function () {
			this.get_container()
				.delegate("a", "contextmenu.jstree", $.proxy(function (e) {
						e.preventDefault();
						if(!$(e.currentTarget).hasClass("jstree-loading")) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
						}
					}, this))
				.delegate("a", "click.jstree", $.proxy(function (e) {
						if(this.data.contextmenu) {
							$.vakata.context.hide();
						}
					}, this))
				.bind("destroy.jstree", $.proxy(function () {
						// TODO: move this to descruct method
						if(this.data.contextmenu) {
							$.vakata.context.hide();
						}
					}, this));
			$(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));
		},
		defaults : { 
			select_node : false, // requires UI plugin
			show_at_node : true,
			items : { // Could be a function that should return an object like this one
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"label"				: "Create",
					"action"			: function (obj) { this.create(obj); }
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"label"				: "Rename",
					"action"			: function (obj) { this.rename(obj); }
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Delete",
					"action"			: function (obj) { if(this.is_selected(obj)) { this.remove(); } else { this.remove(obj); } }
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : { 
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (obj) { this.cut(obj); }
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (obj) { this.copy(obj); }
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (obj) { this.paste(obj); }
						}
					}
				}
			}
		},
		_fn : {
			show_contextmenu : function (obj, x, y) {
				obj = this._get_node(obj);
				var s = this.get_settings().contextmenu,
					a = obj.children("a:visible:eq(0)"),
					o = false,
					i = false;
				if(s.select_node && this.data.ui && !this.is_selected(obj)) {
					this.deselect_all();
					this.select_node(obj, true);
				}
				if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
					o = a.offset();
					x = o.left;
					y = o.top + this.data.core.li_height;
				}
				i = obj.data("jstree") && obj.data("jstree").contextmenu ? obj.data("jstree").contextmenu : s.items;
				if($.isFunction(i)) { i = i.call(this, obj); }
				this.data.contextmenu = true;
				$.vakata.context.show(i, a, x, y, this, obj, this._get_settings().core.rtl);
				if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree types plugin
 * Adds support types of nodes
 * You can set an attribute on each li node, that represents its type.
 * According to the type setting the node may get custom icon/validation rules
 */
(function ($) {
	$.jstree.plugin("types", {
		__init : function () {
			var s = this._get_settings().types;
			this.data.types.attach_to = [];
			this.get_container()
				.bind("init.jstree", $.proxy(function () { 
						var types = s.types, 
							attr  = s.type_attr, 
							icons_css = "", 
							_this = this;

						$.each(types, function (i, tp) {
							$.each(tp, function (k, v) { 
								if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }
							});
							if(!tp.icon) { return true; }
							if( tp.icon.image || tp.icon.position) {
								if(i == "default")	{ icons_css += '.jstree-' + _this.get_index() + ' a > .jstree-icon { '; }
								else				{ icons_css += '.jstree-' + _this.get_index() + ' li[' + attr + '="' + i + '"] > a > .jstree-icon { '; }
								if(tp.icon.image)	{ icons_css += ' background-image:url(' + tp.icon.image + '); '; }
								if(tp.icon.position){ icons_css += ' background-position:' + tp.icon.position + '; '; }
								else				{ icons_css += ' background-position:0 0; '; }
								icons_css += '} ';
							}
						});
						if(icons_css !== "") { $.vakata.css.add_sheet({ 'str' : icons_css, title : "jstree-types" }); }
					}, this))
				.bind("before.jstree", $.proxy(function (e, data) { 
						var s, t, 
							o = this._get_settings().types.use_data ? this._get_node(data.args[0]) : false, 
							d = o && o !== -1 && o.length ? o.data("jstree") : false;
						if(d && d.types && d.types[data.func] === false) { e.stopImmediatePropagation(); return false; }
						if($.inArray(data.func, this.data.types.attach_to) !== -1) {
							if(!data.args[0] || (!data.args[0].tagName && !data.args[0].jquery)) { return; }
							s = this._get_settings().types.types;
							t = this._get_type(data.args[0]);
							if(
								( 
									(s[t] && typeof s[t][data.func] !== "undefined") || 
									(s["default"] && typeof s["default"][data.func] !== "undefined") 
								) && this._check(data.func, data.args[0]) === false
							) {
								e.stopImmediatePropagation();
								return false;
							}
						}
					}, this));
			if(is_ie6) {
				this.get_container()
					.bind("load_node.jstree set_type.jstree", $.proxy(function (e, data) {
							var r = data && data.rslt && data.rslt.obj && data.rslt.obj !== -1 ? this._get_node(data.rslt.obj).parent() : this.get_container_ul(),
								c = false,
								s = this._get_settings().types;
							$.each(s.types, function (i, tp) {
								if(tp.icon && (tp.icon.image || tp.icon.position)) {
									c = i === "default" ? r.find("li > a > .jstree-icon") : r.find("li[" + s.type_attr + "='" + i + "'] > a > .jstree-icon");
									if(tp.icon.image) { c.css("backgroundImage","url(" + tp.icon.image + ")"); }
									c.css("backgroundPosition", tp.icon.position || "0 0");
								}
							});
						}, this));
			}
		},
		defaults : {
			// defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)
			max_children		: -1,
			// defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)
			max_depth			: -1,
			// defines valid node types for the root nodes
			valid_children		: "all",

			// whether to use $.data
			use_data : false, 
			// where is the type stores (the rel attribute of the LI element)
			type_attr : "rel",
			// a list of types
			types : {
				// the default type
				"default" : {
					"max_children"	: -1,
					"max_depth"		: -1,
					"valid_children": "all"

					// Bound functions - you can bind any other function here (using boolean or function)
					//"select_node"	: true
				}
			}
		},
		_fn : {
			_types_notify : function (n, data) {
				if(data.type && this._get_settings().types.use_data) {
					this.set_type(data.type, n);
				}
			},
			_get_type : function (obj) {
				obj = this._get_node(obj);
				return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";
			},
			set_type : function (str, obj) {
				obj = this._get_node(obj);
				var ret = (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);
				if(ret) { this.__callback({ obj : obj, type : str}); }
				return ret;
			},
			_check : function (rule, obj, opts) {
				obj = this._get_node(obj);
				var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types, data = false;
				if(obj === -1) { 
					if(!!s[rule]) { v = s[rule]; }
					else { return; }
				}
				else {
					if(t === false) { return; }
					data = s.use_data ? obj.data("jstree") : false;
					if(data && data.types && typeof data.types[rule] !== "undefined") { v = data.types[rule]; }
					else if(!!s.types[t] && typeof s.types[t][rule] !== "undefined") { v = s.types[t][rule]; }
					else if(!!s.types["default"] && typeof s.types["default"][rule] !== "undefined") { v = s.types["default"][rule]; }
				}
				if($.isFunction(v)) { v = v.call(this, obj); }
				if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {
					// also include the node itself - otherwise if root node it is not checked
					obj.children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {
						// check if current depth already exceeds global tree depth
						if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }
						d = (i === 0) ? v : _this._check(rule, this, false);
						// check if current node max depth is already matched or exceeded
						if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }
						// otherwise - set the max depth to the current value minus current depth
						if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }
						// if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited
						if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }
					});
				}
				return v;
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var m  = this._get_move(),
					s  = m.rt._get_settings().types,
					mc = m.rt._check("max_children", m.cr),
					md = m.rt._check("max_depth", m.cr),
					vc = m.rt._check("valid_children", m.cr),
					ch = 0, d = 1, t;

				if(vc === "none") { return false; } 
				if($.isArray(vc) && m.ot && m.ot._get_type) {
					m.o.each(function () {
						if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }
					});
					if(d === false) { return false; }
				}
				if(s.max_children !== -2 && mc !== -1) {
					ch = m.cr === -1 ? this.get_container().find("> ul > li").not(m.o).length : m.cr.find("> ul > li").not(m.o).length;
					if(ch + m.o.length > mc) { return false; }
				}
				if(s.max_depth !== -2 && md !== -1) {
					d = 0;
					if(md === 0) { return false; }
					if(typeof m.o.d === "undefined") {
						// TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)
						t = m.o;
						while(t.length > 0) {
							t = t.find("> ul > li");
							d ++;
						}
						m.o.d = d;
					}
					if(md - m.o.d < 0) { return false; }
				}
				return true;
			},
			create_node : function (obj, position, js, callback, is_loaded, skip_check) {
				if(!skip_check && (is_loaded || this._is_loaded(obj))) {
					var p  = (typeof position == "string" && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),
						s  = this._get_settings().types,
						mc = this._check("max_children", p),
						md = this._check("max_depth", p),
						vc = this._check("valid_children", p),
						ch;
					if(typeof js === "string") { js = { data : js }; }
					if(!js) { js = {}; }
					if(vc === "none") { return false; } 
					if($.isArray(vc)) {
						if(!js.attr || !js.attr[s.type_attr]) { 
							if(!js.attr) { js.attr = {}; }
							js.attr[s.type_attr] = vc[0]; 
						}
						else {
							if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }
						}
					}
					if(s.max_children !== -2 && mc !== -1) {
						ch = p === -1 ? this.get_container().find("> ul > li").length : p.find("> ul > li").length;
						if(ch + 1 > mc) { return false; }
					}
					if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }
				}
				return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree HTML plugin
 * The HTML data store. Datastores are build by replacing the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.jstree.plugin("html_data", {
		__init : function () { 
			// this used to use html() and clean the whitespace, but this way any attached data was lost
			this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);
			// remove white space from LI node - otherwise nodes appear a bit to the right
			this.data.html_data.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType == 3; }).remove();
		},
		defaults : { 
			data : false,
			ajax : false,
			correct_state : true
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				obj = this._get_node(obj); 
				return obj == -1 || !obj || (!this._get_settings().html_data.ajax && !$.isFunction(this._get_settings().html_data.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
			},
			load_node_html : function (obj, s_call, e_call) {
				var d,
					s = this.get_settings().html_data,
					error_func = function () {},
					success_func = function () {};
				obj = this._get_node(obj);
				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							if(d && d !== "" && d.toString && d.toString().replace(/^[\s\n]+$/,"") !== "") {
								d = $(d);
								if(!d.is("ul")) { d = $("<ul />").append(d); }
								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj && obj !== -1) {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
								else {
									if(s.correct_state) { 
										this.get_container().children("ul").empty();
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						}, this));
						break;
					case (!s.data && !s.ajax):
						if(!obj || obj == -1) {
							this.get_container()
								.children("ul").empty()
								.append(this.data.html_data.original_container_html)
								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
							this.clean_node();
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							d = $(s.data);
							if(!d.is("ul")) { d = $("<ul />").append(d); }
							this.get_container()
								.children("ul").empty().append(d.children())
								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
							this.clean_node();
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						obj = this._get_node(obj);
						error_func = function (x, t, e) {
							var ef = this.get_settings().html_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj != -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							var sf = this.get_settings().html_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
								return error_func.call(this, x, t, "");
							}
							if(d) {
								d = $(d);
								if(!d.is("ul")) { d = $("<ul />").append(d); }
								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj && obj !== -1) {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
								else {
									if(s.correct_state) { 
										this.get_container().children("ul").empty();
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "html"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			}
		}
	});
	// include the HTML data plugin by default
	$.jstree.defaults.plugins.push("html_data");
})(jQuery);
//*/

/* 
 * jsTree themeroller plugin
 * Adds support for jQuery UI themes. Include this at the end of your plugins list, also make sure "themes" is not included.
 */
(function ($) {
	$.jstree.plugin("themeroller", {
		__init : function () {
			var s = this._get_settings().themeroller;
			this.get_container()
				.addClass("ui-widget-content")
				.addClass("jstree-themeroller")
				.delegate("a","mouseenter.jstree", function (e) {
					if(!$(e.currentTarget).hasClass("jstree-loading")) {
						$(this).addClass(s.item_h);
					}
				})
				.delegate("a","mouseleave.jstree", function () {
					$(this).removeClass(s.item_h);
				})
				.bind("init.jstree", $.proxy(function (e, data) { 
						data.inst.get_container().find("> ul > li > .jstree-loading > ins").addClass("ui-icon-refresh");
						this._themeroller(data.inst.get_container().find("> ul > li"));
					}, this))
				.bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { 
						this._themeroller(data.rslt.obj);
					}, this))
				.bind("loaded.jstree refresh.jstree", $.proxy(function (e) {
						this._themeroller();
					}, this))
				.bind("close_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.obj);
					}, this))
				.bind("delete_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.parent);
					}, this))
				.bind("correct_state.jstree", $.proxy(function (e, data) {
						data.rslt.obj
							.children("ins.jstree-icon").removeClass(s.opened + " " + s.closed + " ui-icon").end()
							.find("> a > ins.ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_open + " " + s.item_clsd).addClass(s.item_leaf || "jstree-no-icon");
					}, this))
				.bind("select_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.children("a").addClass(s.item_a);
					}, this))
				.bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {
						this.get_container()
							.find("a." + s.item_a).removeClass(s.item_a).end()
							.find("a.jstree-clicked").addClass(s.item_a);
					}, this))
				.bind("dehover_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.children("a").removeClass(s.item_h);
					}, this))
				.bind("hover_node.jstree", $.proxy(function (e, data) {
						this.get_container()
							.find("a." + s.item_h).not(data.rslt.obj).removeClass(s.item_h);
						data.rslt.obj.children("a").addClass(s.item_h);
					}, this))
				.bind("move_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.o);
						this._themeroller(data.rslt.op);
					}, this));
		},
		__destroy : function () {
			var s = this._get_settings().themeroller,
				c = [ "ui-icon" ];
			$.each(s, function (i, v) {
				v = v.split(" ");
				if(v.length) { c = c.concat(v); }
			});
			this.get_container()
				.removeClass("ui-widget-content")
				.find("." + c.join(", .")).removeClass(c.join(" "));
		},
		_fn : {
			_themeroller : function (obj) {
				var s = this._get_settings().themeroller;
				obj = !obj || obj == -1 ? this.get_container_ul() : this._get_node(obj).parent();
				obj
					.find("li.jstree-closed")
						.children("ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_leaf + " " + s.item_open).addClass(s.item_clsd || "jstree-no-icon")
								.end()
							.end()
						.end()
					.end()
					.find("li.jstree-open")
						.children("ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_leaf + " " + s.item_clsd).addClass(s.item_open || "jstree-no-icon")
								.end()
							.end()
						.end()
					.end()
					.find("li.jstree-leaf")
						.children("ins.jstree-icon").removeClass(s.closed + " ui-icon " + s.opened).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_clsd + " " + s.item_open).addClass(s.item_leaf || "jstree-no-icon");
			}
		},
		defaults : {
			"opened"	: "ui-icon-triangle-1-se",
			"closed"	: "ui-icon-triangle-1-e",
			"item"		: "ui-state-default",
			"item_h"	: "ui-state-hover",
			"item_a"	: "ui-state-active",
			"item_open"	: "ui-icon-folder-open",
			"item_clsd"	: "ui-icon-folder-collapsed",
			"item_leaf"	: "ui-icon-document"
		}
	});
	$(function() {
		var css_string = '' + 
			'.jstree-themeroller .ui-icon { overflow:visible; } ' + 
			'.jstree-themeroller a { padding:0 2px; } ' + 
			'.jstree-themeroller .jstree-no-icon { display:none; }';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/* 
 * jsTree unique plugin
 * Forces different names amongst siblings (still a bit experimental)
 * NOTE: does not check language versions (it will not be possible to have nodes with the same title, even in different languages)
 */
(function ($) {
	$.jstree.plugin("unique", {
		__init : function () {
			this.get_container()
				.bind("before.jstree", $.proxy(function (e, data) { 
						var nms = [], res = true, p, t;
						if(data.func == "move_node") {
							// obj, ref, position, is_copy, is_prepared, skip_check
							if(data.args[4] === true) {
								if(data.args[0].o && data.args[0].o.length) {
									data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
									res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o), "move_node");
								}
							}
						}
						if(data.func == "create_node") {
							// obj, position, js, callback, is_loaded
							if(data.args[4] || this._is_loaded(data.args[0])) {
								p = this._get_node(data.args[0]);
								if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {
									p = this._get_parent(data.args[0]);
									if(!p || p === -1) { p = this.get_container(); }
								}
								if(typeof data.args[2] === "string") { nms.push(data.args[2]); }
								else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_string("new_node")); }
								else { nms.push(data.args[2].data); }
								res = this._check_unique(nms, p.find("> ul > li"), "create_node");
							}
						}
						if(data.func == "rename_node") {
							// obj, val
							nms.push(data.args[1]);
							t = this._get_node(data.args[0]);
							p = this._get_parent(t);
							if(!p || p === -1) { p = this.get_container(); }
							res = this._check_unique(nms, p.find("> ul > li").not(t), "rename_node");
						}
						if(!res) {
							e.stopPropagation();
							return false;
						}
					}, this));
		},
		defaults : { 
			error_callback : $.noop
		},
		_fn : { 
			_check_unique : function (nms, p, func) {
				var cnms = [];
				p.children("a").each(function () { cnms.push($(this).text().replace(/^\s+/g,"")); });
				if(!cnms.length || !nms.length) { return true; }
				cnms = cnms.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");
				if((cnms.length + nms.length) != cnms.concat(nms).sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",").length) {
					this._get_settings().unique.error_callback.call(null, nms, p, func);
					return false;
				}
				return true;
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var p = this._get_move(), nms = [];
				if(p.o && p.o.length) {
					p.o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
					return this._check_unique(nms, p.np.find("> ul > li").not(p.o), "check_move");
				}
				return true;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree wholerow plugin
 * Makes select and hover work on the entire width of the node
 * MAY BE HEAVY IN LARGE DOM
 */
(function ($) {
	$.jstree.plugin("wholerow", {
		__init : function () {
			if(!this.data.ui) { throw "jsTree wholerow: jsTree UI plugin not included."; }
			this.data.wholerow.html = false;
			this.data.wholerow.to = false;
			this.get_container()
				.bind("init.jstree", $.proxy(function (e, data) { 
						this._get_settings().core.animation = 0;
					}, this))
				.bind("open_node.jstree create_node.jstree clean_node.jstree loaded.jstree", $.proxy(function (e, data) { 
						this._prepare_wholerow_span( data && data.rslt && data.rslt.obj ? data.rslt.obj : -1 );
					}, this))
				.bind("search.jstree clear_search.jstree reopen.jstree after_open.jstree after_close.jstree create_node.jstree delete_node.jstree clean_node.jstree", $.proxy(function (e, data) { 
						if(this.data.to) { clearTimeout(this.data.to); }
						this.data.to = setTimeout( (function (t, o) { return function() { t._prepare_wholerow_ul(o); }; })(this,  data && data.rslt && data.rslt.obj ? data.rslt.obj : -1), 0);
					}, this))
				.bind("deselect_all.jstree", $.proxy(function (e, data) { 
						this.get_container().find(" > .jstree-wholerow .jstree-clicked").removeClass("jstree-clicked " + (this.data.themeroller ? this._get_settings().themeroller.item_a : "" ));
					}, this))
				.bind("select_node.jstree deselect_node.jstree ", $.proxy(function (e, data) { 
						data.rslt.obj.each(function () { 
							var ref = data.inst.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt((($(this).offset().top - data.inst.get_container().offset().top + data.inst.get_container()[0].scrollTop) / data.inst.data.core.li_height),10)) + ")");
							// ref.children("a")[e.type === "select_node" ? "addClass" : "removeClass"]("jstree-clicked");
							ref.children("a").attr("class",data.rslt.obj.children("a").attr("class"));
						});
					}, this))
				.bind("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) { 
						this.get_container().find(" > .jstree-wholerow .jstree-hovered").removeClass("jstree-hovered " + (this.data.themeroller ? this._get_settings().themeroller.item_h : "" ));
						if(e.type === "hover_node") {
							var ref = this.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt(((data.rslt.obj.offset().top - this.get_container().offset().top + this.get_container()[0].scrollTop) / this.data.core.li_height),10)) + ")");
							// ref.children("a").addClass("jstree-hovered");
							ref.children("a").attr("class",data.rslt.obj.children(".jstree-hovered").attr("class"));
						}
					}, this))
				.delegate(".jstree-wholerow-span, ins.jstree-icon, li", "click.jstree", function (e) {
						var n = $(e.currentTarget);
						if(e.target.tagName === "A" || (e.target.tagName === "INS" && n.closest("li").is(".jstree-open, .jstree-closed"))) { return; }
						n.closest("li").children("a:visible:eq(0)").click();
						e.stopImmediatePropagation();
					})
				.delegate("li", "mouseover.jstree", $.proxy(function (e) {
						e.stopImmediatePropagation();
						if($(e.currentTarget).children(".jstree-hovered, .jstree-clicked").length) { return false; }
						this.hover_node(e.currentTarget);
						return false;
					}, this))
				.delegate("li", "mouseleave.jstree", $.proxy(function (e) {
						if($(e.currentTarget).children("a").hasClass("jstree-hovered").length) { return; }
						this.dehover_node(e.currentTarget);
					}, this));
			if(is_ie7 || is_ie6) {
				$.vakata.css.add_sheet({ str : ".jstree-" + this.get_index() + " { position:relative; } ", title : "jstree" });
			}
		},
		defaults : {
		},
		__destroy : function () {
			this.get_container().children(".jstree-wholerow").remove();
			this.get_container().find(".jstree-wholerow-span").remove();
		},
		_fn : {
			_prepare_wholerow_span : function (obj) {
				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);
				if(obj === false) { return; } // added for removing root nodes
				obj.each(function () {
					$(this).find("li").andSelf().each(function () {
						var $t = $(this);
						if($t.children(".jstree-wholerow-span").length) { return true; }
						$t.prepend("<span class='jstree-wholerow-span' style='width:" + ($t.parentsUntil(".jstree","li").length * 18) + "px;'>&#160;</span>");
					});
				});
			},
			_prepare_wholerow_ul : function () {
				var o = this.get_container().children("ul").eq(0), h = o.html();
				o.addClass("jstree-wholerow-real");
				if(this.data.wholerow.last_html !== h) {
					this.data.wholerow.last_html = h;
					this.get_container().children(".jstree-wholerow").remove();
					this.get_container().append(
						o.clone().removeClass("jstree-wholerow-real")
							.wrapAll("<div class='jstree-wholerow' />").parent()
							.width(o.parent()[0].scrollWidth)
							.css("top", (o.height() + ( is_ie7 ? 5 : 0)) * -1 )
							.find("li[id]").each(function () { this.removeAttribute("id"); }).end()
					);
				}
			}
		}
	});
	$(function() {
		var css_string = '' + 
			'.jstree .jstree-wholerow-real { position:relative; z-index:1; } ' + 
			'.jstree .jstree-wholerow-real li { cursor:pointer; } ' + 
			'.jstree .jstree-wholerow-real a { border-left-color:transparent !important; border-right-color:transparent !important; } ' + 
			'.jstree .jstree-wholerow { position:relative; z-index:0; height:0; } ' + 
			'.jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { width:100%; } ' + 
			'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li, .jstree .jstree-wholerow a { margin:0 !important; padding:0 !important; } ' + 
			'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { background:transparent !important; }' + 
			'.jstree .jstree-wholerow ins, .jstree .jstree-wholerow span, .jstree .jstree-wholerow input { display:none !important; }' + 
			'.jstree .jstree-wholerow a, .jstree .jstree-wholerow a:hover { text-indent:-9999px; !important; width:100%; padding:0 !important; border-right-width:0px !important; border-left-width:0px !important; } ' + 
			'.jstree .jstree-wholerow-span { position:absolute; left:0; margin:0px; padding:0; height:18px; border-width:0; padding:0; z-index:0; }';
		if(is_ff2) {
			css_string += '' + 
				'.jstree .jstree-wholerow a { display:block; height:18px; margin:0; padding:0; border:0; } ' + 
				'.jstree .jstree-wholerow-real a { border-color:transparent !important; } ';
		}
		if(is_ie7 || is_ie6) {
			css_string += '' + 
				'.jstree .jstree-wholerow, .jstree .jstree-wholerow li, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow a { margin:0; padding:0; line-height:18px; } ' + 
				'.jstree .jstree-wholerow a { display:block; height:18px; line-height:18px; overflow:hidden; } ';
		}
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/*
* jsTree model plugin
* This plugin gets jstree to use a class model to retrieve data, creating great dynamism
*/
(function ($) {
	var nodeInterface = ["getChildren","getChildrenCount","getAttr","getName","getProps"],
		validateInterface = function(obj, inter) {
			var valid = true;
			obj = obj || {};
			inter = [].concat(inter);
			$.each(inter, function (i, v) {
				if(!$.isFunction(obj[v])) { valid = false; return false; }
			});
			return valid;
		};
	$.jstree.plugin("model", {
		__init : function () {
			if(!this.data.json_data) { throw "jsTree model: jsTree json_data plugin not included."; }
			this._get_settings().json_data.data = function (n, b) {
				var obj = (n == -1) ? this._get_settings().model.object : n.data("jstree_model");
				if(!validateInterface(obj, nodeInterface)) { return b.call(null, false); }
				if(this._get_settings().model.async) {
					obj.getChildren($.proxy(function (data) {
						this.model_done(data, b);
					}, this));
				}
				else {
					this.model_done(obj.getChildren(), b);
				}
			};
		},
		defaults : {
			object : false,
			id_prefix : false,
			async : false
		},
		_fn : {
			model_done : function (data, callback) {
				var ret = [], 
					s = this._get_settings(),
					_this = this;

				if(!$.isArray(data)) { data = [data]; }
				$.each(data, function (i, nd) {
					var r = nd.getProps() || {};
					r.attr = nd.getAttr() || {};
					if(nd.getChildrenCount()) { r.state = "closed"; }
					r.data = nd.getName();
					if(!$.isArray(r.data)) { r.data = [r.data]; }
					if(_this.data.types && $.isFunction(nd.getType)) {
						r.attr[s.types.type_attr] = nd.getType();
					}
					if(r.attr.id && s.model.id_prefix) { r.attr.id = s.model.id_prefix + r.attr.id; }
					if(!r.metadata) { r.metadata = { }; }
					r.metadata.jstree_model = nd;
					ret.push(r);
				});
				callback.call(null, ret);
			}
		}
	});
})(jQuery);
//*/

})();
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
!function(){var n="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||this||{},r=n._,e=Array.prototype,o=Object.prototype,s="undefined"!=typeof Symbol?Symbol.prototype:null,u=e.push,c=e.slice,p=o.toString,i=o.hasOwnProperty,t=Array.isArray,a=Object.keys,l=Object.create,f=function(){},h=function(n){return n instanceof h?n:this instanceof h?void(this._wrapped=n):new h(n)};"undefined"==typeof exports||exports.nodeType?n._=h:("undefined"!=typeof module&&!module.nodeType&&module.exports&&(exports=module.exports=h),exports._=h),h.VERSION="1.9.1";var v,y=function(u,i,n){if(void 0===i)return u;switch(null==n?3:n){case 1:return function(n){return u.call(i,n)};case 3:return function(n,r,t){return u.call(i,n,r,t)};case 4:return function(n,r,t,e){return u.call(i,n,r,t,e)}}return function(){return u.apply(i,arguments)}},d=function(n,r,t){return h.iteratee!==v?h.iteratee(n,r):null==n?h.identity:h.isFunction(n)?y(n,r,t):h.isObject(n)&&!h.isArray(n)?h.matcher(n):h.property(n)};h.iteratee=v=function(n,r){return d(n,r,1/0)};var g=function(u,i){return i=null==i?u.length-1:+i,function(){for(var n=Math.max(arguments.length-i,0),r=Array(n),t=0;t<n;t++)r[t]=arguments[t+i];switch(i){case 0:return u.call(this,r);case 1:return u.call(this,arguments[0],r);case 2:return u.call(this,arguments[0],arguments[1],r)}var e=Array(i+1);for(t=0;t<i;t++)e[t]=arguments[t];return e[i]=r,u.apply(this,e)}},m=function(n){if(!h.isObject(n))return{};if(l)return l(n);f.prototype=n;var r=new f;return f.prototype=null,r},b=function(r){return function(n){return null==n?void 0:n[r]}},j=function(n,r){return null!=n&&i.call(n,r)},x=function(n,r){for(var t=r.length,e=0;e<t;e++){if(null==n)return;n=n[r[e]]}return t?n:void 0},_=Math.pow(2,53)-1,A=b("length"),w=function(n){var r=A(n);return"number"==typeof r&&0<=r&&r<=_};h.each=h.forEach=function(n,r,t){var e,u;if(r=y(r,t),w(n))for(e=0,u=n.length;e<u;e++)r(n[e],e,n);else{var i=h.keys(n);for(e=0,u=i.length;e<u;e++)r(n[i[e]],i[e],n)}return n},h.map=h.collect=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=Array(u),o=0;o<u;o++){var a=e?e[o]:o;i[o]=r(n[a],a,n)}return i};var O=function(c){return function(n,r,t,e){var u=3<=arguments.length;return function(n,r,t,e){var u=!w(n)&&h.keys(n),i=(u||n).length,o=0<c?0:i-1;for(e||(t=n[u?u[o]:o],o+=c);0<=o&&o<i;o+=c){var a=u?u[o]:o;t=r(t,n[a],a,n)}return t}(n,y(r,e,4),t,u)}};h.reduce=h.foldl=h.inject=O(1),h.reduceRight=h.foldr=O(-1),h.find=h.detect=function(n,r,t){var e=(w(n)?h.findIndex:h.findKey)(n,r,t);if(void 0!==e&&-1!==e)return n[e]},h.filter=h.select=function(n,e,r){var u=[];return e=d(e,r),h.each(n,function(n,r,t){e(n,r,t)&&u.push(n)}),u},h.reject=function(n,r,t){return h.filter(n,h.negate(d(r)),t)},h.every=h.all=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=0;i<u;i++){var o=e?e[i]:i;if(!r(n[o],o,n))return!1}return!0},h.some=h.any=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=0;i<u;i++){var o=e?e[i]:i;if(r(n[o],o,n))return!0}return!1},h.contains=h.includes=h.include=function(n,r,t,e){return w(n)||(n=h.values(n)),("number"!=typeof t||e)&&(t=0),0<=h.indexOf(n,r,t)},h.invoke=g(function(n,t,e){var u,i;return h.isFunction(t)?i=t:h.isArray(t)&&(u=t.slice(0,-1),t=t[t.length-1]),h.map(n,function(n){var r=i;if(!r){if(u&&u.length&&(n=x(n,u)),null==n)return;r=n[t]}return null==r?r:r.apply(n,e)})}),h.pluck=function(n,r){return h.map(n,h.property(r))},h.where=function(n,r){return h.filter(n,h.matcher(r))},h.findWhere=function(n,r){return h.find(n,h.matcher(r))},h.max=function(n,e,r){var t,u,i=-1/0,o=-1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,c=(n=w(n)?n:h.values(n)).length;a<c;a++)null!=(t=n[a])&&i<t&&(i=t);else e=d(e,r),h.each(n,function(n,r,t){u=e(n,r,t),(o<u||u===-1/0&&i===-1/0)&&(i=n,o=u)});return i},h.min=function(n,e,r){var t,u,i=1/0,o=1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,c=(n=w(n)?n:h.values(n)).length;a<c;a++)null!=(t=n[a])&&t<i&&(i=t);else e=d(e,r),h.each(n,function(n,r,t){((u=e(n,r,t))<o||u===1/0&&i===1/0)&&(i=n,o=u)});return i},h.shuffle=function(n){return h.sample(n,1/0)},h.sample=function(n,r,t){if(null==r||t)return w(n)||(n=h.values(n)),n[h.random(n.length-1)];var e=w(n)?h.clone(n):h.values(n),u=A(e);r=Math.max(Math.min(r,u),0);for(var i=u-1,o=0;o<r;o++){var a=h.random(o,i),c=e[o];e[o]=e[a],e[a]=c}return e.slice(0,r)},h.sortBy=function(n,e,r){var u=0;return e=d(e,r),h.pluck(h.map(n,function(n,r,t){return{value:n,index:u++,criteria:e(n,r,t)}}).sort(function(n,r){var t=n.criteria,e=r.criteria;if(t!==e){if(e<t||void 0===t)return 1;if(t<e||void 0===e)return-1}return n.index-r.index}),"value")};var k=function(o,r){return function(e,u,n){var i=r?[[],[]]:{};return u=d(u,n),h.each(e,function(n,r){var t=u(n,r,e);o(i,n,t)}),i}};h.groupBy=k(function(n,r,t){j(n,t)?n[t].push(r):n[t]=[r]}),h.indexBy=k(function(n,r,t){n[t]=r}),h.countBy=k(function(n,r,t){j(n,t)?n[t]++:n[t]=1});var S=/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;h.toArray=function(n){return n?h.isArray(n)?c.call(n):h.isString(n)?n.match(S):w(n)?h.map(n,h.identity):h.values(n):[]},h.size=function(n){return null==n?0:w(n)?n.length:h.keys(n).length},h.partition=k(function(n,r,t){n[t?0:1].push(r)},!0),h.first=h.head=h.take=function(n,r,t){return null==n||n.length<1?null==r?void 0:[]:null==r||t?n[0]:h.initial(n,n.length-r)},h.initial=function(n,r,t){return c.call(n,0,Math.max(0,n.length-(null==r||t?1:r)))},h.last=function(n,r,t){return null==n||n.length<1?null==r?void 0:[]:null==r||t?n[n.length-1]:h.rest(n,Math.max(0,n.length-r))},h.rest=h.tail=h.drop=function(n,r,t){return c.call(n,null==r||t?1:r)},h.compact=function(n){return h.filter(n,Boolean)};var M=function(n,r,t,e){for(var u=(e=e||[]).length,i=0,o=A(n);i<o;i++){var a=n[i];if(w(a)&&(h.isArray(a)||h.isArguments(a)))if(r)for(var c=0,l=a.length;c<l;)e[u++]=a[c++];else M(a,r,t,e),u=e.length;else t||(e[u++]=a)}return e};h.flatten=function(n,r){return M(n,r,!1)},h.without=g(function(n,r){return h.difference(n,r)}),h.uniq=h.unique=function(n,r,t,e){h.isBoolean(r)||(e=t,t=r,r=!1),null!=t&&(t=d(t,e));for(var u=[],i=[],o=0,a=A(n);o<a;o++){var c=n[o],l=t?t(c,o,n):c;r&&!t?(o&&i===l||u.push(c),i=l):t?h.contains(i,l)||(i.push(l),u.push(c)):h.contains(u,c)||u.push(c)}return u},h.union=g(function(n){return h.uniq(M(n,!0,!0))}),h.intersection=function(n){for(var r=[],t=arguments.length,e=0,u=A(n);e<u;e++){var i=n[e];if(!h.contains(r,i)){var o;for(o=1;o<t&&h.contains(arguments[o],i);o++);o===t&&r.push(i)}}return r},h.difference=g(function(n,r){return r=M(r,!0,!0),h.filter(n,function(n){return!h.contains(r,n)})}),h.unzip=function(n){for(var r=n&&h.max(n,A).length||0,t=Array(r),e=0;e<r;e++)t[e]=h.pluck(n,e);return t},h.zip=g(h.unzip),h.object=function(n,r){for(var t={},e=0,u=A(n);e<u;e++)r?t[n[e]]=r[e]:t[n[e][0]]=n[e][1];return t};var F=function(i){return function(n,r,t){r=d(r,t);for(var e=A(n),u=0<i?0:e-1;0<=u&&u<e;u+=i)if(r(n[u],u,n))return u;return-1}};h.findIndex=F(1),h.findLastIndex=F(-1),h.sortedIndex=function(n,r,t,e){for(var u=(t=d(t,e,1))(r),i=0,o=A(n);i<o;){var a=Math.floor((i+o)/2);t(n[a])<u?i=a+1:o=a}return i};var E=function(i,o,a){return function(n,r,t){var e=0,u=A(n);if("number"==typeof t)0<i?e=0<=t?t:Math.max(t+u,e):u=0<=t?Math.min(t+1,u):t+u+1;else if(a&&t&&u)return n[t=a(n,r)]===r?t:-1;if(r!=r)return 0<=(t=o(c.call(n,e,u),h.isNaN))?t+e:-1;for(t=0<i?e:u-1;0<=t&&t<u;t+=i)if(n[t]===r)return t;return-1}};h.indexOf=E(1,h.findIndex,h.sortedIndex),h.lastIndexOf=E(-1,h.findLastIndex),h.range=function(n,r,t){null==r&&(r=n||0,n=0),t||(t=r<n?-1:1);for(var e=Math.max(Math.ceil((r-n)/t),0),u=Array(e),i=0;i<e;i++,n+=t)u[i]=n;return u},h.chunk=function(n,r){if(null==r||r<1)return[];for(var t=[],e=0,u=n.length;e<u;)t.push(c.call(n,e,e+=r));return t};var N=function(n,r,t,e,u){if(!(e instanceof r))return n.apply(t,u);var i=m(n.prototype),o=n.apply(i,u);return h.isObject(o)?o:i};h.bind=g(function(r,t,e){if(!h.isFunction(r))throw new TypeError("Bind must be called on a function");var u=g(function(n){return N(r,u,t,this,e.concat(n))});return u}),h.partial=g(function(u,i){var o=h.partial.placeholder,a=function(){for(var n=0,r=i.length,t=Array(r),e=0;e<r;e++)t[e]=i[e]===o?arguments[n++]:i[e];for(;n<arguments.length;)t.push(arguments[n++]);return N(u,a,this,this,t)};return a}),(h.partial.placeholder=h).bindAll=g(function(n,r){var t=(r=M(r,!1,!1)).length;if(t<1)throw new Error("bindAll must be passed function names");for(;t--;){var e=r[t];n[e]=h.bind(n[e],n)}}),h.memoize=function(e,u){var i=function(n){var r=i.cache,t=""+(u?u.apply(this,arguments):n);return j(r,t)||(r[t]=e.apply(this,arguments)),r[t]};return i.cache={},i},h.delay=g(function(n,r,t){return setTimeout(function(){return n.apply(null,t)},r)}),h.defer=h.partial(h.delay,h,1),h.throttle=function(t,e,u){var i,o,a,c,l=0;u||(u={});var f=function(){l=!1===u.leading?0:h.now(),i=null,c=t.apply(o,a),i||(o=a=null)},n=function(){var n=h.now();l||!1!==u.leading||(l=n);var r=e-(n-l);return o=this,a=arguments,r<=0||e<r?(i&&(clearTimeout(i),i=null),l=n,c=t.apply(o,a),i||(o=a=null)):i||!1===u.trailing||(i=setTimeout(f,r)),c};return n.cancel=function(){clearTimeout(i),l=0,i=o=a=null},n},h.debounce=function(t,e,u){var i,o,a=function(n,r){i=null,r&&(o=t.apply(n,r))},n=g(function(n){if(i&&clearTimeout(i),u){var r=!i;i=setTimeout(a,e),r&&(o=t.apply(this,n))}else i=h.delay(a,e,this,n);return o});return n.cancel=function(){clearTimeout(i),i=null},n},h.wrap=function(n,r){return h.partial(r,n)},h.negate=function(n){return function(){return!n.apply(this,arguments)}},h.compose=function(){var t=arguments,e=t.length-1;return function(){for(var n=e,r=t[e].apply(this,arguments);n--;)r=t[n].call(this,r);return r}},h.after=function(n,r){return function(){if(--n<1)return r.apply(this,arguments)}},h.before=function(n,r){var t;return function(){return 0<--n&&(t=r.apply(this,arguments)),n<=1&&(r=null),t}},h.once=h.partial(h.before,2),h.restArguments=g;var I=!{toString:null}.propertyIsEnumerable("toString"),T=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],B=function(n,r){var t=T.length,e=n.constructor,u=h.isFunction(e)&&e.prototype||o,i="constructor";for(j(n,i)&&!h.contains(r,i)&&r.push(i);t--;)(i=T[t])in n&&n[i]!==u[i]&&!h.contains(r,i)&&r.push(i)};h.keys=function(n){if(!h.isObject(n))return[];if(a)return a(n);var r=[];for(var t in n)j(n,t)&&r.push(t);return I&&B(n,r),r},h.allKeys=function(n){if(!h.isObject(n))return[];var r=[];for(var t in n)r.push(t);return I&&B(n,r),r},h.values=function(n){for(var r=h.keys(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=n[r[u]];return e},h.mapObject=function(n,r,t){r=d(r,t);for(var e=h.keys(n),u=e.length,i={},o=0;o<u;o++){var a=e[o];i[a]=r(n[a],a,n)}return i},h.pairs=function(n){for(var r=h.keys(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=[r[u],n[r[u]]];return e},h.invert=function(n){for(var r={},t=h.keys(n),e=0,u=t.length;e<u;e++)r[n[t[e]]]=t[e];return r},h.functions=h.methods=function(n){var r=[];for(var t in n)h.isFunction(n[t])&&r.push(t);return r.sort()};var R=function(c,l){return function(n){var r=arguments.length;if(l&&(n=Object(n)),r<2||null==n)return n;for(var t=1;t<r;t++)for(var e=arguments[t],u=c(e),i=u.length,o=0;o<i;o++){var a=u[o];l&&void 0!==n[a]||(n[a]=e[a])}return n}};h.extend=R(h.allKeys),h.extendOwn=h.assign=R(h.keys),h.findKey=function(n,r,t){r=d(r,t);for(var e,u=h.keys(n),i=0,o=u.length;i<o;i++)if(r(n[e=u[i]],e,n))return e};var q,K,z=function(n,r,t){return r in t};h.pick=g(function(n,r){var t={},e=r[0];if(null==n)return t;h.isFunction(e)?(1<r.length&&(e=y(e,r[1])),r=h.allKeys(n)):(e=z,r=M(r,!1,!1),n=Object(n));for(var u=0,i=r.length;u<i;u++){var o=r[u],a=n[o];e(a,o,n)&&(t[o]=a)}return t}),h.omit=g(function(n,t){var r,e=t[0];return h.isFunction(e)?(e=h.negate(e),1<t.length&&(r=t[1])):(t=h.map(M(t,!1,!1),String),e=function(n,r){return!h.contains(t,r)}),h.pick(n,e,r)}),h.defaults=R(h.allKeys,!0),h.create=function(n,r){var t=m(n);return r&&h.extendOwn(t,r),t},h.clone=function(n){return h.isObject(n)?h.isArray(n)?n.slice():h.extend({},n):n},h.tap=function(n,r){return r(n),n},h.isMatch=function(n,r){var t=h.keys(r),e=t.length;if(null==n)return!e;for(var u=Object(n),i=0;i<e;i++){var o=t[i];if(r[o]!==u[o]||!(o in u))return!1}return!0},q=function(n,r,t,e){if(n===r)return 0!==n||1/n==1/r;if(null==n||null==r)return!1;if(n!=n)return r!=r;var u=typeof n;return("function"===u||"object"===u||"object"==typeof r)&&K(n,r,t,e)},K=function(n,r,t,e){n instanceof h&&(n=n._wrapped),r instanceof h&&(r=r._wrapped);var u=p.call(n);if(u!==p.call(r))return!1;switch(u){case"[object RegExp]":case"[object String]":return""+n==""+r;case"[object Number]":return+n!=+n?+r!=+r:0==+n?1/+n==1/r:+n==+r;case"[object Date]":case"[object Boolean]":return+n==+r;case"[object Symbol]":return s.valueOf.call(n)===s.valueOf.call(r)}var i="[object Array]"===u;if(!i){if("object"!=typeof n||"object"!=typeof r)return!1;var o=n.constructor,a=r.constructor;if(o!==a&&!(h.isFunction(o)&&o instanceof o&&h.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in r)return!1}e=e||[];for(var c=(t=t||[]).length;c--;)if(t[c]===n)return e[c]===r;if(t.push(n),e.push(r),i){if((c=n.length)!==r.length)return!1;for(;c--;)if(!q(n[c],r[c],t,e))return!1}else{var l,f=h.keys(n);if(c=f.length,h.keys(r).length!==c)return!1;for(;c--;)if(l=f[c],!j(r,l)||!q(n[l],r[l],t,e))return!1}return t.pop(),e.pop(),!0},h.isEqual=function(n,r){return q(n,r)},h.isEmpty=function(n){return null==n||(w(n)&&(h.isArray(n)||h.isString(n)||h.isArguments(n))?0===n.length:0===h.keys(n).length)},h.isElement=function(n){return!(!n||1!==n.nodeType)},h.isArray=t||function(n){return"[object Array]"===p.call(n)},h.isObject=function(n){var r=typeof n;return"function"===r||"object"===r&&!!n},h.each(["Arguments","Function","String","Number","Date","RegExp","Error","Symbol","Map","WeakMap","Set","WeakSet"],function(r){h["is"+r]=function(n){return p.call(n)==="[object "+r+"]"}}),h.isArguments(arguments)||(h.isArguments=function(n){return j(n,"callee")});var D=n.document&&n.document.childNodes;"function"!=typeof/./&&"object"!=typeof Int8Array&&"function"!=typeof D&&(h.isFunction=function(n){return"function"==typeof n||!1}),h.isFinite=function(n){return!h.isSymbol(n)&&isFinite(n)&&!isNaN(parseFloat(n))},h.isNaN=function(n){return h.isNumber(n)&&isNaN(n)},h.isBoolean=function(n){return!0===n||!1===n||"[object Boolean]"===p.call(n)},h.isNull=function(n){return null===n},h.isUndefined=function(n){return void 0===n},h.has=function(n,r){if(!h.isArray(r))return j(n,r);for(var t=r.length,e=0;e<t;e++){var u=r[e];if(null==n||!i.call(n,u))return!1;n=n[u]}return!!t},h.noConflict=function(){return n._=r,this},h.identity=function(n){return n},h.constant=function(n){return function(){return n}},h.noop=function(){},h.property=function(r){return h.isArray(r)?function(n){return x(n,r)}:b(r)},h.propertyOf=function(r){return null==r?function(){}:function(n){return h.isArray(n)?x(r,n):r[n]}},h.matcher=h.matches=function(r){return r=h.extendOwn({},r),function(n){return h.isMatch(n,r)}},h.times=function(n,r,t){var e=Array(Math.max(0,n));r=y(r,t,1);for(var u=0;u<n;u++)e[u]=r(u);return e},h.random=function(n,r){return null==r&&(r=n,n=0),n+Math.floor(Math.random()*(r-n+1))},h.now=Date.now||function(){return(new Date).getTime()};var L={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},P=h.invert(L),W=function(r){var t=function(n){return r[n]},n="(?:"+h.keys(r).join("|")+")",e=RegExp(n),u=RegExp(n,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};h.escape=W(L),h.unescape=W(P),h.result=function(n,r,t){h.isArray(r)||(r=[r]);var e=r.length;if(!e)return h.isFunction(t)?t.call(n):t;for(var u=0;u<e;u++){var i=null==n?void 0:n[r[u]];void 0===i&&(i=t,u=e),n=h.isFunction(i)?i.call(n):i}return n};var C=0;h.uniqueId=function(n){var r=++C+"";return n?n+r:r},h.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var J=/(.)^/,U={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},V=/\\|'|\r|\n|\u2028|\u2029/g,$=function(n){return"\\"+U[n]};h.template=function(i,n,r){!n&&r&&(n=r),n=h.defaults({},n,h.templateSettings);var t,e=RegExp([(n.escape||J).source,(n.interpolate||J).source,(n.evaluate||J).source].join("|")+"|$","g"),o=0,a="__p+='";i.replace(e,function(n,r,t,e,u){return a+=i.slice(o,u).replace(V,$),o=u+n.length,r?a+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'":t?a+="'+\n((__t=("+t+"))==null?'':__t)+\n'":e&&(a+="';\n"+e+"\n__p+='"),n}),a+="';\n",n.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{t=new Function(n.variable||"obj","_",a)}catch(n){throw n.source=a,n}var u=function(n){return t.call(this,n,h)},c=n.variable||"obj";return u.source="function("+c+"){\n"+a+"}",u},h.chain=function(n){var r=h(n);return r._chain=!0,r};var G=function(n,r){return n._chain?h(r).chain():r};h.mixin=function(t){return h.each(h.functions(t),function(n){var r=h[n]=t[n];h.prototype[n]=function(){var n=[this._wrapped];return u.apply(n,arguments),G(this,r.apply(h,n))}}),h},h.mixin(h),h.each(["pop","push","reverse","shift","sort","splice","unshift"],function(r){var t=e[r];h.prototype[r]=function(){var n=this._wrapped;return t.apply(n,arguments),"shift"!==r&&"splice"!==r||0!==n.length||delete n[0],G(this,n)}}),h.each(["concat","join","slice"],function(n){var r=e[n];h.prototype[n]=function(){return G(this,r.apply(this._wrapped,arguments))}}),h.prototype.value=function(){return this._wrapped},h.prototype.valueOf=h.prototype.toJSON=h.prototype.value,h.prototype.toString=function(){return String(this._wrapped)},"function"==typeof define&&define.amd&&define("underscore",[],function(){return h})}();
//     Backbone.js 1.3.3

//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function (factory) {

    // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
    // We use `self` instead of `window` for `WebWorker` support.
    var root = (typeof self == 'object' && self.self === self && self) ||
              (typeof global == 'object' && global.global === global && global);

    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));

    //// Set up Backbone appropriately for the environment. Start with AMD.
    //if (typeof define === 'function' && define.amd) {
    //    define(['underscore', 'jquery', 'exports'], function (_, $, exports) {
    //        // Export global even in AMD case in case this script is loaded with
    //        // others that may still expect a global Backbone.
    //        root.Backbone = factory(root, exports, _, $);
    //    });

    //    // Next for Node.js or CommonJS. jQuery may not be needed as a module.
    //} else if (typeof exports !== 'undefined') {
    //    var _ = require('underscore'), $;
    //    try { $ = require('jquery'); } catch (e) { }
    //    factory(root, exports, _, $);

    //    // Finally, as a browser global.
    //} else {
    //    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
    //}

})(function (root, Backbone, _, $) {

    // Initial Setup
    // -------------

    // Save the previous value of the `Backbone` variable, so that it can be
    // restored later on, if `noConflict` is used.
    var previousBackbone = root.Backbone;

    // Create a local reference to a common array method we'll want to use later.
    var slice = Array.prototype.slice;

    // Current version of the library. Keep in sync with `package.json`.
    Backbone.VERSION = '1.3.3';

    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
    // the `$` variable.
    Backbone.$ = $;

    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
    // to its previous owner. Returns a reference to this Backbone object.
    Backbone.noConflict = function () {
        root.Backbone = previousBackbone;
        return this;
    };

    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
    // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
    // set a `X-Http-Method-Override` header.
    Backbone.emulateHTTP = false;

    // Turn on `emulateJSON` to support legacy servers that can't deal with direct
    // `application/json` requests ... this will encode the body as
    // `application/x-www-form-urlencoded` instead and will send the model in a
    // form param named `model`.
    Backbone.emulateJSON = false;

    // Proxy Backbone class methods to Underscore functions, wrapping the model's
    // `attributes` object or collection's `models` array behind the scenes.
    //
    // collection.filter(function(model) { return model.get('age') > 10 });
    // collection.each(this.addView);
    //
    // `Function#apply` can be slow so we use the method's arg count, if we know it.
    var addMethod = function (length, method, attribute) {
        switch (length) {
            case 1: return function () {
                return _[method](this[attribute]);
            };
            case 2: return function (value) {
                return _[method](this[attribute], value);
            };
            case 3: return function (iteratee, context) {
                return _[method](this[attribute], cb(iteratee, this), context);
            };
            case 4: return function (iteratee, defaultVal, context) {
                return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
            };
            default: return function () {
                var args = slice.call(arguments);
                args.unshift(this[attribute]);
                return _[method].apply(_, args);
            };
        }
    };
    var addUnderscoreMethods = function (Class, methods, attribute) {
        _.each(methods, function (length, method) {
            if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
        });
    };

    // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
    var cb = function (iteratee, instance) {
        if (_.isFunction(iteratee)) return iteratee;
        if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
        if (_.isString(iteratee)) return function (model) { return model.get(iteratee); };
        return iteratee;
    };
    var modelMatcher = function (attrs) {
        var matcher = _.matches(attrs);
        return function (model) {
            return matcher(model.attributes);
        };
    };

    // Backbone.Events
    // ---------------

    // A module that can be mixed in to *any object* in order to provide it with
    // a custom event channel. You may bind a callback to an event with `on` or
    // remove with `off`; `trigger`-ing an event fires all callbacks in
    // succession.
    //
    //     var object = {};
    //     _.extend(object, Backbone.Events);
    //     object.on('expand', function(){ alert('expanded'); });
    //     object.trigger('expand');
    //
    var Events = Backbone.Events = {};

    // Regular expression used to split event strings.
    var eventSplitter = /\s+/;

    // Iterates over the standard `event, callback` (as well as the fancy multiple
    // space-separated events `"change blur", callback` and jQuery-style event
    // maps `{event: callback}`).
    var eventsApi = function (iteratee, events, name, callback, opts) {
        var i = 0, names;
        if (name && typeof name === 'object') {
            // Handle event maps.
            if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
            for (names = _.keys(name) ; i < names.length ; i++) {
                events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
            }
        } else if (name && eventSplitter.test(name)) {
            // Handle space-separated event names by delegating them individually.
            for (names = name.split(eventSplitter) ; i < names.length; i++) {
                events = iteratee(events, names[i], callback, opts);
            }
        } else {
            // Finally, standard events.
            events = iteratee(events, name, callback, opts);
        }
        return events;
    };

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    Events.on = function (name, callback, context) {
        return internalOn(this, name, callback, context);
    };

    // Guard the `listening` argument from the public API.
    var internalOn = function (obj, name, callback, context, listening) {
        obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
            context: context,
            ctx: obj,
            listening: listening
        });

        if (listening) {
            var listeners = obj._listeners || (obj._listeners = {});
            listeners[listening.id] = listening;
        }

        return obj;
    };

    // Inversion-of-control versions of `on`. Tell *this* object to listen to
    // an event in another object... keeping track of what it's listening to
    // for easier unbinding later.
    Events.listenTo = function (obj, name, callback) {
        if (!obj) return this;
        var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = listeningTo[id];

        // This object is not listening to any other events on `obj` yet.
        // Setup the necessary references to track the listening callbacks.
        if (!listening) {
            var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
            listening = listeningTo[id] = { obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0 };
        }

        // Bind callbacks on obj, and keep track of them on listening.
        internalOn(obj, name, callback, this, listening);
        return this;
    };

    // The reducing API that adds a callback to the `events` object.
    var onApi = function (events, name, callback, options) {
        if (callback) {
            var handlers = events[name] || (events[name] = []);
            var context = options.context, ctx = options.ctx, listening = options.listening;
            if (listening) listening.count++;

            handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
        }
        return events;
    };

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    Events.off = function (name, callback, context) {
        if (!this._events) return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
            context: context,
            listeners: this._listeners
        });
        return this;
    };

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    Events.stopListening = function (obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;

        var ids = obj ? [obj._listenId] : _.keys(listeningTo);

        for (var i = 0; i < ids.length; i++) {
            var listening = listeningTo[ids[i]];

            // If listening doesn't exist, this object is not currently
            // listening to obj. Break out early.
            if (!listening) break;

            listening.obj.off(name, callback, this);
        }

        return this;
    };

    // The reducing API that removes a callback from the `events` object.
    var offApi = function (events, name, callback, options) {
        if (!events) return;

        var i = 0, listening;
        var context = options.context, listeners = options.listeners;

        // Delete all events listeners and "drop" events.
        if (!name && !callback && !context) {
            var ids = _.keys(listeners);
            for (; i < ids.length; i++) {
                listening = listeners[ids[i]];
                delete listeners[listening.id];
                delete listening.listeningTo[listening.objId];
            }
            return;
        }

        var names = name ? [name] : _.keys(events);
        for (; i < names.length; i++) {
            name = names[i];
            var handlers = events[name];

            // Bail out if there are no events stored.
            if (!handlers) break;

            // Replace events if there are any remaining.  Otherwise, clean up.
            var remaining = [];
            for (var j = 0; j < handlers.length; j++) {
                var handler = handlers[j];
                if (
                  callback && callback !== handler.callback &&
                    callback !== handler.callback._callback ||
                      context && context !== handler.context
                ) {
                    remaining.push(handler);
                } else {
                    listening = handler.listening;
                    if (listening && --listening.count === 0) {
                        delete listeners[listening.id];
                        delete listening.listeningTo[listening.objId];
                    }
                }
            }

            // Update tail event if the list has any events.  Otherwise, clean up.
            if (remaining.length) {
                events[name] = remaining;
            } else {
                delete events[name];
            }
        }
        return events;
    };

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, its listener will be removed. If multiple events
    // are passed in using the space-separated syntax, the handler will fire
    // once for each event, not once for a combination of all events.
    Events.once = function (name, callback, context) {
        // Map the event into a `{event: once}` object.
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
        if (typeof name === 'string' && context == null) callback = void 0;
        return this.on(events, callback, context);
    };

    // Inversion-of-control versions of `once`.
    Events.listenToOnce = function (obj, name, callback) {
        // Map the event into a `{event: once}` object.
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
        return this.listenTo(obj, events);
    };

    // Reduces the event callbacks into a map of `{event: onceWrapper}`.
    // `offer` unbinds the `onceWrapper` after it has been called.
    var onceMap = function (map, name, callback, offer) {
        if (callback) {
            var once = map[name] = _.once(function () {
                offer(name, once);
                callback.apply(this, arguments);
            });
            once._callback = callback;
        }
        return map;
    };

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    Events.trigger = function (name) {
        if (!this._events) return this;

        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
    };

    // Handles triggering the appropriate event callbacks.
    var triggerApi = function (objEvents, name, callback, args) {
        if (objEvents) {
            var events = objEvents[name];
            var allEvents = objEvents.all;
            if (events && allEvents) allEvents = allEvents.slice();
            if (events) triggerEvents(events, args);
            if (allEvents) triggerEvents(allEvents, [name].concat(args));
        }
        return objEvents;
    };

    // A difficult-to-believe, but optimized internal dispatch function for
    // triggering events. Tries to keep the usual cases speedy (most internal
    // Backbone events have 3 arguments).
    var triggerEvents = function (events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
            case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
            case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
            case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
            case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
            default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
        }
    };

    // Aliases for backwards compatibility.
    Events.bind = Events.on;
    Events.unbind = Events.off;

    // Allow the `Backbone` object to serve as a global event bus, for folks who
    // want global "pubsub" in a convenient place.
    _.extend(Backbone, Events);

    // Backbone.Model
    // --------------

    // Backbone **Models** are the basic data object in the framework --
    // frequently representing a row in a table in a database on your server.
    // A discrete chunk of data and a bunch of useful, related methods for
    // performing computations and transformations on that data.

    // Create a new model with the specified attributes. A client id (`cid`)
    // is automatically generated and assigned for you.
    var Model = Backbone.Model = function (attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection) this.collection = options.collection;
        if (options.parse) attrs = this.parse(attrs, options) || {};
        var defaults = _.result(this, 'defaults');
        attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    };

    // Attach all inheritable methods to the Model prototype.
    _.extend(Model.prototype, Events, {

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: 'c',

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function () { },

        // Return a copy of the model's `attributes` object.
        toJSON: function (options) {
            return _.clone(this.attributes);
        },

        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function () {
            return Backbone.sync.apply(this, arguments);
        },

        // Get the value of an attribute.
        get: function (attr) {
            return this.attributes[attr];
        },

        // Get the HTML-escaped value of an attribute.
        escape: function (attr) {
            return _.escape(this.get(attr));
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function (attr) {
            return this.get(attr) != null;
        },

        // Special-cased proxy to underscore's `_.matches` method.
        matches: function (attrs) {
            return !!_.iteratee(attrs, this)(this.attributes);
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function (key, val, options) {
            if (key == null) return this;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            var attrs;
            if (typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            options || (options = {});

            // Run validation.
            if (!this._validate(attrs, options)) return false;

            // Extract attributes and options.
            var unset = options.unset;
            var silent = options.silent;
            var changes = [];
            var changing = this._changing;
            this._changing = true;

            if (!changing) {
                this._previousAttributes = _.clone(this.attributes);
                this.changed = {};
            }

            var current = this.attributes;
            var changed = this.changed;
            var prev = this._previousAttributes;

            // For each `set` attribute, update or delete the current value.
            for (var attr in attrs) {
                val = attrs[attr];
                if (!_.isEqual(current[attr], val)) changes.push(attr);
                if (!_.isEqual(prev[attr], val)) {
                    changed[attr] = val;
                } else {
                    delete changed[attr];
                }
                unset ? delete current[attr] : current[attr] = val;
            }

            // Update the `id`.
            if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

            // Trigger all relevant attribute changes.
            if (!silent) {
                if (changes.length) this._pending = options;
                for (var i = 0; i < changes.length; i++) {
                    this.trigger('change:' + changes[i], this, current[changes[i]], options);
                }
            }

            // You might be wondering why there's a `while` loop here. Changes can
            // be recursively nested within `"change"` events.
            if (changing) return this;
            if (!silent) {
                while (this._pending) {
                    options = this._pending;
                    this._pending = false;
                    this.trigger('change', this, options);
                }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function (attr, options) {
            return this.set(attr, void 0, _.extend({}, options, { unset: true }));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function (options) {
            var attrs = {};
            for (var key in this.attributes) attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, { unset: true }));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function (attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function (diff) {
            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            var changed = {};
            for (var attr in diff) {
                var val = diff[attr];
                if (_.isEqual(old[attr], val)) continue;
                changed[attr] = val;
            }
            return _.size(changed) ? changed : false;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function (attr) {
            if (attr == null || !this._previousAttributes) return null;
            return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function () {
            return _.clone(this._previousAttributes);
        },

        // Fetch the model from the server, merging the response with the model's
        // local attributes. Any changed attributes will trigger a "change" event.
        fetch: function (options) {
            options = _.extend({ parse: true }, options);
            var model = this;
            var success = options.success;
            options.success = function (resp) {
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (!model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
        },

        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function (key, val, options) {
            // Handle both `"key", value` and `{key: value}` -style arguments.
            var attrs;
            if (key == null || typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            options = _.extend({ validate: true, parse: true }, options);
            var wait = options.wait;

            // If we're not waiting and attributes exist, save acts as
            // `set(attr).save(null, opts)` with validation. Otherwise, check if
            // the model will be valid when the attributes, if any, are set.
            if (attrs && !wait) {
                if (!this.set(attrs, options)) return false;
            } else if (!this._validate(attrs, options)) {
                return false;
            }

            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            var model = this;
            var success = options.success;
            var attributes = this.attributes;
            options.success = function (resp) {
                // Ensure attributes are restored during synchronous saves.
                model.attributes = attributes;
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
                if (serverAttrs && !model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);

            // Set temporary attributes if `{wait: true}` to properly find new ids.
            if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

            var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
            if (method === 'patch' && !options.attrs) options.attrs = attrs;
            var xhr = this.sync(method, this, options);

            // Restore attributes.
            this.attributes = attributes;

            return xhr;
        },

        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function (options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            var wait = options.wait;

            var destroy = function () {
                model.stopListening();
                model.trigger('destroy', model, model.collection, options);
            };

            options.success = function (resp) {
                if (wait) destroy();
                if (success) success.call(options.context, model, resp, options);
                if (!model.isNew()) model.trigger('sync', model, resp, options);
            };

            var xhr = false;
            if (this.isNew()) {
                _.defer(options.success);
            } else {
                wrapError(this, options);
                xhr = this.sync('delete', this, options);
            }
            if (!wait) destroy();
            return xhr;
        },

        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function () {
            var base =
              _.result(this, 'urlRoot') ||
              _.result(this.collection, 'url') ||
              urlError();
            if (this.isNew()) return base;
            var id = this.get(this.idAttribute);
            return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
        },

        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function (resp, options) {
            return resp;
        },

        // Create a new model with identical attributes to this one.
        clone: function () {
            return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function () {
            return !this.has(this.idAttribute);
        },

        // Check if the model is currently in a valid state.
        isValid: function (options) {
            return this._validate({}, _.extend({}, options, { validate: true }));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function (attrs, options) {
            if (!options.validate || !this.validate) return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
            return false;
        }

    });

    // Underscore methods that we want to implement on the Model, mapped to the
    // number of arguments they take.
    var modelMethods = {
        keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
        omit: 0, chain: 1, isEmpty: 1
    };

    // Mix in each Underscore method as a proxy to `Model#attributes`.
    addUnderscoreMethods(Model, modelMethods, 'attributes');

    // Backbone.Collection
    // -------------------

    // If models tend to represent a single row of data, a Backbone Collection is
    // more analogous to a table full of data ... or a small slice or page of that
    // table, or a collection of rows that belong together for a particular reason
    // -- all of the messages in this particular folder, all of the documents
    // belonging to this particular author, and so on. Collections maintain
    // indexes of their models, both in order, and for lookup by `id`.

    // Create a new **Collection**, perhaps to contain a specific type of `model`.
    // If a `comparator` is specified, the Collection will maintain
    // its models in sort order, as they're added and removed.
    var Collection = Backbone.Collection = function (models, options) {
        options || (options = {});
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({ silent: true }, options));
    };

    // Default options for `Collection#set`.
    var setOptions = { add: true, remove: true, merge: true };
    var addOptions = { add: true, remove: false };

    // Splices `insert` into `array` at index `at`.
    var splice = function (array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i;
        for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
        for (i = 0; i < length; i++) array[i + at] = insert[i];
        for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
    };

    // Define the Collection's inheritable methods.
    _.extend(Collection.prototype, Events, {

        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model,

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function () { },

        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function (options) {
            return this.map(function (model) { return model.toJSON(options); });
        },

        // Proxy `Backbone.sync` by default.
        sync: function () {
            return Backbone.sync.apply(this, arguments);
        },

        // Add a model, or list of models to the set. `models` may be Backbone
        // Models or raw JavaScript objects to be converted to Models, or any
        // combination of the two.
        add: function (models, options) {
            return this.set(models, _.extend({ merge: false }, options, addOptions));
        },

        // Remove a model, or a list of models from the set.
        remove: function (models, options) {
            options = _.extend({}, options);
            var singular = !_.isArray(models);
            models = singular ? [models] : models.slice();
            var removed = this._removeModels(models, options);
            if (!options.silent && removed.length) {
                options.changes = { added: [], merged: [], removed: removed };
                this.trigger('update', this, options);
            }
            return singular ? removed[0] : removed;
        },

        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function (models, options) {
            if (models == null) return;

            options = _.extend({}, setOptions, options);
            if (options.parse && !this._isModel(models)) {
                models = this.parse(models, options) || [];
            }

            var singular = !_.isArray(models);
            models = singular ? [models] : models.slice();

            var at = options.at;
            if (at != null) at = +at;
            if (at > this.length) at = this.length;
            if (at < 0) at += this.length + 1;

            var set = [];
            var toAdd = [];
            var toMerge = [];
            var toRemove = [];
            var modelMap = {};

            var add = options.add;
            var merge = options.merge;
            var remove = options.remove;

            var sort = false;
            var sortable = this.comparator && at == null && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;

            // Turn bare objects into model references, and prevent invalid models
            // from being added.
            var model, i;
            for (i = 0; i < models.length; i++) {
                model = models[i];

                // If a duplicate is found, prevent it from being added and
                // optionally merge it into the existing model.
                var existing = this.get(model);
                if (existing) {
                    if (merge && model !== existing) {
                        var attrs = this._isModel(model) ? model.attributes : model;
                        if (options.parse) attrs = existing.parse(attrs, options);
                        existing.set(attrs, options);
                        toMerge.push(existing);
                        if (sortable && !sort) sort = existing.hasChanged(sortAttr);
                    }
                    if (!modelMap[existing.cid]) {
                        modelMap[existing.cid] = true;
                        set.push(existing);
                    }
                    models[i] = existing;

                    // If this is a new, valid model, push it to the `toAdd` list.
                } else if (add) {
                    model = models[i] = this._prepareModel(model, options);
                    if (model) {
                        toAdd.push(model);
                        this._addReference(model, options);
                        modelMap[model.cid] = true;
                        set.push(model);
                    }
                }
            }

            // Remove stale models.
            if (remove) {
                for (i = 0; i < this.length; i++) {
                    model = this.models[i];
                    if (!modelMap[model.cid]) toRemove.push(model);
                }
                if (toRemove.length) this._removeModels(toRemove, options);
            }

            // See if sorting is needed, update `length` and splice in new models.
            var orderChanged = false;
            var replace = !sortable && add && remove;
            if (set.length && replace) {
                orderChanged = this.length !== set.length || _.some(this.models, function (m, index) {
                    return m !== set[index];
                });
                this.models.length = 0;
                splice(this.models, set, 0);
                this.length = this.models.length;
            } else if (toAdd.length) {
                if (sortable) sort = true;
                splice(this.models, toAdd, at == null ? this.length : at);
                this.length = this.models.length;
            }

            // Silently sort the collection if appropriate.
            if (sort) this.sort({ silent: true });

            // Unless silenced, it's time to fire all appropriate add/sort/update events.
            if (!options.silent) {
                for (i = 0; i < toAdd.length; i++) {
                    if (at != null) options.index = at + i;
                    model = toAdd[i];
                    model.trigger('add', model, this, options);
                }
                if (sort || orderChanged) this.trigger('sort', this, options);
                if (toAdd.length || toRemove.length || toMerge.length) {
                    options.changes = {
                        added: toAdd,
                        removed: toRemove,
                        merged: toMerge
                    };
                    this.trigger('update', this, options);
                }
            }

            // Return the added (or merged) model (or models).
            return singular ? models[0] : models;
        },

        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function (models, options) {
            options = options ? _.clone(options) : {};
            for (var i = 0; i < this.models.length; i++) {
                this._removeReference(this.models[i], options);
            }
            options.previousModels = this.models;
            this._reset();
            models = this.add(models, _.extend({ silent: true }, options));
            if (!options.silent) this.trigger('reset', this, options);
            return models;
        },

        // Add a model to the end of the collection.
        push: function (model, options) {
            return this.add(model, _.extend({ at: this.length }, options));
        },

        // Remove a model from the end of the collection.
        pop: function (options) {
            var model = this.at(this.length - 1);
            return this.remove(model, options);
        },

        // Add a model to the beginning of the collection.
        unshift: function (model, options) {
            return this.add(model, _.extend({ at: 0 }, options));
        },

        // Remove a model from the beginning of the collection.
        shift: function (options) {
            var model = this.at(0);
            return this.remove(model, options);
        },

        // Slice out a sub-array of models from the collection.
        slice: function () {
            return slice.apply(this.models, arguments);
        },

        // Get a model from the set by id, cid, model object with id or cid
        // properties, or an attributes object that is transformed through modelId.
        get: function (obj) {
            if (obj == null) return void 0;
            return this._byId[obj] ||
              this._byId[this.modelId(obj.attributes || obj)] ||
              obj.cid && this._byId[obj.cid];
        },

        // Returns `true` if the model is in the collection.
        has: function (obj) {
            return this.get(obj) != null;
        },

        // Get the model at the given index.
        at: function (index) {
            if (index < 0) index += this.length;
            return this.models[index];
        },

        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function (attrs, first) {
            return this[first ? 'find' : 'filter'](attrs);
        },

        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function (attrs) {
            return this.where(attrs, true);
        },

        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function (options) {
            var comparator = this.comparator;
            if (!comparator) throw new Error('Cannot sort a set without a comparator');
            options || (options = {});

            var length = comparator.length;
            if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

            // Run sort based on type of `comparator`.
            if (length === 1 || _.isString(comparator)) {
                this.models = this.sortBy(comparator);
            } else {
                this.models.sort(comparator);
            }
            if (!options.silent) this.trigger('sort', this, options);
            return this;
        },

        // Pluck an attribute from each model in the collection.
        pluck: function (attr) {
            return this.map(attr + '');
        },

        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function (options) {
            options = _.extend({ parse: true }, options);
            var success = options.success;
            var collection = this;
            options.success = function (resp) {
                var method = options.reset ? 'reset' : 'set';
                collection[method](resp, options);
                if (success) success.call(options.context, collection, resp, options);
                collection.trigger('sync', collection, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
        },

        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function (model, options) {
            options = options ? _.clone(options) : {};
            var wait = options.wait;
            model = this._prepareModel(model, options);
            if (!model) return false;
            if (!wait) this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function (m, resp, callbackOpts) {
                if (wait) collection.add(m, callbackOpts);
                if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
            };
            model.save(null, options);
            return model;
        },

        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function (resp, options) {
            return resp;
        },

        // Create a new collection with an identical list of models as this one.
        clone: function () {
            return new this.constructor(this.models, {
                model: this.model,
                comparator: this.comparator
            });
        },

        // Define how to uniquely identify models in the collection.
        modelId: function (attrs) {
            return attrs[this.model.prototype.idAttribute || 'id'];
        },

        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function () {
            this.length = 0;
            this.models = [];
            this._byId = {};
        },

        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function (attrs, options) {
            if (this._isModel(attrs)) {
                if (!attrs.collection) attrs.collection = this;
                return attrs;
            }
            options = options ? _.clone(options) : {};
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model.validationError) return model;
            this.trigger('invalid', this, model.validationError, options);
            return false;
        },

        // Internal method called by both remove and set.
        _removeModels: function (models, options) {
            var removed = [];
            for (var i = 0; i < models.length; i++) {
                var model = this.get(models[i]);
                if (!model) continue;

                var index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;

                // Remove references before triggering 'remove' event to prevent an
                // infinite loop. #3693
                delete this._byId[model.cid];
                var id = this.modelId(model.attributes);
                if (id != null) delete this._byId[id];

                if (!options.silent) {
                    options.index = index;
                    model.trigger('remove', model, this, options);
                }

                removed.push(model);
                this._removeReference(model, options);
            }
            return removed;
        },

        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function (model) {
            return model instanceof Model;
        },

        // Internal method to create a model's ties to a collection.
        _addReference: function (model, options) {
            this._byId[model.cid] = model;
            var id = this.modelId(model.attributes);
            if (id != null) this._byId[id] = model;
            model.on('all', this._onModelEvent, this);
        },

        // Internal method to sever a model's ties to a collection.
        _removeReference: function (model, options) {
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null) delete this._byId[id];
            if (this === model.collection) delete model.collection;
            model.off('all', this._onModelEvent, this);
        },

        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function (event, model, collection, options) {
            if (model) {
                if ((event === 'add' || event === 'remove') && collection !== this) return;
                if (event === 'destroy') this.remove(model, options);
                if (event === 'change') {
                    var prevId = this.modelId(model.previousAttributes());
                    var id = this.modelId(model.attributes);
                    if (prevId !== id) {
                        if (prevId != null) delete this._byId[prevId];
                        if (id != null) this._byId[id] = model;
                    }
                }
            }
            this.trigger.apply(this, arguments);
        }

    });

    // Underscore methods that we want to implement on the Collection.
    // 90% of the core usefulness of Backbone Collections is actually implemented
    // right here:
    var collectionMethods = {
        forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
        foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
        select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
        contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
        head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
        without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
        isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
        sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3
    };

    // Mix in each Underscore method as a proxy to `Collection#models`.
    addUnderscoreMethods(Collection, collectionMethods, 'models');

    // Backbone.View
    // -------------

    // Backbone Views are almost more convention than they are actual code. A View
    // is simply a JavaScript object that represents a logical chunk of UI in the
    // DOM. This might be a single item, an entire list, a sidebar or panel, or
    // even the surrounding frame which wraps your whole app. Defining a chunk of
    // UI as a **View** allows you to define your DOM events declaratively, without
    // having to worry about render order ... and makes it easy for the view to
    // react to specific changes in the state of your models.

    // Creating a Backbone.View creates its initial element outside of the DOM,
    // if an existing element is not provided...
    var View = Backbone.View = function (options) {
        this.cid = _.uniqueId('view');
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
    };

    // Cached regex to split keys for `delegate`.
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;

    // List of view options to be set as properties.
    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

    // Set up all inheritable **Backbone.View** properties and methods.
    _.extend(View.prototype, Events, {

        // The default `tagName` of a View's element is `"div"`.
        tagName: 'div',

        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function (selector) {
            return this.$el.find(selector);
        },

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function () { },

        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function () {
            return this;
        },

        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Backbone.Events listeners.
        remove: function () {
            this._removeElement();
            this.stopListening();
            return this;
        },

        // Remove this view's element from the document and all event listeners
        // attached to it. Exposed for subclasses using an alternative DOM
        // manipulation API.
        _removeElement: function () {
            this.$el.remove();
        },

        // Change the view's element (`this.el` property) and re-delegate the
        // view's events on the new element.
        setElement: function (element) {
            this.undelegateEvents();
            this._setElement(element);
            this.delegateEvents();
            return this;
        },

        // Creates the `this.el` and `this.$el` references for this view using the
        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
        // context or an element. Subclasses can override this to utilize an
        // alternative DOM manipulation API and are only required to set the
        // `this.el` property.
        _setElement: function (el) {
            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
            this.el = this.$el[0];
        },

        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function (events) {
            events || (events = _.result(this, 'events'));
            if (!events) return this;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) method = this[method];
                if (!method) continue;
                var match = key.match(delegateEventSplitter);
                this.delegate(match[1], match[2], _.bind(method, this));
            }
            return this;
        },

        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function (eventName, selector, listener) {
            this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
            return this;
        },

        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function () {
            if (this.$el) this.$el.off('.delegateEvents' + this.cid);
            return this;
        },

        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function (eventName, selector, listener) {
            this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
            return this;
        },

        // Produces a DOM element to be assigned to your view. Exposed for
        // subclasses using an alternative DOM manipulation API.
        _createElement: function (tagName) {
            return document.createElement(tagName);
        },

        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function () {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, 'attributes'));
                if (this.id) attrs.id = _.result(this, 'id');
                if (this.className) attrs['class'] = _.result(this, 'className');
                this.setElement(this._createElement(_.result(this, 'tagName')));
                this._setAttributes(attrs);
            } else {
                this.setElement(_.result(this, 'el'));
            }
        },

        // Set attributes from a hash on this view's element.  Exposed for
        // subclasses using an alternative DOM manipulation API.
        _setAttributes: function (attributes) {
            this.$el.attr(attributes);
        }

    });

    // Backbone.sync
    // -------------

    // Override this function to change the manner in which Backbone persists
    // models to the server. You will be passed the type of request, and the
    // model in question. By default, makes a RESTful Ajax request
    // to the model's `url()`. Some possible customizations could be:
    //
    // * Use `setTimeout` to batch rapid-fire updates into a single request.
    // * Send up the models as XML instead of JSON.
    // * Persist models via WebSockets instead of Ajax.
    //
    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
    // as `POST`, with a `_method` parameter containing the true HTTP method,
    // as well as all requests with the body as `application/x-www-form-urlencoded`
    // instead of `application/json` with the model in a param named `model`.
    // Useful when interfacing with server-side languages like **PHP** that make
    // it difficult to read the body of `PUT` requests.
    Backbone.sync = function (method, model, options) {
        var type = methodMap[method];

        // Default options, unless specified.
        _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
        });

        // Default JSON-request options.
        var params = { type: type, dataType: 'json' };

        // Ensure that we have a URL.
        if (!options.url) {
            params.url = _.result(model, 'url') || urlError();
        }

        // Ensure that we have the appropriate request data.
        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
            params.contentType = 'application/json';
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }

        // For older servers, emulate JSON by encoding the request into an HTML-form.
        if (options.emulateJSON) {
            params.contentType = 'application/x-www-form-urlencoded';
            params.data = params.data ? { model: params.data } : {};
        }

        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
        // And an `X-HTTP-Method-Override` header.
        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
            params.type = 'POST';
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function (xhr) {
                xhr.setRequestHeader('X-HTTP-Method-Override', type);
                if (beforeSend) return beforeSend.apply(this, arguments);
            };
        }

        // Don't process data on a non-GET request.
        if (params.type !== 'GET' && !options.emulateJSON) {
            params.processData = false;
        }

        // Pass along `textStatus` and `errorThrown` from jQuery.
        var error = options.error;
        options.error = function (xhr, textStatus, errorThrown) {
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            if (error) error.call(options.context, xhr, textStatus, errorThrown);
        };

        // Make the request, allowing the user to override any Ajax options.
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger('request', model, xhr, options);
        return xhr;
    };

    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
    var methodMap = {
        'create': 'POST',
        'update': 'PUT',
        'patch': 'PATCH',
        'delete': 'DELETE',
        'read': 'GET'
    };

    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
    // Override this if you'd like to use a different library.
    Backbone.ajax = function () {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };

    // Backbone.Router
    // ---------------

    // Routers map faux-URLs to actions, and fire events when routes are
    // matched. Creating a new one sets its `routes` hash, if not set statically.
    var Router = Backbone.Router = function (options) {
        options || (options = {});
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };

    // Cached regular expressions for matching named param parts and splatted
    // parts of route strings.
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

    // Set up all inheritable **Backbone.Router** properties and methods.
    _.extend(Router.prototype, Events, {

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function () { },

        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function (route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = '';
            }
            if (!callback) callback = this[name];
            var router = this;
            Backbone.history.route(route, function (fragment) {
                var args = router._extractParameters(route, fragment);
                if (router.execute(callback, args, name) !== false) {
                    router.trigger.apply(router, ['route:' + name].concat(args));
                    router.trigger('route', name, args);
                    Backbone.history.trigger('route', router, name, args);
                }
            });
            return this;
        },

        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function (callback, args, name) {
            if (callback) callback.apply(this, args);
        },

        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function (fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },

        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function () {
            if (!this.routes) return;
            this.routes = _.result(this, 'routes');
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },

        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function (route) {
            route = route.replace(escapeRegExp, '\\$&')
                         .replace(optionalParam, '(?:$1)?')
                         .replace(namedParam, function (match, optional) {
                             return optional ? match : '([^/?]+)';
                         })
                         .replace(splatParam, '([^?]*?)');
            return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },

        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function (route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function (param, i) {
                // Don't decode the search params.
                if (i === params.length - 1) return param || null;
                return param ? decodeURIComponent(param) : null;
            });
        }

    });

    // Backbone.History
    // ----------------

    // Handles cross-browser history management, based on either
    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
    // and URL fragments. If the browser supports neither (old IE, natch),
    // falls back to polling.
    var History = Backbone.History = function () {
        this.handlers = [];
        this.checkUrl = _.bind(this.checkUrl, this);

        // Ensure that `History` can be used outside of the browser.
        if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
        }
    };

    // Cached regex for stripping a leading hash/slash and trailing space.
    var routeStripper = /^[#\/]|\s+$/g;

    // Cached regex for stripping leading and trailing slashes.
    var rootStripper = /^\/+|\/+$/g;

    // Cached regex for stripping urls of hash.
    var pathStripper = /#.*$/;

    // Has the history handling already been started?
    History.started = false;

    // Set up all inheritable **Backbone.History** properties and methods.
    _.extend(History.prototype, Events, {

        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,

        // Are we at the app root?
        atRoot: function () {
            var path = this.location.pathname.replace(/[^\/]$/, '$&/');
            return path === this.root && !this.getSearch();
        },

        // Does the pathname match the root?
        matchRoot: function () {
            var path = this.decodeFragment(this.location.pathname);
            var rootPath = path.slice(0, this.root.length - 1) + '/';
            return rootPath === this.root;
        },

        // Unicode characters in `location.pathname` are percent encoded so they're
        // decoded for comparison. `%25` should not be decoded since it may be part
        // of an encoded parameter.
        decodeFragment: function (fragment) {
            return decodeURI(fragment.replace(/%25/g, '%2525'));
        },

        // In IE6, the hash fragment and search params are incorrect if the
        // fragment contains `?`.
        getSearch: function () {
            var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
            return match ? match[0] : '';
        },

        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function (window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : '';
        },

        // Get the pathname and search params, without the root.
        getPath: function () {
            var path = this.decodeFragment(
              this.location.pathname + this.getSearch()
            ).slice(this.root.length - 1);
            return path.charAt(0) === '/' ? path.slice(1) : path;
        },

        // Get the cross-browser normalized URL fragment from the path or hash.
        getFragment: function (fragment) {
            if (fragment == null) {
                if (this._usePushState || !this._wantsHashChange) {
                    fragment = this.getPath();
                } else {
                    fragment = this.getHash();
                }
            }
            return fragment.replace(routeStripper, '');
        },

        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function (options) {
            if (History.started) throw new Error('Backbone.history has already been started');
            History.started = true;

            // Figure out the initial configuration. Do we need an iframe?
            // Is pushState desired ... is it available?
            this.options = _.extend({ root: '/' }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._hasHashChange = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
            this._useHashChange = this._wantsHashChange && this._hasHashChange;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.history && this.history.pushState);
            this._usePushState = this._wantsPushState && this._hasPushState;
            this.fragment = this.getFragment();

            // Normalize root to always include a leading and trailing slash.
            this.root = ('/' + this.root + '/').replace(rootStripper, '/');

            // Transition from hashChange to pushState or vice versa if both are
            // requested.
            if (this._wantsHashChange && this._wantsPushState) {

                // If we've started off with a route from a `pushState`-enabled
                // browser, but we're currently in a browser that doesn't support it...
                if (!this._hasPushState && !this.atRoot()) {
                    var rootPath = this.root.slice(0, -1) || '/';
                    this.location.replace(rootPath + '#' + this.getPath());
                    // Return immediately as browser will do redirect to new url
                    return true;

                    // Or if we've started out with a hash-based route, but we're currently
                    // in a browser where it could be `pushState`-based instead...
                } else if (this._hasPushState && this.atRoot()) {
                    this.navigate(this.getHash(), { replace: true });
                }

            }

            // Proxy an iframe to handle location events if the browser doesn't
            // support the `hashchange` event, HTML5 history, or the user wants
            // `hashChange` but not `pushState`.
            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                this.iframe = document.createElement('iframe');
                this.iframe.src = 'javascript:0';
                this.iframe.style.display = 'none';
                this.iframe.tabIndex = -1;
                var body = document.body;
                // Using `appendChild` will throw on IE < 9 if the document is not ready.
                var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
                iWindow.document.open();
                iWindow.document.close();
                iWindow.location.hash = '#' + this.fragment;
            }

            // Add a cross-platform `addEventListener` shim for older browsers.
            var addEventListener = window.addEventListener || function (eventName, listener) {
                return attachEvent('on' + eventName, listener);
            };

            // Depending on whether we're using pushState or hashes, and whether
            // 'onhashchange' is supported, determine how we check the URL state.
            if (this._usePushState) {
                addEventListener('popstate', this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                addEventListener('hashchange', this.checkUrl, false);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }

            if (!this.options.silent) return this.loadUrl();
        },

        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function () {
            // Add a cross-platform `removeEventListener` shim for older browsers.
            var removeEventListener = window.removeEventListener || function (eventName, listener) {
                return detachEvent('on' + eventName, listener);
            };

            // Remove window listeners.
            if (this._usePushState) {
                removeEventListener('popstate', this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                removeEventListener('hashchange', this.checkUrl, false);
            }

            // Clean up the iframe if necessary.
            if (this.iframe) {
                document.body.removeChild(this.iframe);
                this.iframe = null;
            }

            // Some environments will throw when clearing an undefined interval.
            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
            History.started = false;
        },

        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function (route, callback) {
            this.handlers.unshift({ route: route, callback: callback });
        },

        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function (e) {
            var current = this.getFragment();

            // If the user pressed the back button, the iframe's hash will have
            // changed and we should use that for comparison.
            if (current === this.fragment && this.iframe) {
                current = this.getHash(this.iframe.contentWindow);
            }

            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl();
        },

        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function (fragment) {
            // If the root doesn't match, no routes can match either.
            if (!this.matchRoot()) return false;
            fragment = this.fragment = this.getFragment(fragment);
            return _.some(this.handlers, function (handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
        },

        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function (fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = { trigger: !!options };

            // Normalize the fragment.
            fragment = this.getFragment(fragment || '');

            // Don't include a trailing slash on the root.
            var rootPath = this.root;
            if (fragment === '' || fragment.charAt(0) === '?') {
                rootPath = rootPath.slice(0, -1) || '/';
            }
            var url = rootPath + fragment;

            // Strip the hash and decode for matching.
            fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

            if (this.fragment === fragment) return;
            this.fragment = fragment;

            // If pushState is available, we use it to set the fragment as a real URL.
            if (this._usePushState) {
                this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

                // If hash changes haven't been explicitly disabled, update the hash
                // fragment to store history.
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
                    var iWindow = this.iframe.contentWindow;

                    // Opening and closing the iframe tricks IE7 and earlier to push a
                    // history entry on hash-tag change.  When replace is true, we don't
                    // want this.
                    if (!options.replace) {
                        iWindow.document.open();
                        iWindow.document.close();
                    }

                    this._updateHash(iWindow.location, fragment, options.replace);
                }

                // If you've told us that you explicitly don't want fallback hashchange-
                // based history, then `navigate` becomes a page refresh.
            } else {
                return this.location.assign(url);
            }
            if (options.trigger) return this.loadUrl(fragment);
        },

        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function (location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, '');
                location.replace(href + '#' + fragment);
            } else {
                // Some browsers require that `hash` contains a leading #.
                location.hash = '#' + fragment;
            }
        }

    });

    // Create the default Backbone.history.
    Backbone.history = new History;

    // Helpers
    // -------

    // Helper function to correctly set up the prototype chain for subclasses.
    // Similar to `goog.inherits`, but uses a hash of prototype properties and
    // class properties to be extended.
    var extend = function (protoProps, staticProps) {
        var parent = this;
        var child;

        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent constructor.
        if (protoProps && _.has(protoProps, 'constructor')) {
            child = protoProps.constructor;
        } else {
            child = function () { return parent.apply(this, arguments); };
        }

        // Add static properties to the constructor function, if supplied.
        _.extend(child, parent, staticProps);

        // Set the prototype chain to inherit from `parent`, without calling
        // `parent`'s constructor function and add the prototype properties.
        child.prototype = _.create(parent.prototype, protoProps);
        child.prototype.constructor = child;

        // Set a convenience property in case the parent's prototype is needed
        // later.
        child.__super__ = parent.prototype;

        return child;
    };

    // Set up inheritance for the model, collection, router, view and history.
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

    // Throw an error when a URL is needed, and none is supplied.
    var urlError = function () {
        throw new Error('A "url" property or function must be specified');
    };

    // Wrap an optional error callback with a fallback error event.
    var wrapError = function (model, options) {
        var error = options.error;
        options.error = function (resp) {
            if (error) error.call(options.context, model, resp, options);
            model.trigger('error', model, resp, options);
        };
    };

    return Backbone;
});

(function() {

  // nb. This is for IE10 and lower _only_.
  var supportCustomEvent = window.CustomEvent;
  if (!supportCustomEvent || typeof supportCustomEvent === 'object') {
    supportCustomEvent = function CustomEvent(event, x) {
      x = x || {};
      var ev = document.createEvent('CustomEvent');
      ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);
      return ev;
    };
    supportCustomEvent.prototype = window.Event.prototype;
  }

  /**
   * @param {Element} el to check for stacking context
   * @return {boolean} whether this el or its parents creates a stacking context
   */
  function createsStackingContext(el) {
    while (el && el !== document.body) {
      var s = window.getComputedStyle(el);
      var invalid = function(k, ok) {
        return !(s[k] === undefined || s[k] === ok);
      }
      if (s.opacity < 1 ||
          invalid('zIndex', 'auto') ||
          invalid('transform', 'none') ||
          invalid('mixBlendMode', 'normal') ||
          invalid('filter', 'none') ||
          invalid('perspective', 'none') ||
          s['isolation'] === 'isolate' ||
          s.position === 'fixed' ||
          s.webkitOverflowScrolling === 'touch') {
        return true;
      }
      el = el.parentElement;
    }
    return false;
  }

  /**
   * Finds the nearest <dialog> from the passed element.
   *
   * @param {Element} el to search from
   * @return {HTMLDialogElement} dialog found
   */
  function findNearestDialog(el) {
    while (el) {
      if (el.localName === 'dialog') {
        return /** @type {HTMLDialogElement} */ (el);
      }
      el = el.parentElement;
    }
    return null;
  }

  /**
   * Blur the specified element, as long as it's not the HTML body element.
   * This works around an IE9/10 bug - blurring the body causes Windows to
   * blur the whole application.
   *
   * @param {Element} el to blur
   */
  function safeBlur(el) {
    if (el && el.blur && el !== document.body) {
      el.blur();
    }
  }

  /**
   * @param {!NodeList} nodeList to search
   * @param {Node} node to find
   * @return {boolean} whether node is inside nodeList
   */
  function inNodeList(nodeList, node) {
    for (var i = 0; i < nodeList.length; ++i) {
      if (nodeList[i] === node) {
        return true;
      }
    }
    return false;
  }

  /**
   * @param {HTMLFormElement} el to check
   * @return {boolean} whether this form has method="dialog"
   */
  function isFormMethodDialog(el) {
    if (!el || !el.hasAttribute('method')) {
      return false;
    }
    return el.getAttribute('method').toLowerCase() === 'dialog';
  }

  /**
   * @param {!HTMLDialogElement} dialog to upgrade
   * @constructor
   */
  function dialogPolyfillInfo(dialog) {
    this.dialog_ = dialog;
    this.replacedStyleTop_ = false;
    this.openAsModal_ = false;

    // Set a11y role. Browsers that support dialog implicitly know this already.
    if (!dialog.hasAttribute('role')) {
      dialog.setAttribute('role', 'dialog');
    }

    dialog.show = this.show.bind(this);
    dialog.showModal = this.showModal.bind(this);
    dialog.close = this.close.bind(this);

    if (!('returnValue' in dialog)) {
      dialog.returnValue = '';
    }

    if ('MutationObserver' in window) {
      var mo = new MutationObserver(this.maybeHideModal.bind(this));
      mo.observe(dialog, {attributes: true, attributeFilter: ['open']});
    } else {
      // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also
      // seem to fire even if the element was removed as part of a parent removal. Use the removed
      // events to force downgrade (useful if removed/immediately added).
      var removed = false;
      var cb = function() {
        removed ? this.downgradeModal() : this.maybeHideModal();
        removed = false;
      }.bind(this);
      var timeout;
      var delayModel = function(ev) {
        if (ev.target !== dialog) { return; }  // not for a child element
        var cand = 'DOMNodeRemoved';
        removed |= (ev.type.substr(0, cand.length) === cand);
        window.clearTimeout(timeout);
        timeout = window.setTimeout(cb, 0);
      };
      ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function(name) {
        dialog.addEventListener(name, delayModel);
      });
    }
    // Note that the DOM is observed inside DialogManager while any dialog
    // is being displayed as a modal, to catch modal removal from the DOM.

    Object.defineProperty(dialog, 'open', {
      set: this.setOpen.bind(this),
      get: dialog.hasAttribute.bind(dialog, 'open')
    });

    this.backdrop_ = document.createElement('div');
    this.backdrop_.className = 'backdrop';
    this.backdrop_.addEventListener('click', this.backdropClick_.bind(this));
  }

  dialogPolyfillInfo.prototype = {

    get dialog() {
      return this.dialog_;
    },

    /**
     * Maybe remove this dialog from the modal top layer. This is called when
     * a modal dialog may no longer be tenable, e.g., when the dialog is no
     * longer open or is no longer part of the DOM.
     */
    maybeHideModal: function() {
      if (this.dialog_.hasAttribute('open') && document.body.contains(this.dialog_)) { return; }
      this.downgradeModal();
    },

    /**
     * Remove this dialog from the modal top layer, leaving it as a non-modal.
     */
    downgradeModal: function() {
      if (!this.openAsModal_) { return; }
      this.openAsModal_ = false;
      this.dialog_.style.zIndex = '';

      // This won't match the native <dialog> exactly because if the user set top on a centered
      // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's
      // possible to polyfill this perfectly.
      if (this.replacedStyleTop_) {
        this.dialog_.style.top = '';
        this.replacedStyleTop_ = false;
      }

      // Clear the backdrop and remove from the manager.
      this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);
      dialogPolyfill.dm.removeDialog(this);
    },

    /**
     * @param {boolean} value whether to open or close this dialog
     */
    setOpen: function(value) {
      if (value) {
        this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');
      } else {
        this.dialog_.removeAttribute('open');
        this.maybeHideModal();  // nb. redundant with MutationObserver
      }
    },

    /**
     * Handles clicks on the fake .backdrop element, redirecting them as if
     * they were on the dialog itself.
     *
     * @param {!Event} e to redirect
     */
    backdropClick_: function(e) {
      if (!this.dialog_.hasAttribute('tabindex')) {
        // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be
        // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this
        // would not be needed - clicks would move the implicit cursor there.
        var fake = document.createElement('div');
        this.dialog_.insertBefore(fake, this.dialog_.firstChild);
        fake.tabIndex = -1;
        fake.focus();
        this.dialog_.removeChild(fake);
      } else {
        this.dialog_.focus();
      }

      var redirectedEvent = document.createEvent('MouseEvents');
      redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window,
          e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey,
          e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
      this.dialog_.dispatchEvent(redirectedEvent);
      e.stopPropagation();
    },

    /**
     * Focuses on the first focusable element within the dialog. This will always blur the current
     * focus, even if nothing within the dialog is found.
     */
    focus_: function() {
      // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.
      var target = this.dialog_.querySelector('[autofocus]:not([disabled])');
      if (!target && this.dialog_.tabIndex >= 0) {
        target = this.dialog_;
      }
      if (!target) {
        // Note that this is 'any focusable area'. This list is probably not exhaustive, but the
        // alternative involves stepping through and trying to focus everything.
        var opts = ['button', 'input', 'keygen', 'select', 'textarea'];
        var query = opts.map(function(el) {
          return el + ':not([disabled])';
        });
        // TODO(samthor): tabindex values that are not numeric are not focusable.
        query.push('[tabindex]:not([disabled]):not([tabindex=""])');  // tabindex != "", not disabled
        target = this.dialog_.querySelector(query.join(', '));
      }
      safeBlur(document.activeElement);
      target && target.focus();
    },

    /**
     * Sets the zIndex for the backdrop and dialog.
     *
     * @param {number} dialogZ
     * @param {number} backdropZ
     */
    updateZIndex: function(dialogZ, backdropZ) {
      if (dialogZ < backdropZ) {
        throw new Error('dialogZ should never be < backdropZ');
      }
      this.dialog_.style.zIndex = dialogZ;
      this.backdrop_.style.zIndex = backdropZ;
    },

    /**
     * Shows the dialog. If the dialog is already open, this does nothing.
     */
    show: function() {
      if (!this.dialog_.open) {
        this.setOpen(true);
        this.focus_();
      }
    },

    /**
     * Show this dialog modally.
     */
    showModal: function() {
      if (this.dialog_.hasAttribute('open')) {
        throw new Error('Failed to execute \'showModal\' on dialog: The element is already open, and therefore cannot be opened modally.');
      }
      if (!document.body.contains(this.dialog_)) {
        throw new Error('Failed to execute \'showModal\' on dialog: The element is not in a Document.');
      }
      if (!dialogPolyfill.dm.pushDialog(this)) {
        throw new Error('Failed to execute \'showModal\' on dialog: There are too many open modal dialogs.');
      }

      if (createsStackingContext(this.dialog_.parentElement)) {
        console.warn('A dialog is being shown inside a stacking context. ' +
            'This may cause it to be unusable. For more information, see this link: ' +
            'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');
      }

      this.setOpen(true);
      this.openAsModal_ = true;

      // Optionally center vertically, relative to the current viewport.
      if (dialogPolyfill.needsCentering(this.dialog_)) {
        dialogPolyfill.reposition(this.dialog_);
        this.replacedStyleTop_ = true;
      } else {
        this.replacedStyleTop_ = false;
      }

      // Insert backdrop.
      this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);

      // Focus on whatever inside the dialog.
      this.focus_();
    },

    /**
     * Closes this HTMLDialogElement. This is optional vs clearing the open
     * attribute, however this fires a 'close' event.
     *
     * @param {string=} opt_returnValue to use as the returnValue
     */
    close: function(opt_returnValue) {
      if (!this.dialog_.hasAttribute('open')) {
        throw new Error('Failed to execute \'close\' on dialog: The element does not have an \'open\' attribute, and therefore cannot be closed.');
      }
      this.setOpen(false);

      // Leave returnValue untouched in case it was set directly on the element
      if (opt_returnValue !== undefined) {
        this.dialog_.returnValue = opt_returnValue;
      }

      // Triggering "close" event for any attached listeners on the <dialog>.
      var closeEvent = new supportCustomEvent('close', {
        bubbles: false,
        cancelable: false
      });
      this.dialog_.dispatchEvent(closeEvent);
    }

  };

  var dialogPolyfill = {};

  dialogPolyfill.reposition = function(element) {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;
    element.style.top = Math.max(scrollTop, topValue) + 'px';
  };

  dialogPolyfill.isInlinePositionSetByStylesheet = function(element) {
    for (var i = 0; i < document.styleSheets.length; ++i) {
      var styleSheet = document.styleSheets[i];
      var cssRules = null;
      // Some browsers throw on cssRules.
      try {
        cssRules = styleSheet.cssRules;
      } catch (e) {}
      if (!cssRules) { continue; }
      for (var j = 0; j < cssRules.length; ++j) {
        var rule = cssRules[j];
        var selectedNodes = null;
        // Ignore errors on invalid selector texts.
        try {
          selectedNodes = document.querySelectorAll(rule.selectorText);
        } catch(e) {}
        if (!selectedNodes || !inNodeList(selectedNodes, element)) {
          continue;
        }
        var cssTop = rule.style.getPropertyValue('top');
        var cssBottom = rule.style.getPropertyValue('bottom');
        if ((cssTop && cssTop !== 'auto') || (cssBottom && cssBottom !== 'auto')) {
          return true;
        }
      }
    }
    return false;
  };

  dialogPolyfill.needsCentering = function(dialog) {
    var computedStyle = window.getComputedStyle(dialog);
    if (computedStyle.position !== 'absolute') {
      return false;
    }

    // We must determine whether the top/bottom specified value is non-auto.  In
    // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but
    // Firefox returns the used value. So we do this crazy thing instead: check
    // the inline style and then go through CSS rules.
    if ((dialog.style.top !== 'auto' && dialog.style.top !== '') ||
        (dialog.style.bottom !== 'auto' && dialog.style.bottom !== '')) {
      return false;
    }
    return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);
  };

  /**
   * @param {!Element} element to force upgrade
   */
  dialogPolyfill.forceRegisterDialog = function(element) {
    if (window.HTMLDialogElement || element.showModal) {
      console.warn('This browser already supports <dialog>, the polyfill ' +
          'may not work correctly', element);
    }
    if (element.localName !== 'dialog') {
      throw new Error('Failed to register dialog: The element is not a dialog.');
    }
    new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ (element));
  };

  /**
   * @param {!Element} element to upgrade, if necessary
   */
  dialogPolyfill.registerDialog = function(element) {
    if (!element.showModal) {
      dialogPolyfill.forceRegisterDialog(element);
    }
  };

  /**
   * @constructor
   */
  dialogPolyfill.DialogManager = function() {
    /** @type {!Array<!dialogPolyfillInfo>} */
    this.pendingDialogStack = [];

    var checkDOM = this.checkDOM_.bind(this);

    // The overlay is used to simulate how a modal dialog blocks the document.
    // The blocking dialog is positioned on top of the overlay, and the rest of
    // the dialogs on the pending dialog stack are positioned below it. In the
    // actual implementation, the modal dialog stacking is controlled by the
    // top layer, where z-index has no effect.
    this.overlay = document.createElement('div');
    this.overlay.className = '_dialog_overlay';
    this.overlay.addEventListener('click', function(e) {
      this.forwardTab_ = undefined;
      e.stopPropagation();
      checkDOM([]);  // sanity-check DOM
    }.bind(this));

    this.handleKey_ = this.handleKey_.bind(this);
    this.handleFocus_ = this.handleFocus_.bind(this);

    this.zIndexLow_ = 100000;
    this.zIndexHigh_ = 100000 + 150;

    this.forwardTab_ = undefined;

    if ('MutationObserver' in window) {
      this.mo_ = new MutationObserver(function(records) {
        var removed = [];
        records.forEach(function(rec) {
          for (var i = 0, c; c = rec.removedNodes[i]; ++i) {
            if (!(c instanceof Element)) {
              continue;
            } else if (c.localName === 'dialog') {
              removed.push(c);
            }
            removed = removed.concat(c.querySelectorAll('dialog'));
          }
        });
        removed.length && checkDOM(removed);
      });
    }
  };

  /**
   * Called on the first modal dialog being shown. Adds the overlay and related
   * handlers.
   */
  dialogPolyfill.DialogManager.prototype.blockDocument = function() {
    document.documentElement.addEventListener('focus', this.handleFocus_, true);
    document.addEventListener('keydown', this.handleKey_);
    this.mo_ && this.mo_.observe(document, {childList: true, subtree: true});
  };

  /**
   * Called on the first modal dialog being removed, i.e., when no more modal
   * dialogs are visible.
   */
  dialogPolyfill.DialogManager.prototype.unblockDocument = function() {
    document.documentElement.removeEventListener('focus', this.handleFocus_, true);
    document.removeEventListener('keydown', this.handleKey_);
    this.mo_ && this.mo_.disconnect();
  };

  /**
   * Updates the stacking of all known dialogs.
   */
  dialogPolyfill.DialogManager.prototype.updateStacking = function() {
    var zIndex = this.zIndexHigh_;

    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
      dpi.updateZIndex(--zIndex, --zIndex);
      if (i === 0) {
        this.overlay.style.zIndex = --zIndex;
      }
    }

    // Make the overlay a sibling of the dialog itself.
    var last = this.pendingDialogStack[0];
    if (last) {
      var p = last.dialog.parentNode || document.body;
      p.appendChild(this.overlay);
    } else if (this.overlay.parentNode) {
      this.overlay.parentNode.removeChild(this.overlay);
    }
  };

  /**
   * @param {Element} candidate to check if contained or is the top-most modal dialog
   * @return {boolean} whether candidate is contained in top dialog
   */
  dialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {
    while (candidate = findNearestDialog(candidate)) {
      for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
        if (dpi.dialog === candidate) {
          return i === 0;  // only valid if top-most
        }
      }
      candidate = candidate.parentElement;
    }
    return false;
  };

  dialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {
    if (this.containedByTopDialog_(event.target)) { return; }

    event.preventDefault();
    event.stopPropagation();
    safeBlur(/** @type {Element} */ (event.target));

    if (this.forwardTab_ === undefined) { return; }  // move focus only from a tab key

    var dpi = this.pendingDialogStack[0];
    var dialog = dpi.dialog;
    var position = dialog.compareDocumentPosition(event.target);
    if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      if (this.forwardTab_) {  // forward
        dpi.focus_();
      } else {  // backwards
        document.documentElement.focus();
      }
    } else {
      // TODO: Focus after the dialog, is ignored.
    }

    return false;
  };

  dialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {
    this.forwardTab_ = undefined;
    if (event.keyCode === 27) {
      event.preventDefault();
      event.stopPropagation();
      var cancelEvent = new supportCustomEvent('cancel', {
        bubbles: false,
        cancelable: true
      });
      var dpi = this.pendingDialogStack[0];
      if (dpi && dpi.dialog.dispatchEvent(cancelEvent)) {
        dpi.dialog.close();
      }
    } else if (event.keyCode === 9) {
      this.forwardTab_ = !event.shiftKey;
    }
  };

  /**
   * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are
   * removed and immediately readded don't stay modal, they become normal.
   *
   * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed
   */
  dialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {
    // This operates on a clone because it may cause it to change. Each change also calls
    // updateStacking, which only actually needs to happen once. But who removes many modal dialogs
    // at a time?!
    var clone = this.pendingDialogStack.slice();
    clone.forEach(function(dpi) {
      if (removed.indexOf(dpi.dialog) !== -1) {
        dpi.downgradeModal();
      } else {
        dpi.maybeHideModal();
      }
    });
  };

  /**
   * @param {!dialogPolyfillInfo} dpi
   * @return {boolean} whether the dialog was allowed
   */
  dialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {
    var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;
    if (this.pendingDialogStack.length >= allowed) {
      return false;
    }
    if (this.pendingDialogStack.unshift(dpi) === 1) {
      this.blockDocument();
    }
    this.updateStacking();
    return true;
  };

  /**
   * @param {!dialogPolyfillInfo} dpi
   */
  dialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {
    var index = this.pendingDialogStack.indexOf(dpi);
    if (index === -1) { return; }

    this.pendingDialogStack.splice(index, 1);
    if (this.pendingDialogStack.length === 0) {
      this.unblockDocument();
    }
    this.updateStacking();
  };

  dialogPolyfill.dm = new dialogPolyfill.DialogManager();
  dialogPolyfill.formSubmitter = null;
  dialogPolyfill.useValue = null;

  /**
   * Installs global handlers, such as click listers and native method overrides. These are needed
   * even if a no dialog is registered, as they deal with <form method="dialog">.
   */
  if (window.HTMLDialogElement === undefined) {

    /**
     * If HTMLFormElement translates method="DIALOG" into 'get', then replace the descriptor with
     * one that returns the correct value.
     */
    var testForm = document.createElement('form');
    testForm.setAttribute('method', 'dialog');
    if (testForm.method !== 'dialog') {
      var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');
      if (methodDescriptor) {
        // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything
        // and don't bother to update the element.
        var realGet = methodDescriptor.get;
        methodDescriptor.get = function() {
          if (isFormMethodDialog(this)) {
            return 'dialog';
          }
          return realGet.call(this);
        };
        var realSet = methodDescriptor.set;
        methodDescriptor.set = function(v) {
          if (typeof v === 'string' && v.toLowerCase() === 'dialog') {
            return this.setAttribute('method', v);
          }
          return realSet.call(this, v);
        };
        Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);
      }
    }

    /**
     * Global 'click' handler, to capture the <input type="submit"> or <button> element which has
     * submitted a <form method="dialog">. Needed as Safari and others don't report this inside
     * document.activeElement.
     */
    document.addEventListener('click', function(ev) {
      dialogPolyfill.formSubmitter = null;
      dialogPolyfill.useValue = null;
      if (ev.defaultPrevented) { return; }  // e.g. a submit which prevents default submission

      var target = /** @type {Element} */ (ev.target);
      if (!target || !isFormMethodDialog(target.form)) { return; }

      var valid = (target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1);
      if (!valid) {
        if (!(target.localName === 'input' && target.type === 'image')) { return; }
        // this is a <input type="image">, which can submit forms
        dialogPolyfill.useValue = ev.offsetX + ',' + ev.offsetY;
      }

      var dialog = findNearestDialog(target);
      if (!dialog) { return; }

      dialogPolyfill.formSubmitter = target;
    }, false);

    /**
     * Replace the native HTMLFormElement.submit() method, as it won't fire the
     * submit event and give us a chance to respond.
     */
    var nativeFormSubmit = HTMLFormElement.prototype.submit;
    function replacementFormSubmit() {
      if (!isFormMethodDialog(this)) {
        return nativeFormSubmit.call(this);
      }
      var dialog = findNearestDialog(this);
      dialog && dialog.close();
    }
    HTMLFormElement.prototype.submit = replacementFormSubmit;

    /**
     * Global form 'dialog' method handler. Closes a dialog correctly on submit
     * and possibly sets its return value.
     */
    document.addEventListener('submit', function(ev) {
      var form = /** @type {HTMLFormElement} */ (ev.target);
      if (!isFormMethodDialog(form)) { return; }
      ev.preventDefault();

      var dialog = findNearestDialog(form);
      if (!dialog) { return; }

      // Forms can only be submitted via .submit() or a click (?), but anyway: sanity-check that
      // the submitter is correct before using its value as .returnValue.
      var s = dialogPolyfill.formSubmitter;
      if (s && s.form === form) {
        dialog.close(dialogPolyfill.useValue || s.value);
      } else {
        dialog.close();
      }
      dialogPolyfill.formSubmitter = null;
    }, true);
  }

  dialogPolyfill['forceRegisterDialog'] = dialogPolyfill.forceRegisterDialog;
  dialogPolyfill['registerDialog'] = dialogPolyfill.registerDialog;

  window['dialogPolyfill'] = dialogPolyfill;

  //if (typeof define === 'function' && 'amd' in define) {
  //  // AMD support
  //  define(function() { return dialogPolyfill; });
  //} else if (typeof module === 'object' && typeof module['exports'] === 'object') {
  //  // CommonJS support
  //  module['exports'] = dialogPolyfill;
  //} else {
  //  // all others
  //  window['dialogPolyfill'] = dialogPolyfill;
  //}
})();

/*
 * jQuery UI Widget 1.10.1+amd
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */

(function (factory) {
    factory(jQuery);
    //if (typeof define === "function" && define.amd) {
    //    // Register as an anonymous AMD module:
    //    define(["jquery"], factory);
    //} else {
    //    // Browser globals:
    //    factory(jQuery);
    //}
}(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		if (!$.widget.extend) {
		    $.widget.extend = function (target) {
		        var input = slice.call(arguments, 1),
                    inputIndex = 0,
                    inputLength = input.length,
                    key,
                    value;
		        for (; inputIndex < inputLength; inputIndex++) {
		            for (key in input[inputIndex]) {
		                value = input[inputIndex][key];
		                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
		                    // Clone objects
		                    if ($.isPlainObject(value)) {
		                        target[key] = $.isPlainObject(target[key]) ?
                                    $.widget.extend({}, target[key], value) :
                                    // Don't extend strings, arrays, etc. with objects
                                    $.widget.extend({}, value);
		                        // Copy everything else by reference
		                    } else {
		                        target[key] = value;
		                    }
		                }
		            }
		        }
		        return target;
		    };
		}
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
		    $.data(element, this.widgetFullName, this);
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function () {
	    if (this._destroy) {
	        this._destroy();
	    }
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
		    this.widget()
				[value ? "addClass" : "removeClass"](
					this.widgetBaseClass + "-disabled" + " " +
					"ui-state-disabled")
				.attr("aria-disabled", value);
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

}));

/*
 * jQuery File Upload Plugin 5.26
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, unparam: true, regexp: true */
/*global define, window, document, File, Blob, FormData, location */

(function (factory) {
    'use strict';
    factory(window.jQuery);
    //if (typeof define === 'function' && define.amd) {
    //    // Register as an anonymous AMD module:
    //    define([
    //        'jquery',
    //        'jquery.ui.widget'
    //    ], factory);
    //} else {
    //    // Browser globals:
    //    factory(window.jQuery);
    //}
}(function ($) {
    'use strict';

    // The FileReader API is not actually used, but works as feature detection,
    // as e.g. Safari supports XHR file uploads via the FormData API,
    // but not non-multipart XHR file uploads:
    $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);
    $.support.xhrFormDataFileUpload = !!window.FormData;

    // The fileupload widget listens for change events on file input fields defined
    // via fileInput setting and paste or drop events of the given dropZone.
    // In addition to the default jQuery Widget methods, the fileupload widget
    // exposes the "add" and "send" methods, to add or directly send files using
    // the fileupload API.
    // By default, files added via file input selection, paste, drag & drop or
    // "add" method are uploaded immediately, but it is possible to override
    // the "add" callback option to queue file uploads.
    $.widget('blueimp.fileupload', {

        options: {
            // The drop target element(s), by the default the complete document.
            // Set to null to disable drag & drop support:
            dropZone: $(document),
            // The paste target element(s), by the default the complete document.
            // Set to null to disable paste support:
            pasteZone: $(document),
            // The file input field(s), that are listened to for change events.
            // If undefined, it is set to the file input fields inside
            // of the widget element on plugin initialization.
            // Set to null to disable the change listener.
            fileInput: undefined,
            // By default, the file input field is replaced with a clone after
            // each input field change event. This is required for iframe transport
            // queues and allows change events to be fired for the same file
            // selection, but can be disabled by setting the following option to false:
            replaceFileInput: true,
            // The parameter name for the file form data (the request argument name).
            // If undefined or empty, the name property of the file input field is
            // used, or "files[]" if the file input name property is also empty,
            // can be a string or an array of strings:
            paramName: undefined,
            // By default, each file of a selection is uploaded using an individual
            // request for XHR type uploads. Set to false to upload file
            // selections in one request each:
            singleFileUploads: true,
            // To limit the number of files uploaded with one XHR request,
            // set the following option to an integer greater than 0:
            limitMultiFileUploads: undefined,
            // Set the following option to true to issue all file upload requests
            // in a sequential order:
            sequentialUploads: false,
            // To limit the number of concurrent uploads,
            // set the following option to an integer greater than 0:
            limitConcurrentUploads: undefined,
            // Set the following option to true to force iframe transport uploads:
            forceIframeTransport: false,
            // Set the following option to the location of a redirect url on the
            // origin server, for cross-domain iframe transport uploads:
            redirect: undefined,
            // The parameter name for the redirect url, sent as part of the form
            // data and set to 'redirect' if this option is empty:
            redirectParamName: undefined,
            // Set the following option to the location of a postMessage window,
            // to enable postMessage transport uploads:
            postMessage: undefined,
            // By default, XHR file uploads are sent as multipart/form-data.
            // The iframe transport is always using multipart/form-data.
            // Set to false to enable non-multipart XHR uploads:
            multipart: true,
            // To upload large files in smaller chunks, set the following option
            // to a preferred maximum chunk size. If set to 0, null or undefined,
            // or the browser does not support the required Blob API, files will
            // be uploaded as a whole.
            maxChunkSize: undefined,
            // When a non-multipart upload or a chunked multipart upload has been
            // aborted, this option can be used to resume the upload by setting
            // it to the size of the already uploaded bytes. This option is most
            // useful when modifying the options object inside of the "add" or
            // "send" callbacks, as the options are cloned for each file upload.
            uploadedBytes: undefined,
            // By default, failed (abort or error) file uploads are removed from the
            // global progress calculation. Set the following option to false to
            // prevent recalculating the global progress data:
            recalculateProgress: true,
            // Interval in milliseconds to calculate and trigger progress events:
            progressInterval: 100,
            // Interval in milliseconds to calculate progress bitrate:
            bitrateInterval: 500,
            // By default, uploads are started automatically when adding files:
            autoUpload: true,

            // Additional form data to be sent along with the file uploads can be set
            // using this option, which accepts an array of objects with name and
            // value properties, a function returning such an array, a FormData
            // object (for XHR file uploads), or a simple object.
            // The form of the first fileInput is given as parameter to the function:
            formData: function (form) {
                return form.serializeArray();
            },

            // The add callback is invoked as soon as files are added to the fileupload
            // widget (via file input selection, drag & drop, paste or add API call).
            // If the singleFileUploads option is enabled, this callback will be
            // called once for each file in the selection for XHR file uplaods, else
            // once for each file selection.
            // The upload starts when the submit method is invoked on the data parameter.
            // The data object contains a files property holding the added files
            // and allows to override plugin options as well as define ajax settings.
            // Listeners for this callback can also be bound the following way:
            // .bind('fileuploadadd', func);
            // data.submit() returns a Promise object and allows to attach additional
            // handlers using jQuery's Deferred callbacks:
            // data.submit().done(func).fail(func).always(func);
            add: function (e, data) {
                if (data.autoUpload || (data.autoUpload !== false &&
                        ($(this).data('blueimp-fileupload') ||
                        $(this).data('fileupload')).options.autoUpload)) {
                    data.submit();
                }
            },

            // Other callbacks:

            // Callback for the submit event of each file upload:
            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);

            // Callback for the start of each file upload request:
            // send: function (e, data) {}, // .bind('fileuploadsend', func);

            // Callback for successful uploads:
            // done: function (e, data) {}, // .bind('fileuploaddone', func);

            // Callback for failed (abort or error) uploads:
            // fail: function (e, data) {}, // .bind('fileuploadfail', func);

            // Callback for completed (success, abort or error) requests:
            // always: function (e, data) {}, // .bind('fileuploadalways', func);

            // Callback for upload progress events:
            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);

            // Callback for global upload progress events:
            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);

            // Callback for uploads start, equivalent to the global ajaxStart event:
            // start: function (e) {}, // .bind('fileuploadstart', func);

            // Callback for uploads stop, equivalent to the global ajaxStop event:
            // stop: function (e) {}, // .bind('fileuploadstop', func);

            // Callback for change events of the fileInput(s):
            // change: function (e, data) {}, // .bind('fileuploadchange', func);

            // Callback for paste events to the pasteZone(s):
            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);

            // Callback for drop events of the dropZone(s):
            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);

            // Callback for dragover events of the dropZone(s):
            // dragover: function (e) {}, // .bind('fileuploaddragover', func);

            // Callback for the start of each chunk upload request:
            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);

            // Callback for successful chunk uploads:
            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);

            // Callback for failed (abort or error) chunk uploads:
            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);

            // Callback for completed (success, abort or error) chunk upload requests:
            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);

            // The plugin options are used as settings object for the ajax calls.
            // The following are jQuery ajax settings required for the file uploads:
            processData: false,
            contentType: false,
            cache: false
        },

        // A list of options that require a refresh after assigning a new value:
        _refreshOptionsList: [
            'fileInput',
            'dropZone',
            'pasteZone',
            'multipart',
            'forceIframeTransport'
        ],

        _BitrateTimer: function () {
            this.timestamp = +(new Date());
            this.loaded = 0;
            this.bitrate = 0;
            this.getBitrate = function (now, loaded, interval) {
                var timeDiff = now - this.timestamp;
                if (!this.bitrate || !interval || timeDiff > interval) {
                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
                    this.loaded = loaded;
                    this.timestamp = now;
                }
                return this.bitrate;
            };
        },

        _isXHRUpload: function (options) {
            return !options.forceIframeTransport &&
                ((!options.multipart && $.support.xhrFileUpload) ||
                $.support.xhrFormDataFileUpload);
        },

        _getFormData: function (options) {
            var formData;
            if (typeof options.formData === 'function') {
                return options.formData(options.form);
            }
            if ($.isArray(options.formData)) {
                return options.formData;
            }
            if (options.formData) {
                formData = [];
                $.each(options.formData, function (name, value) {
                    formData.push({name: name, value: value});
                });
                return formData;
            }
            return [];
        },

        _getTotal: function (files) {
            var total = 0;
            $.each(files, function (index, file) {
                total += file.size || 1;
            });
            return total;
        },

        _initProgressObject: function (obj) {
            obj._progress = {
                loaded: 0,
                total: 0,
                bitrate: 0
            };
        },

        _onProgress: function (e, data) {
            if (e.lengthComputable) {
                var now = +(new Date()),
                    loaded;
                if (data._time && data.progressInterval &&
                        (now - data._time < data.progressInterval) &&
                        e.loaded !== e.total) {
                    return;
                }
                data._time = now;
                loaded = Math.floor(
                    e.loaded / e.total * (data.chunkSize || data._progress.total)
                ) + (data.uploadedBytes || 0);
                // Add the difference from the previously loaded state
                // to the global loaded counter:
                this._progress.loaded += (loaded - data._progress.loaded);
                this._progress.bitrate = this._bitrateTimer.getBitrate(
                    now,
                    this._progress.loaded,
                    data.bitrateInterval
                );
                data._progress.loaded = data.loaded = loaded;
                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(
                    now,
                    loaded,
                    data.bitrateInterval
                );
                // Trigger a custom progress event with a total data property set
                // to the file size(s) of the current upload and a loaded data
                // property calculated accordingly:
                this._trigger('progress', e, data);
                // Trigger a global progress event for all current file uploads,
                // including ajax calls queued for sequential file uploads:
                this._trigger('progressall', e, this._progress);
            }
        },

        _initProgressListener: function (options) {
            var that = this,
                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
            // Accesss to the native XHR object is required to add event listeners
            // for the upload progress event:
            if (xhr.upload) {
                $(xhr.upload).bind('progress', function (e) {
                    var oe = e.originalEvent;
                    // Make sure the progress event properties get copied over:
                    e.lengthComputable = oe.lengthComputable;
                    e.loaded = oe.loaded;
                    e.total = oe.total;
                    that._onProgress(e, options);
                });
                options.xhr = function () {
                    return xhr;
                };
            }
        },

        _initXHRData: function (options) {
            var formData,
                file = options.files[0],
                // Ignore non-multipart setting if not supported:
                multipart = options.multipart || !$.support.xhrFileUpload,
                paramName = options.paramName[0];
            options.headers = options.headers || {};
            if (options.contentRange) {
                options.headers['Content-Range'] = options.contentRange;
            }
            if (!multipart) {
                options.headers['Content-Disposition'] = 'attachment; filename="' +
                    encodeURI(file.name) + '"';
                options.contentType = file.type;
                options.data = options.blob || file;
            } else if ($.support.xhrFormDataFileUpload) {
                if (options.postMessage) {
                    // window.postMessage does not allow sending FormData
                    // objects, so we just add the File/Blob objects to
                    // the formData array and let the postMessage window
                    // create the FormData object out of this array:
                    formData = this._getFormData(options);
                    if (options.blob) {
                        formData.push({
                            name: paramName,
                            value: options.blob
                        });
                    } else {
                        $.each(options.files, function (index, file) {
                            formData.push({
                                name: options.paramName[index] || paramName,
                                value: file
                            });
                        });
                    }
                } else {
                    if (options.formData instanceof FormData) {
                        formData = options.formData;
                    } else {
                        formData = new FormData();
                        $.each(this._getFormData(options), function (index, field) {
                            formData.append(field.name, field.value);
                        });
                    }
                    if (options.blob) {
                        options.headers['Content-Disposition'] = 'attachment; filename="' +
                            encodeURI(file.name) + '"';
                        formData.append(paramName, options.blob, file.name);
                    } else {
                        $.each(options.files, function (index, file) {
                            // Files are also Blob instances, but some browsers
                            // (Firefox 3.6) support the File API but not Blobs.
                            // This check allows the tests to run with
                            // dummy objects:
                            if ((window.Blob && file instanceof Blob) ||
                                    (window.File && file instanceof File)) {
                                formData.append(
                                    options.paramName[index] || paramName,
                                    file,
                                    file.name
                                );
                            }
                        });
                    }
                }
                options.data = formData;
            }
            // Blob reference is not needed anymore, free memory:
            options.blob = null;
        },

        _initIframeSettings: function (options) {
            // Setting the dataType to iframe enables the iframe transport:
            options.dataType = 'iframe ' + (options.dataType || '');
            // The iframe transport accepts a serialized array as form data:
            options.formData = this._getFormData(options);
            // Add redirect url to form data on cross-domain uploads:
            if (options.redirect && $('<a></a>').prop('href', options.url)
                    .prop('host') !== location.host) {
                options.formData.push({
                    name: options.redirectParamName || 'redirect',
                    value: options.redirect
                });
            }
        },

        _initDataSettings: function (options) {
            if (this._isXHRUpload(options)) {
                if (!this._chunkedUpload(options, true)) {
                    if (!options.data) {
                        this._initXHRData(options);
                    }
                    this._initProgressListener(options);
                }
                if (options.postMessage) {
                    // Setting the dataType to postmessage enables the
                    // postMessage transport:
                    options.dataType = 'postmessage ' + (options.dataType || '');
                }
            } else {
                this._initIframeSettings(options, 'iframe');
            }
        },

        _getParamName: function (options) {
            var fileInput = $(options.fileInput),
                paramName = options.paramName;
            if (!paramName) {
                paramName = [];
                fileInput.each(function () {
                    var input = $(this),
                        name = input.prop('name') || 'files[]',
                        i = (input.prop('files') || [1]).length;
                    while (i) {
                        paramName.push(name);
                        i -= 1;
                    }
                });
                if (!paramName.length) {
                    paramName = [fileInput.prop('name') || 'files[]'];
                }
            } else if (!$.isArray(paramName)) {
                paramName = [paramName];
            }
            return paramName;
        },

        _initFormSettings: function (options) {
            // Retrieve missing options from the input field and the
            // associated form, if available:
            if (!options.form || !options.form.length) {
                options.form = $(options.fileInput.prop('form'));
                // If the given file input doesn't have an associated form,
                // use the default widget file input's form:
                if (!options.form.length) {
                    options.form = $(this.options.fileInput.prop('form'));
                }
            }
            options.paramName = this._getParamName(options);
            if (!options.url) {
                options.url = options.form.prop('action') || location.href;
            }
            // The HTTP request method must be "POST" or "PUT":
            options.type = (options.type || options.form.prop('method') || '')
                .toUpperCase();
            if (options.type !== 'POST' && options.type !== 'PUT' &&
                    options.type !== 'PATCH') {
                options.type = 'POST';
            }
            if (!options.formAcceptCharset) {
                options.formAcceptCharset = options.form.attr('accept-charset');
            }
        },

        _getAJAXSettings: function (data) {
            var options = $.extend({}, this.options, data);
            this._initFormSettings(options);
            this._initDataSettings(options);
            return options;
        },

        // jQuery 1.6 doesn't provide .state(),
        // while jQuery 1.8+ removed .isRejected() and .isResolved():
        _getDeferredState: function (deferred) {
            if (deferred.state) {
                return deferred.state();
            }
            if (deferred.isResolved()) {
                return 'resolved';
            }
            if (deferred.isRejected()) {
                return 'rejected';
            }
            return 'pending';
        },

        // Maps jqXHR callbacks to the equivalent
        // methods of the given Promise object:
        _enhancePromise: function (promise) {
            promise.success = promise.done;
            promise.error = promise.fail;
            promise.complete = promise.always;
            return promise;
        },

        // Creates and returns a Promise object enhanced with
        // the jqXHR methods abort, success, error and complete:
        _getXHRPromise: function (resolveOrReject, context, args) {
            var dfd = $.Deferred(),
                promise = dfd.promise();
            context = context || this.options.context || promise;
            if (resolveOrReject === true) {
                dfd.resolveWith(context, args);
            } else if (resolveOrReject === false) {
                dfd.rejectWith(context, args);
            }
            promise.abort = dfd.promise;
            return this._enhancePromise(promise);
        },

        // Adds convenience methods to the callback arguments:
        _addConvenienceMethods: function (e, data) {
            var that = this;
            data.submit = function () {
                if (this.state() !== 'pending') {
                    data.jqXHR = this.jqXHR =
                        (that._trigger('submit', e, this) !== false) &&
                        that._onSend(e, this);
                }
                return this.jqXHR || that._getXHRPromise();
            };
            data.abort = function () {
                if (this.jqXHR) {
                    return this.jqXHR.abort();
                }
                return this._getXHRPromise();
            };
            data.state = function () {
                if (this.jqXHR) {
                    return that._getDeferredState(this.jqXHR);
                }
            };
            data.progress = function () {
                return this._progress;
            };
        },

        // Parses the Range header from the server response
        // and returns the uploaded bytes:
        _getUploadedBytes: function (jqXHR) {
            var range = jqXHR.getResponseHeader('Range'),
                parts = range && range.split('-'),
                upperBytesPos = parts && parts.length > 1 &&
                    parseInt(parts[1], 10);
            return upperBytesPos && upperBytesPos + 1;
        },

        // Uploads a file in multiple, sequential requests
        // by splitting the file up in multiple blob chunks.
        // If the second parameter is true, only tests if the file
        // should be uploaded in chunks, but does not invoke any
        // upload requests:
        _chunkedUpload: function (options, testOnly) {
            var that = this,
                file = options.files[0],
                fs = file.size,
                ub = options.uploadedBytes = options.uploadedBytes || 0,
                mcs = options.maxChunkSize || fs,
                slice = file.slice || file.webkitSlice || file.mozSlice,
                dfd = $.Deferred(),
                promise = dfd.promise(),
                jqXHR,
                upload;
            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||
                    options.data) {
                return false;
            }
            if (testOnly) {
                return true;
            }
            if (ub >= fs) {
                file.error = 'Uploaded bytes exceed file size';
                return this._getXHRPromise(
                    false,
                    options.context,
                    [null, 'error', file.error]
                );
            }
            // The chunk upload method:
            upload = function () {
                // Clone the options object for each chunk upload:
                var o = $.extend({}, options),
                    currentLoaded = o._progress.loaded;
                o.blob = slice.call(
                    file,
                    ub,
                    ub + mcs,
                    file.type
                );
                // Store the current chunk size, as the blob itself
                // will be dereferenced after data processing:
                o.chunkSize = o.blob.size;
                // Expose the chunk bytes position range:
                o.contentRange = 'bytes ' + ub + '-' +
                    (ub + o.chunkSize - 1) + '/' + fs;
                // Process the upload data (the blob and potential form data):
                that._initXHRData(o);
                // Add progress listeners for this chunk upload:
                that._initProgressListener(o);
                jqXHR = ((that._trigger('chunksend', null, o) !== false && $.ajax(o)) ||
                        that._getXHRPromise(false, o.context))
                    .done(function (result, textStatus, jqXHR) {
                        ub = that._getUploadedBytes(jqXHR) ||
                            (ub + o.chunkSize);
                        // Create a progress event if no final progress event
                        // with loaded equaling total has been triggered
                        // for this chunk:
                        if (o._progress.loaded === currentLoaded) {
                            that._onProgress($.Event('progress', {
                                lengthComputable: true,
                                loaded: ub - o.uploadedBytes,
                                total: ub - o.uploadedBytes
                            }), o);
                        }
                        options.uploadedBytes = o.uploadedBytes = ub;
                        o.result = result;
                        o.textStatus = textStatus;
                        o.jqXHR = jqXHR;
                        that._trigger('chunkdone', null, o);
                        that._trigger('chunkalways', null, o);
                        if (ub < fs) {
                            // File upload not yet complete,
                            // continue with the next chunk:
                            upload();
                        } else {
                            dfd.resolveWith(
                                o.context,
                                [result, textStatus, jqXHR]
                            );
                        }
                    })
                    .fail(function (jqXHR, textStatus, errorThrown) {
                        o.jqXHR = jqXHR;
                        o.textStatus = textStatus;
                        o.errorThrown = errorThrown;
                        that._trigger('chunkfail', null, o);
                        that._trigger('chunkalways', null, o);
                        dfd.rejectWith(
                            o.context,
                            [jqXHR, textStatus, errorThrown]
                        );
                    });
            };
            this._enhancePromise(promise);
            promise.abort = function () {
                return jqXHR.abort();
            };
            upload();
            return promise;
        },

        _beforeSend: function (e, data) {
            if (this._active === 0) {
                // the start callback is triggered when an upload starts
                // and no other uploads are currently running,
                // equivalent to the global ajaxStart event:
                this._trigger('start');
                // Set timer for global bitrate progress calculation:
                this._bitrateTimer = new this._BitrateTimer();
                // Reset the global progress values:
                this._progress.loaded = this._progress.total = 0;
                this._progress.bitrate = 0;
            }
            if (!data._progress) {
                data._progress = {};
            }
            data._progress.loaded = data.loaded = data.uploadedBytes || 0;
            data._progress.total = data.total = this._getTotal(data.files) || 1;
            data._progress.bitrate = data.bitrate = 0;
            this._active += 1;
            // Initialize the global progress values:
            this._progress.loaded += data.loaded;
            this._progress.total += data.total;
        },

        _onDone: function (result, textStatus, jqXHR, options) {
            var total = options._progress.total;
            if (options._progress.loaded < total) {
                // Create a progress event if no final progress event
                // with loaded equaling total has been triggered:
                this._onProgress($.Event('progress', {
                    lengthComputable: true,
                    loaded: total,
                    total: total
                }), options);
            }
            options.result = result;
            options.textStatus = textStatus;
            options.jqXHR = jqXHR;
            this._trigger('done', null, options);
        },

        _onFail: function (jqXHR, textStatus, errorThrown, options) {
            options.jqXHR = jqXHR;
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            this._trigger('fail', null, options);
            if (options.recalculateProgress) {
                // Remove the failed (error or abort) file upload from
                // the global progress calculation:
                this._progress.loaded -= options._progress.loaded;
                this._progress.total -= options._progress.total;
            }
        },

        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
            // jqXHRorResult, textStatus and jqXHRorError are added to the
            // options object via done and fail callbacks
            this._active -= 1;
            this._trigger('always', null, options);
            if (this._active === 0) {
                // The stop callback is triggered when all uploads have
                // been completed, equivalent to the global ajaxStop event:
                this._trigger('stop');
            }
        },

        _onSend: function (e, data) {
            if (!data.submit) {
                this._addConvenienceMethods(e, data);
            }
            var that = this,
                jqXHR,
                aborted,
                slot,
                pipe,
                options = that._getAJAXSettings(data),
                send = function () {
                    that._sending += 1;
                    // Set timer for bitrate progress calculation:
                    options._bitrateTimer = new that._BitrateTimer();
                    jqXHR = jqXHR || (
                        ((aborted || that._trigger('send', e, options) === false) &&
                        that._getXHRPromise(false, options.context, aborted)) ||
                        that._chunkedUpload(options) || $.ajax(options)
                    ).done(function (result, textStatus, jqXHR) {
                        that._onDone(result, textStatus, jqXHR, options);
                    }).fail(function (jqXHR, textStatus, errorThrown) {
                        that._onFail(jqXHR, textStatus, errorThrown, options);
                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
                        that._sending -= 1;
                        that._onAlways(
                            jqXHRorResult,
                            textStatus,
                            jqXHRorError,
                            options
                        );
                        if (options.limitConcurrentUploads &&
                                options.limitConcurrentUploads > that._sending) {
                            // Start the next queued upload,
                            // that has not been aborted:
                            var nextSlot = that._slots.shift();
                            while (nextSlot) {
                                if (that._getDeferredState(nextSlot) === 'pending') {
                                    nextSlot.resolve();
                                    break;
                                }
                                nextSlot = that._slots.shift();
                            }
                        }
                    });
                    return jqXHR;
                };
            this._beforeSend(e, options);
            if (this.options.sequentialUploads ||
                    (this.options.limitConcurrentUploads &&
                    this.options.limitConcurrentUploads <= this._sending)) {
                if (this.options.limitConcurrentUploads > 1) {
                    slot = $.Deferred();
                    this._slots.push(slot);
                    pipe = slot.pipe(send);
                } else {
                    pipe = (this._sequence = this._sequence.pipe(send, send));
                }
                // Return the piped Promise object, enhanced with an abort method,
                // which is delegated to the jqXHR object of the current upload,
                // and jqXHR callbacks mapped to the equivalent Promise methods:
                pipe.abort = function () {
                    aborted = [undefined, 'abort', 'abort'];
                    if (!jqXHR) {
                        if (slot) {
                            slot.rejectWith(options.context, aborted);
                        }
                        return send();
                    }
                    return jqXHR.abort();
                };
                return this._enhancePromise(pipe);
            }
            return send();
        },

        _onAdd: function (e, data) {
            var that = this,
                result = true,
                options = $.extend({}, this.options, data),
                limit = options.limitMultiFileUploads,
                paramName = this._getParamName(options),
                paramNameSet,
                paramNameSlice,
                fileSet,
                i;
            if (!(options.singleFileUploads || limit) ||
                    !this._isXHRUpload(options)) {
                fileSet = [data.files];
                paramNameSet = [paramName];
            } else if (!options.singleFileUploads && limit) {
                fileSet = [];
                paramNameSet = [];
                for (i = 0; i < data.files.length; i += limit) {
                    fileSet.push(data.files.slice(i, i + limit));
                    paramNameSlice = paramName.slice(i, i + limit);
                    if (!paramNameSlice.length) {
                        paramNameSlice = paramName;
                    }
                    paramNameSet.push(paramNameSlice);
                }
            } else {
                paramNameSet = paramName;
            }
            data.originalFiles = data.files;
            $.each(fileSet || data.files, function (index, element) {
                var newData = $.extend({}, data);
                newData.files = fileSet ? element : [element];
                newData.paramName = paramNameSet[index];
                that._initProgressObject(newData);
                that._addConvenienceMethods(e, newData);
                result = that._trigger('add', e, newData);
                return result;
            });
            return result;
        },

        _replaceFileInput: function (input) {
            var inputClone = input.clone(true);
            $('<form></form>').append(inputClone)[0].reset();
            // Detaching allows to insert the fileInput on another form
            // without loosing the file input value:
            input.after(inputClone).detach();
            // Avoid memory leaks with the detached file input:
            $.cleanData(input.unbind('remove'));
            // Replace the original file input element in the fileInput
            // elements set with the clone, which has been copied including
            // event handlers:
            this.options.fileInput = this.options.fileInput.map(function (i, el) {
                if (el === input[0]) {
                    return inputClone[0];
                }
                return el;
            });
            // If the widget has been initialized on the file input itself,
            // override this.element with the file input clone:
            if (input[0] === this.element[0]) {
                this.element = inputClone;
            }
        },

        _handleFileTreeEntry: function (entry, path) {
            var that = this,
                dfd = $.Deferred(),
                errorHandler = function (e) {
                    if (e && !e.entry) {
                        e.entry = entry;
                    }
                    // Since $.when returns immediately if one
                    // Deferred is rejected, we use resolve instead.
                    // This allows valid files and invalid items
                    // to be returned together in one set:
                    dfd.resolve([e]);
                },
                dirReader;
            path = path || '';
            if (entry.isFile) {
                if (entry._file) {
                    // Workaround for Chrome bug #149735
                    entry._file.relativePath = path;
                    dfd.resolve(entry._file);
                } else {
                    entry.file(function (file) {
                        file.relativePath = path;
                        dfd.resolve(file);
                    }, errorHandler);
                }
            } else if (entry.isDirectory) {
                dirReader = entry.createReader();
                dirReader.readEntries(function (entries) {
                    that._handleFileTreeEntries(
                        entries,
                        path + entry.name + '/'
                    ).done(function (files) {
                        dfd.resolve(files);
                    }).fail(errorHandler);
                }, errorHandler);
            } else {
                // Return an empy list for file system items
                // other than files or directories:
                dfd.resolve([]);
            }
            return dfd.promise();
        },

        _handleFileTreeEntries: function (entries, path) {
            var that = this;
            return $.when.apply(
                $,
                $.map(entries, function (entry) {
                    return that._handleFileTreeEntry(entry, path);
                })
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _getDroppedFiles: function (dataTransfer) {
            dataTransfer = dataTransfer || {};
            var items = dataTransfer.items;
            if (items && items.length && (items[0].webkitGetAsEntry ||
                    items[0].getAsEntry)) {
                return this._handleFileTreeEntries(
                    $.map(items, function (item) {
                        var entry;
                        if (item.webkitGetAsEntry) {
                            entry = item.webkitGetAsEntry();
                            if (entry) {
                                // Workaround for Chrome bug #149735:
                                entry._file = item.getAsFile();
                            }
                            return entry;
                        }
                        return item.getAsEntry();
                    })
                );
            }
            return $.Deferred().resolve(
                $.makeArray(dataTransfer.files)
            ).promise();
        },

        _getSingleFileInputFiles: function (fileInput) {
            fileInput = $(fileInput);
            var entries = fileInput.prop('webkitEntries') ||
                    fileInput.prop('entries'),
                files,
                value;
            if (entries && entries.length) {
                return this._handleFileTreeEntries(entries);
            }
            files = $.makeArray(fileInput.prop('files'));
            if (!files.length) {
                value = fileInput.prop('value');
                if (!value) {
                    return $.Deferred().resolve([]).promise();
                }
                // If the files property is not available, the browser does not
                // support the File API and we add a pseudo File object with
                // the input value as name with path information removed:
                files = [{name: value.replace(/^.*\\/, '')}];
            } else if (files[0].name === undefined && files[0].fileName) {
                // File normalization for Safari 4 and Firefox 3:
                $.each(files, function (index, file) {
                    file.name = file.fileName;
                    file.size = file.fileSize;
                });
            }
            return $.Deferred().resolve(files).promise();
        },

        _getFileInputFiles: function (fileInput) {
            if (!(fileInput instanceof $) || fileInput.length === 1) {
                return this._getSingleFileInputFiles(fileInput);
            }
            return $.when.apply(
                $,
                $.map(fileInput, this._getSingleFileInputFiles)
            ).pipe(function () {
                return Array.prototype.concat.apply(
                    [],
                    arguments
                );
            });
        },

        _onChange: function (e) {
            var that = this,
                data = {
                    fileInput: $(e.target),
                    form: $(e.target.form)
                };
            this._getFileInputFiles(data.fileInput).always(function (files) {
                data.files = files;
                if (that.options.replaceFileInput) {
                    that._replaceFileInput(data.fileInput);
                }
                if (that._trigger('change', e, data) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onPaste: function (e) {
            var cbd = e.originalEvent.clipboardData,
                items = (cbd && cbd.items) || [],
                data = {files: []};
            $.each(items, function (index, item) {
                var file = item.getAsFile && item.getAsFile();
                if (file) {
                    data.files.push(file);
                }
            });
            if (this._trigger('paste', e, data) === false ||
                    this._onAdd(e, data) === false) {
                return false;
            }
        },

        _onDrop: function (e) {
            var that = this,
                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer,
                data = {};
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                e.preventDefault();
            }
            this._getDroppedFiles(dataTransfer).always(function (files) {
                data.files = files;
                if (that._trigger('drop', e, data) !== false) {
                    that._onAdd(e, data);
                }
            });
        },

        _onDragOver: function (e) {
            var dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer;
            if (this._trigger('dragover', e) === false) {
                return false;
            }
            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1) {
                dataTransfer.dropEffect = 'copy';
                e.preventDefault();
            }
        },

        _initEventHandlers: function () {
            if (this._isXHRUpload(this.options)) {
                this._on(this.options.dropZone, {
                    dragover: this._onDragOver,
                    drop: this._onDrop
                });
                this._on(this.options.pasteZone, {
                    paste: this._onPaste
                });
            }
            this._on(this.options.fileInput, {
                change: this._onChange
            });
        },

        _destroyEventHandlers: function () {
            this._off(this.options.dropZone, 'dragover drop');
            this._off(this.options.pasteZone, 'paste');
            this._off(this.options.fileInput, 'change');
        },

        _setOption: function (key, value) {
            var refresh = $.inArray(key, this._refreshOptionsList) !== -1;
            if (refresh) {
                this._destroyEventHandlers();
            }
            this._super(key, value);
            if (refresh) {
                this._initSpecialOptions();
                this._initEventHandlers();
            }
        },

        _initSpecialOptions: function () {
            var options = this.options;
            if (options.fileInput === undefined) {
                options.fileInput = this.element.is('input[type="file"]') ?
                        this.element : this.element.find('input[type="file"]');
            } else if (!(options.fileInput instanceof $)) {
                options.fileInput = $(options.fileInput);
            }
            if (!(options.dropZone instanceof $)) {
                options.dropZone = $(options.dropZone);
            }
            if (!(options.pasteZone instanceof $)) {
                options.pasteZone = $(options.pasteZone);
            }
        },

        _create: function () {
            var options = this.options;
            // Initialize options set via HTML5 data-attributes:
            $.extend(options, $(this.element[0].cloneNode(false)).data());
            this._initSpecialOptions();
            this._slots = [];
            this._sequence = this._getXHRPromise(true);
            this._sending = this._active = 0;
            this._initProgressObject(this);
            this._initEventHandlers();
        },

        // This method is exposed to the widget API and allows to query
        // the widget upload progress.
        // It returns an object with loaded, total and bitrate properties
        // for the running uploads:
        progress: function () {
            return this._progress;
        },

        // This method is exposed to the widget API and allows adding files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files property and can contain additional options:
        // .fileupload('add', {files: filesList});
        add: function (data) {
            var that = this;
            if (!data || this.options.disabled) {
                return;
            }
            if (data.fileInput && !data.files) {
                this._getFileInputFiles(data.fileInput).always(function (files) {
                    data.files = files;
                    that._onAdd(null, data);
                });
            } else {
                data.files = $.makeArray(data.files);
                this._onAdd(null, data);
            }
        },

        // This method is exposed to the widget API and allows sending files
        // using the fileupload API. The data parameter accepts an object which
        // must have a files or fileInput property and can contain additional options:
        // .fileupload('send', {files: filesList});
        // The method returns a Promise object for the file upload call.
        send: function (data) {
            if (data && !this.options.disabled) {
                if (data.fileInput && !data.files) {
                    var that = this,
                        dfd = $.Deferred(),
                        promise = dfd.promise(),
                        jqXHR,
                        aborted;
                    promise.abort = function () {
                        aborted = true;
                        if (jqXHR) {
                            return jqXHR.abort();
                        }
                        dfd.reject(null, 'abort', 'abort');
                        return promise;
                    };
                    this._getFileInputFiles(data.fileInput).always(
                        function (files) {
                            if (aborted) {
                                return;
                            }
                            data.files = files;
                            jqXHR = that._onSend(null, data).then(
                                function (result, textStatus, jqXHR) {
                                    dfd.resolve(result, textStatus, jqXHR);
                                },
                                function (jqXHR, textStatus, errorThrown) {
                                    dfd.reject(jqXHR, textStatus, errorThrown);
                                }
                            );
                        }
                    );
                    return this._enhancePromise(promise);
                }
                data.files = $.makeArray(data.files);
                if (data.files.length) {
                    return this._onSend(null, data);
                }
            }
            return this._getXHRPromise(false, data && data.context);
        }

    });

}));


(function () {

    var _LOADMORECLASS = 'sl-load-more';   

    var ScrollLoadMore = function (selector, options) {
        this.options = Object.assign({
            offset: 100,   // Vng bao xc nh scroll thuc bottom hoc top tnh theo px
            fireDelay: 0,   // Thi gian delay trc khi gi callback, t 0  b delay.
            direction: 'next' // hng scroll to load.
        }, options || {});

        this.$container = typeof selector === 'string' ? document.querySelector(selector) : selector;

        this.callback = this.options.callback;

        if (!this.$container || this.$container.hasScrollLoadMore) {
            return;
        }

        this.$container.hasScrollLoadMore = true;

        this._init();
    };

    ScrollLoadMore.prototype._init = function () {
        this.containerBottom = this.$container.getBoundingClientRect().bottom;
        this.containerTop = this.$container.getBoundingClientRect().top;

        this.lastScrollTop = this.$container.scrollTop;
        this.$loadMoreElement = this._ensureLoadmoreElement();

        this.onScrolling = false;
        this.rafId = null;
        this.timer = null;

        this.onFiring = false; 			// ang chy callback

        this.$container.addEventListener('scroll', this._scrollHandler.bind(this));
    }

    ScrollLoadMore.prototype._scrollHandler = function () {
        this.timer && clearTimeout(this.timer);
        this.onScrolling = true;

        !this.rafId && this._startChecking();

        this.timer = window.setTimeout(function () {
            this.onScrolling = false;
            this._stopChecking();
        }.bind(this), 250);
    }

    ScrollLoadMore.prototype._scrollFire = function () {
        if (this._hasFire()) {
            this._stopChecking();
            this._callback();
            return;
        }

        this.onFiring = false;
        this.rafId = requestAnimationFrame(this._scrollFire.bind(this));
    }

    ScrollLoadMore.prototype._hasFire = function () {
        var bound = this.$loadMoreElement.getBoundingClientRect();
        return this.options.direction === 'next' ? (bound.bottom <= this.containerBottom + this.options.offset)
					: (bound.bottom >= this.containerTop - this.options.offset);
    }

    ScrollLoadMore.prototype._callback = function () {
        if (this.onFiring || typeof this.callback !== 'function') return;

        (this.onFiring = true) && setTimeout(function () { this.callback(); }.bind(this), this.options.fireDelay);
    }

    ScrollLoadMore.prototype._ensureLoadmoreElement = function () {
        var loadmoreElement = this.$container.getElementsByClassName(_LOADMORECLASS), result;
        if (loadmoreElement && loadmoreElement.length > 0) return loadmoreElement[0];

        result = document.createElement("div");
        result.classList.add(_LOADMORECLASS);
        result.style.height = "1px";
        result.style.width = "100%";
        result.style.background = "transparent";
        result.style.border = "none";

        this.options.direction === 'next' ? this.$container.append(result) : this.$container.prepend(result);
        return result;
    }

    ScrollLoadMore.prototype._startChecking = function () {
        this.onScrolling && (this.rafId = requestAnimationFrame(this._scrollFire.bind(this)));
    }

    ScrollLoadMore.prototype._stopChecking = function () {
        this.rafId && cancelAnimationFrame(this.rafId);
        this.rafId = null;
    }

    window.ScrollLoadMore = ScrollLoadMore;
})();
function getColorCode(n){return n?(n.toUpperCase().charCodeAt(0)+randomInt)%10:randomInt%10}function getDefaultAvatar(){egov.mobile&&(title=egov.mobile.avatarTheme);switch(title){case"troll":return String.format(getResource("egov.resources.avatar.troll"),Math.floor(Math.random()*6)+1);case"icon":return String.format(getResource("egov.resources.avatar.icon"),Math.floor(Math.random()*2)+1);case"alphabet":return String.format(getResource("egov.resources.avatar.alphabet"),account[0].toLowerCase());default:return getResource("egov.resources.avatar.noData")}}function getUserAvatar(n,t){return n?String.format(egov.resources.avatar.path,t):getDefaultAvatar()}function getErrorAvatar(){return getResource("egov.resources.avatar.errorUrl")}jQuery.fn.bindResources=function(n,isNotRemoveDataRes){isNotRemoveDataRes=!0;var t=this.find("*[data-res]"),i=this.find("*[data-restitle]"),r=this.find("*[data-respholder]");return(t.length>0||i.length>0||r.length>0)&&($.each(t,function(i,ele){var res=$(ele).attr("data-res"),eleVal,texts;try{eval(res)?(isNotRemoveDataRes||$(ele).removeAttr("data-res"),$(ele).prop("tagName").toLowerCase()==="input"?(eleVal=$(ele).val().trim(),$(ele).val(eval(res))):(eleVal=$(ele).text().trim(),$(ele).text(eval(res)))):console.log(res)}catch(e){texts=JSON.stringify(res).split(".");texts=texts[texts.length-2]+"."+texts[texts.length-1];isNotRemoveDataRes||$(ele).removeAttr("data-res");$(ele).prop("tagName").toLowerCase()==="input"?$(ele).val(texts):$(ele).text(texts);console.log(res)}}),$.each(i,function(i,ele){var res=$(ele).attr("data-restitle"),texts;try{eval(res)&&(isNotRemoveDataRes||$(ele).removeAttr("data-restitle"),$(ele).attr("title",eval(res)))}catch(e){texts=JSON.stringify(res).split(".");texts=texts[texts.length-2]+"."+texts[texts.length-1];isNotRemoveDataRes||$(ele).removeAttr("data-restitle");$(ele).attr("title",texts);console.log(res)}}),$.each(r,function(i,ele){var res=$(ele).attr("data-respholder"),texts;try{eval(res)?(isNotRemoveDataRes||$(ele).removeAttr("data-respholder"),$(ele).attr("placeholder",eval(res))):console.log(res)}catch(e){texts=JSON.stringify(res).split(".");texts=texts[texts.length-2]+"."+texts[texts.length-1];isNotRemoveDataRes||$(ele).removeAttr("data-respholder");$(ele).attr("placeholder",texts);console.log(res)}})),typeof n=="function"&&n(),this};window.getResource=function(resourceKey){try{return eval(resourceKey)}catch(e){return resourceKey}};var extend=function(n,t){for(var i in t)t[i]&&t[i].constructor&&t[i].constructor===Object?(n[i]=n[i]||{},arguments.callee(n[i],t[i])):n[i]=t[i];return n},randomInt=Math.floor(Math.random()*10);

(function (window, egov, bmail) {
    var extend = function (destination, source) {
        /// <summary>
        /// Hm extend  thm resource
        /// </summary>
        /// <param name="destination"></param>
        /// <param name="source"></param>
        for (var property in source) {
            if (source[property] && source[property].constructor &&
             source[property].constructor === Object) {
                destination[property] = destination[property] || {};
                arguments.callee(destination[property], source[property]);
            } else {
                destination[property] = source[property];
            }
        }
        return destination;
    };
    //#region Version 1.0 -  dch khng thm resource mi vo y

    egov.resources = {
        document: {
            Compendium: "Trch yu",
            Comment: " kin x l",
            DocType: "Loi bo co",
            Category: "Hnh thc",
            InOutPlace: "n v",
            DateAppointed: "Thi hn XL",
            Organization: "C quan gi",
            DocCode: "S/k hiu *",
            DocCode2: "S hiu *",
            DateArrived: "Ngy n",
            DateResponse: "Hn hi bo",
            DatePublished: "Ngy ban hnh",
            Docfield: "Lnh vc",
            StoreId: "S bo co",
            InOutCode: "S n",
            TotalPage: "S trang",
            ChooseTotalPage: "Chn s trang",
            DocField: "Lnh vc",
            Keyword: "T kha",
            SendType: "Hnh thc gi",
            DocCode1: "M h s",
            CitizenName: "Tn cng dn",
            Address: "a ch",
            Phone: "S in thoi",
            DocPapers: "Giy t thu",
            IdentityCard: "S CMT",
            Email: "Th in t",
            Commune: "X phng",
            AttachmentList: "File nh km",
            RelationList: "bo co lin quan",
            BusinessLicense: "Giy php ng k",
            cbDetail: "Hin th chi tit bo co n",
            AllComment: "Ni dung x l",
            titleContent: "Ni dung bo co",
            Urgent: {
                name: " khn",
                normal: "Thng",
                fast: "Khn",
                important: "Ha tc"
            },
            SecurityId: {
                name: " mt",
                normal: "Thng",
                high: "Mt",
                important: "Ti mt",
                highest: "Tuyt mt",
            },
            CompendiumTitle: "Nhp trch yu.",
            NoComment: "Cha cho  kin",
            DisplayForm: "Hin th biu mu",
            StorePrivate: "H s c nhn",
            StoreShare: "H s chia s",
            Note: "Ghi ch",
            nextPage: "Trang tip",
            prePage: "Trang trc",
            currentPage: "Trang 1",
            btnFinish: "Kt thc",
            viewIconTraKetQua: "Tr kt qu",
            viewIconTiepNhanBoSung: "Tip nhn b sung",
            viewIconHuyVanBan: "Hy",
            viewIconLuu: "Lu s",
            viewIconGuiykien: "Gi  kin",
            viewIconThongbao: "Thng bo",
            viewIconXinykien: "Xin  kin",
            viewIconYeuCauBoSung: "Yu cu b sung",
            viewIconGiaHanXuLy: "Gia hn",
            no: "T chi",
            yes: "ng ",
            btnInsertRelation: "bo co lin quan...",
            btnInsertAttachment: "Tp nh km",
            btnInsertScan: "Tp scan...",
            btnPaper: "Giy php...",
            btnInsertAnticipate: "D kin chuyn...",
            btnTransfer: "Chuyn bo co/h s",
            btnEdit: "Sa ni dung bo co/h s",
            btnInsertFile: "nh km",
            btnApproverYes: "ng  ph duyt",
            btnApproverNo: "T chi ph duyt",
            btnDestroy: "Hy bo co/h s",
            viewIconKetthuc: "",
            btnFinishtt: "Kt thc",
            btnAnswer: "Tr li",
            btnChangeDoctype: "Phn loi",
            concurrency: "Vnd",
            UserComment: "Ngi x l",
            filename: "Tn tp",
            filesize: "Kch thc",
            fileversion: "Phin bn",
            lastUpdateFile: "Cp nht cui",
            FinalComment: " kin gii quyt",
            backtolist: "Quay li danh sch",
            'delete': "Xa",
            MainProcess: "X l chnh:",
            CoProcess: "ng x l:",
            sendTo: "Chuyn ti",
            thongbao: "Thng bo:",
            xinykien: "Xin  kin:",
            view: "Xem",
            download: "Ti v",
            PersonInfo: "Tn CD/DN:",
            toolbar: {
                noaction: "Khng c hng chuyn tip theo.",
                transferByDk: "Chuyn theo d kin",
                transferUserDk: "Chuyn ngi nhn d kin",
                controlName: {
                    transferDoc: {
                        name: "Chuyn",
                        message: {
                            error: "C li xy ra khi ti danh sch hng chuyn"
                        },
                        item: {
                            cancel: {
                                name: "Khng tm thy hng chuyn tip theo"
                            },
                            transferplan: {
                                name: "Chuyn theo d kin"
                            },
                            newtransferplan: {
                                name: "Chuyn ngi nhn d kin"
                            }
                        }
                    },
                    edit: {
                        name: "Sa"
                    },
                    insert: {
                        name: "Chn",
                        message: {
                            error: "C li xy ra"
                        }
                    },
                    reload: {
                        name: "Ti li"
                    },
                    approverYes: {
                        name: "ng "
                    },
                    approverNo: {
                        name: "T chi"
                    },
                    remove: {
                        name: "Hy"
                    },
                    tiepNhanBoSung: {
                        name: "Yu cu b sung"
                    },
                    'return': {
                        name: "Tr kt qu"
                    },
                    finish: {
                        name: "Kt thc"
                    },
                    traloi: {
                        name: "Tr li",
                        hoso: "H s mi",
                        document: "bo co mi",
                        message: {
                            error: "C li xy ra khi ti danh sch phn loi"
                        }
                    },
                    phanloai: {
                        name: "Phn loi",
                        callBackTitle: "Chn loi bo co/h s",
                        message: {
                            error: "C li xy ra khi ti danh sch phn loi"
                        }
                    },
                    print: {
                        name: "In",
                        message: {
                            error: "C li xy ra khi ti danh sch in!."
                        }
                    },
                    giahan: {
                        name: "In"
                    },
                    xinykien: {
                        name: "Xin  kin"
                    },
                    thongbao: {
                        name: "Thng bo"
                    },
                    guiykien: {
                        name: "Gi  kin"
                    },
                    savePrivateStore: {
                        name: "Lu s"
                    },
                    others: {
                        name: "Khc"
                    }
                }
            },
            content: {
                version: "Xem phin bn ca {0} cp nht lc {1}"
            },
            relation: {
                titleDialog: "Thm bo co lin quan",
                confirmRelationTitle: "Xc nhn gi km bo co lin quan",
                ignoreConfirm: "Lun gi, khng hin th li thng bo ny ln sau.",
                contextmenu: {
                    open: "M bo co",
                    'delete': "Xa bo co"
                },
                documentNotExist: "bo co khng tn ti!"
            },
            attachment: {
                uploading: "ang ti tp ln",
                uploadSuccess: "Ti tp ln thnh cng!.",
                uploadError: "C li xy ra khi ti tp ln",
                fileChanged: "<strong>Tp {0} c s thay i</strong><br/>Bn c mun lu li kh",
                errorDownload: "C li xy ra khi ti tp.",
                openFile: "M",
                deleteFile: "Xa",
                restoreFile: "Phc hi tp  xa",
                download: "Ti v",
                removed: "( loi b)",
                using: "ang s dng",
                version: "Phin bn {0} cp nht lc {1}",
                closeProgramBeforeSave: "Bn phi ng cc chng trnh ang m tp nh km trc khi lu.",
                fileIsRemoved: "Tp  b xa",
                existFile: "Trng tn tp nh km",
                replaceOrNo: "Bn c mun lu phin bn mi cho tp <span style='color: #7A3807;'",
                'new': "mi",
                notEqualName: "Tp ti ln khng khp vi tp tin hin ti",
                confirmToUploadWithOtherName: "Tp tin <span style='color: #7A3807;'>'{0}'</span> ti ln khng ph"
            },
            transfer: {
                transferButton: "Chuyn",
                dialogTitle: "Bn giao bo co",
                noUser: "Cha chn ngi nhn x l",
                transferSuccess: "Chuyn bo co thnh cng.",
                transferError: "C li trong qu trnh bn giao.",
                noUserByAction: "Hng chuyn khng c ngi nhn",
                sendAll: "Tt c mi ngi",
                answerSuccess: "Tr li thnh cng.",
                answerFail: "C li trong qu trnh tr li  kin.",
                showDgTitle: "Hin th giao din chn cn b khc",
                noXlc: "Cha chn cn b x l",
                userList: "Danh sch nhn bo co",
                quicktransfer: "Chuyn nhanh",
                detail: "Chi tit",
                'extends': "Nng cao"
            },
            publishment: {
                dialogTitle: "Pht hnh bo co",
                privateDialogTitle: "Lu s pht hnh ni b",
                publishButton: "Lu v Pht hnh",
                noAddressSelected: "Bn cha chn n v nhn bo co.",
                success: "Pht hnh bo co thnh cng.",
                error: "C li xy ra khi pht hnh. Vui lng th li.",
                addpublishment: "Thm d kin pht hnh"
            },
            ChangeDoctype: {
                hasChangeDateAppoint: "bo co/h s  c phn loi theo loi h s mi.</br>Bn c mu",
                success: "bo co/h s  c chuyn sang loi bo co {0}."
            },
            sendComment: {
                dialogButton: "Gi  kin",
                dialogTitle: "Nhp  kin",
                enterComment: "Bn cha nhp  kin x l",
                sendFail: "C li xy khi cho  kin, vui lng th li.",
                sendSuccess: "Gi  kin thnh cng",
                requireMessage: "Bn cha nhp  kin!"
            },
            announcement: {
                dialogTitle: "Thng bo",
                announcementButton: "Gi thng bo",
                sendSuccess: "Gi thng bo thnh cng.",
                sendFail: "Gi thng bo li, vui lng th li.",
                noReceiver: "Bn cha chn ngi nhn thng bo."
            },
            consult: {
                dialogTitle: "Xin  kin",
                consultButton: "Gi xin  kin",
                sendSuccess: "Gi xin  kin thnh cng.",
                sendFail: "Gi xin  kin li, vui lng th li.",
                noReceiver: "Bn cha chn ngi nhn xin  kin.",
                noComment: "Bn cha nhp  kin x l."
            },
            finish: {
                error: "Khng kt thc c bo co, vui lng th li.",
                success: "Kt thc bo co thnh cng",
                processing: "ang x l"
            },
            docStore: {
                dialogTitle: "Lu s c nhn",
                createNew: "To mi",
                saveButton: "Lu",
                notSaveButton: "Khng lu",
                noChooseStore: "Bn cha chn S c nhn",
                processing: "ang lu",
                success: "Lu thnh cng",
                error: "C li xy ra khi lu, vui lng th li"
            },
            hsmc: {
                documentResult: "Kt qu x l: ",
                noResult: "Cha duyt",
                resultOk: " duyt",
                resultDeny: "Khng duyt",
                removeResult: "Hy"
            },
            supplementary: {
                title: "Yu cu b sung",
                requiredTitle: "Thng tin b sung",
                paper: "Giy t b sung",
                fee: "L ph b sung",
                noAdditional: "Dn khng ti b sung",
                addPaper: "Thm giy t",
                addFee: "Thm l ph",
                newDateAppointed: "Tnh li ngy hn tr",
                addDay: "S ngy ",
                dateAppointed: "Hn tr: ",
                supplementType: {
                    renew: "Tnh li t u",
                    'continue': "Tip tc tnh",
                    add: "Cng thm ngy"
                },
                success: " b sung",
                updateAndPrintButton: "Cp nht v In bin nhn",
                name: "Yu cu b sung",
                undel: "Khi phc",
                del: "Hy",
                receivedRequire: "Yu cu b sung ln ",
                printTemplate: "In bin nhn",
                print: "In bin nhn",
                comment: " kin b sung",
                receivedTitle: "Tip nhn b sung",
                unsuccess: "Cha b sung",
                cancelReveiced: "Hy b sung",
                noComment: "Ch : xa trng  nhp liu ny  hy yu cu b sung ca chnh m",
                removeRequired: "Hy yu cu b sung ny",
                add: "Thm yu cu b sung",
                defaultComment: "Yu cu ng/b b sung cc loi giy t cn thiu",
                sendSuplementRequire: "Gi yu cu b sung",
                expireDate: "Hn b sung (ngy)"
            },
            print: {
                text: "In",
                quickPrint: "In nhanh",
                success: "In thnh cng : ",
                error: "C li xy ra khi in",
                inDoc: "Kh dc",
                inNgang: "Kh ngang",
                printer: "Chn my in",
                copies: "S bn in",
                landscape: "B cc",
                isNotCreated: "Phiu tip nhn ch in c khi tip nhn bo co",
                processing: "ang in"
            },
            renewals: {
                renewalsButton: "Gia hn",
                renewalsAndPrintButton: "Gia hn v In phiu",
                dialogTitle: "Gia hn x l",
                renewalsReason: "L do gia hn",
                newDateAppoint: "Hn x l mi",
                printTemplate: "Mu in",
                noPrintTemplate: "Khng c mu in gia hn",
                renewalsType: "Chn hnh thc gia hn",
                renewalsStaffOverdue: "Gia hn x l c nhn",
                renewalsDocOverdue: "Gia hn hn tr h s",
                error: "Gia hn khng thnh cng, vui lng th li!"
            },
            updateLastResult: {
                ok: "Duyt",
                deny: "Khng duyt",
                comment: " kin x l:",
                code: "S n:",
                datePublish: "Ngy pht hnh:",
                dialogTitle: "Cp nht kt qu x l"
            },
            returnResult: {
                dialogTitle: "Tr kt qu",
                updateAndPrintButton: "In v tr kt qu",
                updateButton: "Tr kt qu",
                needToUpdateSupplementary: "H s ang c yu cu b sung, Bn cn cp nht kt qu b sung tr",
                needToUpdateLastResult: "H s cha c kt qu x l cui cng, Bn cn cp nht kt qu x ",
                resultOk: "ng ",
                resultDeny: "T chi",
                result: "Kt qu x l: ",
                personGive: "Thng tin cng dn nhn kt qu",
                finish: " Kt thc x l h s",
                printTemplate: "Mu in",
                finishAfterReturn: "Kt thc x l h s sau khi tr kt qu."
            },
            documentOnline: {
                acceptSuccess: "Tip nhn bo co ng k qua mng thnh cng",
                checkCitizenInfo: "Kim tra thng tin cng dn",
                noData: "Khng c d liu lin quan",
                getExistDocumentError: "C li trong qu trnh tm kim d liu",
                checkRefDocument: "Xem h s lin quan",
                insertRelations: "Thm bo co lin quan",
                insertRejectComment: "Nhp l do t chi tip nhn h s"
            },
            confirmDestroy: "Bn c chc mun hy bo co ny?",
            xlcLabel: "X l chnh: ",
            dxlLabel: "ng gi: ",
            xykLabel: "Xin  kin: ",
            gsLabel: "Gim st: ",
            thongbaoLabel: "Thng bo: ",
            errorLoadPrivateStore: "C li xy ra khi ti danh sch h s c nhn",
            saveSuccess: "Lu h s thnh cng",
            ignoreConfirmRelation: "Khng hi li",
            ignoreConfirmRelationWarning: "C th chnh li config ny bng cch vo Thit lp->Cu hnh khc-",
            checkAll: "Chn tt c",
            displayAllComment: "Xem cc  kin khc...",
            displayOnly3Coment: "n bt  kin x l",
            addAnticipate: "Thm d kin",
            require: "Yu cu",
            hasSpellError: "Pht hin li chnh t. Chn \"C\" nu mun tip tc, chn \"Khng",
            errorSpell: {
                add: "Thm vo th vin chnh t",
                addSuccess: "Thm thnh cng",
                addError: "C li xy ra"
            },
            notpermission: "Bn khng c quyn xem bo co ny!",
            openError: "Khng m c bo co lin quan",
            configError: "Cu hnh khng ng, vui lng th li",
            saveViolateSuccess: "Ghi nhn CBLC thnh cng",
            table: {
                stt: "STT",
                creater: "Ngi son tho",
                datecreate: "Ngy to",
                exprisedate: "Ngy ht hn",
                lastcomment: " kin x l cui",
                docCode: "S k hiu",
                dateRecieved: "Ngy nhn",
                idCard: "S CMND",
                citizenName: "Tn c quan/doanh nghip",
                Phone: "in thoi",
                Email: "Email",
                address: "a ch",
                relationDocsNumber: "{0} bo co lin quan"
            },
            transferError: "Cng vn c li khi chuyn",
            addtime: {
                numberonly: "Thi gian gia hn phi l s."
            },
            report: {
                exprort: "Xut ra file",
                group: "Nhm"
            },
            anticipate: {
                name: "D kin chuyn",
                receive: "Hng nhn",
                choosereceive: "Chn hng nhn",
                receiver: "Ngi nhn",
                choosereceiver: "Chn ngi nhn",
                anticipate: "Hng d kin",
                chooseanticipate: "Chn hng d kin"
            },
            PlaceLabel: "Ni nhn",
            PublishMail: "Email nhn",
            OfficeName: "Tn c quan",
            PlaceInOffice: "Ni nhn trong n v",
            Approvers: "Ngi k",
            DocInPage: "S.bn / s.trang",
            InPlace: "Ni lu bn gc",
            publishReceive: "Danh sch nhn bo co",
            UserNameReturned: "Ngi tr kt qu",
            DateReturned: "Ngy kt thc x l",
            DateSuccess: "Ngy k duyt",
            DateReceived: "Ngy tip nhn",
            contextmenu: {
                copyText: "Copy",
                selectAll: "Chn tt c"
            },
            documentInfo: "Thng tin h s",
            citizenInfo: "Thng tin cng dn",
            noCitizenIdCardNumber: "Cha c CMT",
            noCitizenFullName: "Cha c h tn",
            noCitizenEmail: "Cha c Email",
            addcomment: "Thm  kin",
            Content: "Ni dung",
            Original: "Ngun n",
            hasauthentication: "Thm quyn",
            iscomplain: "Phn loi n",
            publicResult: {
                titleDialog: "Cp nht kt qu gii quyt khiu ni, t co",
                updateButton: "Xc nhn",
                finish: "Kt thc x l h s",
                finalResult: "Kt qu gii quyt",
                dateAppoint: "Ngy hn tip",
                isAllowPublic: "Cho php cng b kt qu",
                hasresult: " cp nht kt qu x l ln cui ngy:"
            },
            dateCreated: "Ngy tip nhn",
            changeDateCreated: "Thay i ngy tip nhn",
            changeDateCreatedDialog: {
                title: "Thay i ngy tip nhn",
                submitBtn: "Thay i",
                closeBtn: "B qua",
                delayReason: "L do thay i",
                dateCreated: "Ngy tip nhn",
                applyAll: "Lu ti cho ln tip nhn tip theo(khi nhn hng chuyn Tip nhn"
            },
            docPaper: {
                receivedCount: "giy t",
                viewPapers: "xem"
            },
            docFee: {
                viewFees: "xem",
                title: "L ph"
            },
            changeWorkflowTypesDialog: {
                title: "Thay i loi h s",
                submitBtn: "Thay i",
                closeBtn: "B qua",
                stt: "STT",
                name: "Loi h s",
                expireProcess: "Hn gi",
                day: "Ngy",
                select: "Chn"
            },
            documentOnlineStatus: {
                label: "Trng thi",
                choDuyet: "Ch duyt",
                dangXuLy: "ang x l",
                choBoSung: "Ch b sung",
                choThanhToan: "Ch thanh ton",
                choTraKetQua: "Ch tr kt qu",
                daTraKetQua: " tr kt qu",
                biTuChoi: "B t chi"
            },
            delayReason: "L do mun",
            deleteDelayReason: "Xa",
            approver: {
                label: "K duyt",
                accept: "ng ",
                denied: "T chi",
                delApprover: "Xa"
            },
            lienthong: {
                dialogTitle: "Lin thng bo co",
                sendButton: "Gi lin thng",
                noAddressChoised: "Cha chn c quan nhn",
                sendSuccess: "Gi bo co lin thng thnh cng",
                sendFail: "Gi bo co lin thng li, vui lng th li sau."
            },
            changeWorkflowType: "Thay i hn x l theo loi",
            addCommonComment: "Thm  kin thng dng",
            selectCommonComment: "Chn t mu",
            create: {
                unpin: "B gn",
                pin: "Gn ln trn u"
            },
            hasReceived: "H s  tip nhn",
            isWaitting: "H s ang ng k",
            appoint: {
                titleDialog: "To lch tip cng dn",
                updateButton: "Cp nht",
                dateAppoint: "Ngy hn tip",
                appointExist: " c lch hn",
                remind: "Ghi ch/Nhc nh",
                createAppointSuccess: "t lch thnh cng",
                updateAppointSuccess: "t li lch thnh cng",
                number: "Ln gp th"
            },
            validateEmail: "Mail khng ng nh dng.",
            validatePhone: "S in thoi khng ng nh dng.",
            notExist: "bo co/h s khng tn ti. Vui lng xem li.",
            deleteDocPaperError: "C li xy ra khi xa giy t ca h s, vui lng th li."
        },
        documentQuickView: {
            belowDocumentSum: "Tm tt thng tin bo co",
            Comment: " kin x l:",
            timeComment: "lc",
            Category: "Loi bo co:",
            Docfield: "Lnh vc:",
            DocCode: "S k hiu:",
            Result: "Kt qu x l",
            LastUserComment: "Ngi x l cui:",
            Place: "Ni nhn bo co:",
            Sign: "Ngi k:",
            TotalPage: "S trang:",
            noDocumentSelected: "Chn bo co  hin th thng tin tm tt  y."
        },
        transfer: {
            ChoseOtherUser: "Chn cn b nhn khc",
            MainProcessUser: "Nhn bn chnh",
            MainProcessUserComment: "(x l chnh)",
            CoProcessUser: "Nhn bn sao",
            CoProcessUserComment: "(phi hp x l)",
            AnnouceUser: "Nhn thng bo",
            AnnouceUserComment: "( xem)",
            GiamsatUser: "Gim st",
            QuickSearchAccount: "Tm nhanh ti khon ca hng chuyn",
            AnnouncementPlace: "Ni nhn thng bo",
            PrivateAnoun: "Nhn thng bo",
            ConsultContent: "Ni dung xin  kin",
            ConsultUser: "Ngi xin  kin",
            MainProcess: "X l chnh",
            CoProcess: "ng x l",
            dgUserLabel: "(Chn c nhn, n v nhn bn sao)",
            dgUser: "C nhn, n v nhn bn sao",
            dgJobtitleLabel: "(Chn chc v v phng ban nhn bn sao)",
            dgJobtitle: "Chc v",
            dgDeptJob: "Phng ban",
            dgUserGiamsat: "(Chn cn b gim st)",
            allJobs: "Tt c chc v",
            sameDept: "Cng n v",
            isDg1: "Thng bo",
            isDg2: "ng gi",
            searchDgLabel: "C nhn nhn bn sao",
            allJobTitlesForDept: "Tt c cc chc danh",
            jobtitlesDeptPopup: "Chc danh thuc phng ban(n v)",
            jobtitleForAll: "Cp nhn bn sao( bit)",
            allJobTitles: "Tt c cc chc danh",
            IsThongbao: "Thng bo|",
            IsDxl: "ng x l |",
            IsAttachYk: "Gi km  kin gii quyt",
            TransferDocument: "Bn giao bo co",
            userList: "Danh sch nhn bo co",
            transferButton: "Chuyn",
            dialogTitle: "Bn giao bo co",
            noUser: "Cha chn ngi nhn x l",
            transferSuccess: "Chuyn bo co thnh cng.",
            transferError: "C li trong qu trnh bn giao.",
            noUserByAction: "Hng chuyn khng c ngi nhn",
            sendAll: "Tt c mi ngi",
            answerSuccess: "Tr li thnh cng.",
            answerFail: "C li trong qu trnh tr li  kin.",
            showDgTitle: "Hin th giao din chn cn b khc",
            noXlc: "Cha chn cn b x l",
            hsmsNoXlc: "Trn h s mt ca phi c ngi x l chnh. Vui lng xem li",
            HasNoneDocument: "Bn cha chn bo co!",
            messageNoBtn: "Khng",
            messageCancelBtn: "B qua",
            messageOkBtn: "ng ",
            dgUserLabelM: "C nhn, n v nhn bn sao",
            dgJobtitleLabelM: "Chc v nhn bn sao",
            dgDeptLabelM: "Phng ban nhn bn sao",
            dgUserGiamsatM: "Cn b gim st"
        },
        attachment: {
            view: "Xem",
            open: "Sa",
            del: "Xa",
            download: "Ti v",
            notPermision: "Bn khng c quyn thc hin thao tc ny",
            downloadAll: "Ti tt c"
        },
        storePrivate: {
            attachmentName: "Ti liu:",
            descStorePrivateAttachment: "M t:",
            storePrivateName: "Tn h s:",
            storePrivateNameWarning: "Nhp tn h s",
            userJoined: "Ngi tham gia:",
            delJoined: "Xa",
            descStorePrivate: "Ghi ch:"
        },
        relation: {
            open: "M",
            del: "Xa",
            view: "Xem chi tit"
        },
        toolbar: {
            XMLAttachment: "nh km file XML",
            codeManager: "Qun l m",
            DuKienPhatHanh: "D kin pht hnh",
            transferBtn: "Chuyn",
            editBtn: "Sa",
            attachBtn: "nh km",
            relation: "bo co lin quan...",
            attachment: "Tp nh km",
            scan: "Tp scan...",
            packet: "X l theo l",
            imagePacket: "Chn nh theo l",
            paper: "Giy php...",
            DuKienChuyen: "D kin chuyn...",
            reloadBtn: "Ti li",
            allow: "ng ",
            deny: "T chi",
            destroy: "Hy",
            TiepNhanBoSung: "Tip nhn b sung",
            TraKetQua: "Tr kt qu",
            CapNhatKetQua: "Cp nht kt qu",
            finish: "Kt thc",
            reply: "Tr li",
            PhanLoai: "Phn loi",
            print: "In",
            other: "Khc",
            GiaHan: "Gia hn",
            YeuCauBoSung: "Yu cu b sung",
            XinYKien: "Xin  kin...",
            btnAnnouncement: "Thng bo...",
            btnSendAnswer: "Gi  kin...",
            btnSaveStore: "Lu s..",
            sendMail: "Gi mail",
            sendSms: "Gi tin nhn",
            accept: "Tip nhn",
            reject: "T chi",
            additionalRequirements: "Yu cu b sung",
            checkCitizenInfo: "Kim tra thng tin cng dn",
            addnewtemplate: "Thm mu mi",
            btnSaveDraft: "Lu nhp",
            btnSave: "Cp nht",
            confirmTransferOrProcess: "Xc nhn bn giao",
            btnEditDocInfo: "Sa thng tin",
            appoint: "Hn tip",
            pdfPacket: "Chn pdf theo l",
            btnUndoFinish: "Ly li bo co",
            btnRePublish: "Pht hnh tip",
            invoice: "Bin lai",
            importinvoice: "Thm mi bin lai"
        },
        main: {
            gtv: "Kiu g",
            notifications: "Thng bo",
            news: "Tin iu hnh",
            newEmail: "Son th",
            config: "Thit lp",
            reply: "Gi phn hi",
            smallSize: "Xem c nh",
            mediumSize: "Xem c va",
            largeSize: "Xem c ln",
            underPreview: "Xem trc bn di",
            rightPreview: "Xem trc bn phi",
            hidePreview: "n xem trc",
            reload: "Khi ng li",
            logout: "ng xut",
            searchDocument: "Tm kim thng tin h s, bo co, tp nh km",
            searchFile: "Tm kim file nh km",
            reloadMessage: "Mt s thit lp yu cu phi reload li h thng. Bn c mun relo",
            closeBtn: "ng",
            submitBtn: "Cp nht",
            titleMessage: "Thng bo!",
            closeAll: "ng tt c li",
            report: "Bo co thng k",
            contacts: "S lin lc",
            calendar: "Lch",
            chat: "Chat",
            documents: "X l bo co",
            bmail: "Tin iu hnh",
            placeholderSearch: "Tm kim thng tin h s, bo co, tp nh km",
            links: "Lin kt",
            administrator: "Qun tr h thng",
            messageNoBtn: "Khng",
            emptyMailNotifications: "Bn khng c thng bo mail no",
            openAllMail: "M tt c mail nhn c",
            emptyChatNotifications: "Bn khng c tin nhn no",
            openAllChat: "M tt c tin nhn nhn c",
            emptyDocumentNotifications: "Bn khng c thng bo bo co no!",
            openAllDocument: "M tt c bo co c thng bo",
            haveNewDocument: "Bn c bo co mi",
            haveNewMail: "Bn c th mi",
            haveNewChat: "Bn c tin nhn mi",
            downloaddesktopversion: "Ti bn desktop",
            conversion: "Hi thoi",
            notJqueryAlert: "Cha c file jquery. Vui lng ti thm file jquery!",
            lblDocument: "bo co",
            lblNewConversion: "Hi thoi",
            lblNewWorkTime: "To lch",
            lblNewMail: "Son th",
            searchMail: "Tm kim mail",
            youHave: "Bn c",
            unreadDocuments: "bo co cha xem",
            installPlugin: {
                message: "Bn cn ci t eGov Plugin  s dng y  cc chc nng ca eGo",
                link: "Ti Plugin.",
                reDownload: "Ti li."
            }
        },
        index: {
            storePrivate: "H s cng vic",
            plugin: "ng dng",
            reportNode: "Bo co thng k",
            printNode: "In nhanh",
            reload: "ng b"
        },
        setting: {
            title: "Thit lp c nhn",
            ProfileConfig: "Thng tin c nhn",
            EnterCode: "Nhp m xc thc",
            Changepassword: "i mt khu",
            UserSetting: "Cu hnh phm tt",
            GeneralSettings: "Cu hnh khc",
            NotifySettings: "Trung tm thng bo",
            SignatureSetting: "Cu hnh ch k",
            btnUpdateSetting: "Cp nht",
            btnCloseSetting: "ng",
            AuthorizesSetting: "Cu hnh y quyn",
            notify: {
                documentNotify: "Thng bo bo co",
                BmailNotifyType: "Thng bo th in t",
                chat: "Thng bo hi thoi",
                mail: {
                    MailFolderNotify: "Danh sch cc th mc c nhn thng bo",
                },
                mobileconfig: "Cu hnh cho app eGov",
            },
            signature: {
                titleCreate: "Thm mi ch k",
                titleEdit: "Cp nht ch k",
                configPossition: "Cu hnh v tr t ch k",
                configOther: "Cu hnh khc",
                deleteMessage: "Bn c chc mun xa cu hnh ny",
                labelCreate: "Thm mi",
                table: {
                    header: {
                        stt: "STT",
                        configNameSignature: "Tn cu hnh",
                        wordsNeedFind: "T cn tm",
                        findTypes: "Loi tm kim",
                        signTypes: "Loi k",
                        position: "V tr",
                        edit: "Sa",
                        'delete': "Xa"
                    },
                    body: {
                        findTypeBottomToTop: "Di ln",
                        findTypeTopToBottom: "Trn xung",
                        imageSignature: "Ch k nh",
                        textSignature: "Ch k dng k t",
                        leftPosition: "Bn tri",
                        abovePosition: "Bn trn",
                        rightPosition: "Bn phi",
                        belowPosition: "Bn di",
                        noData: "Khng c d liu"
                    }
                }
            },
            authorize: {
                titleCreate: "Thm mi ngi nhn y quyn",
                titleEdit: "Cp nht ch k",
                labelCreate: "Thm mi",
                titleDialogDelete: "Thng bo!",
                confirmDelete: "Bn c chc mun xa cu hnh ny",
                btnSubmitDelete: "ng ",
                btnCancelDelete: "Hy",
                table: {
                    header: {
                        stt: "STT",
                        nameDocType: "Tn loi h s",
                        userReceive: "Ngi nhn y quyn",
                        startDate: "Ngy bt u",
                        endDate: "Ngy ht hn",
                        state: "Trng thi",
                        edit: "Sa",
                        'delete': "Xa"
                    },
                    body: {
                        noData: "Khng c d liu"
                    }
                }
            },
            general: {
                page: "Phn trang",
                scrollLoadData: "Cun chut  ti d liu",
                pagingLoadData: "Phn trang ti d liu",
                showDetailDocument: "Hin th chi tit bo co",
                showQuickView: "Hin th tm tt bo co",
                finishdocument: "Thit lp chung x l h s, bo co",
                setting: "Cu hnh Page trang ch",
                nofifysetting: "Cu hnh notify",
                displayAccount: "Hin th tn ngi dng",
                loadpagescroll: "Cun trang",
                loadpagesize: "Phn trang",
                language: "Ngn ng: ",
                useVietNameseTyping: "S dng b g Ting Vit",
                isFullQuickView: "Thit lp ch  xem tm tt bo co/h s",
                IsSaveOpenTab: "Cho php m li h s, bo co khi load li trang",
                HasHideLuuSo: "Cho php b qua lu s khi kt thc bo co",
                DisplayPopupTransferTheoLo: "Hin th popup cho  kin khi bn giao bo co theo l",
                ViewDocInPopUp: "Xem bo co  ca s mi",
                IgnoreConfirmRelation: "Lun gi tt c bo co nh km",
                HasPopupChat: "Chat bng ca s popup (dng phng to).",
                DocumentNotifyType: "Thng bo bo co",
                QuickView: "V tr hin th tm tt bo co",
                MudimMethod: "Kiu g",
                FontSize: "Cu hnh hin th c ch",
                DefaultPageSizeHome: "S bn ghi trn 1 trang mc nh",
                ListPageSizeHome: "Danh sch phn trang",
                PrinterName: "My in",
                Language: "Ngn ng",
                TypeChucVuChucDanh: "Hin th theo chc v hoc chc danh trong pht hnh bo co"
            },
            profile: {
                avatar: "nh i din",
                choseAvatar: "Chn",
                male: "Nam",
                female: "N",
                lastname: "H v tn m *",
                firstname: "Tn *",
                gender: "Gii tnh *",
                phone: "S in thoi",
                fax: "Fax",
                address: "a ch",
                entercode: "Nhp m"
            },
            login: {
                account: "Ti khon:",
                password: "Mt khu:",
                keepingLogin: "Duy tr ng nhp!",
                loginType: "Hnh thc ng nhp",
                forgetPassword: "Qun mt khu",
                choseServicer: "Hy chn 1 nh cung cp dch v OpenID:",
                loading: "ang x l...",
                btnLogin: "ng nhp",
                title: "NG NHP",
                username: "Tn ng nhp",
                capslockison: "Capslock ang bt",
                entercaptcha: "ng nhp sai qu s ln cho php, hy chng minh bn khng phi ro"
            },
            usersetting: {
                document: "bo co, h s",
                shortkey: "Phm tt",
                documentdefaultname: "Tn bo co, h s mc nh",
                supportkey: "Phm h tr",
                fnname: "Tn chc nng",
                generalconfig: "Cu hnh chung",
                selectdocument: "Chn bo co, h s"
            },
            sendemailto: "Gi email kim tra ti ",
            sendemailsuccess: "thnh cng!",
            sendemailfailure: "khng thnh cng!",
            smtpsetting: "Cu hnh my ch SMTP",
            othersetting: "Cu hnh khc",
            location: {
                addlocation: "Thm v tr",
                editlocation: "Sa v tr",
                confirmdeletefilelocation: "Bn chc chn mun xa v tr lu file ny ch?",
                canotdelete: "",
                listfilelocation: "Danh sc cc ni lu file",
                nodata: "Cha c cu hnh v tr lu file"
            },
            passwordpolicy: {
                checkpassword: "Kim tra c php mt khu",
                lookaccount: "Kha ti khon",
                passworddeadtime: "Ht hn mt khu",
                passwordchangehistory: "Lch s thay i mt khu",
                defaultpassword: "Mt khu mc nh",
                captchatext: "S dng ch: (V d: 'MADQES', 'JOMCOC', ...)",
                captchamath: "S dng biu thc ton hc: (V d: '4 + 5 =', '64 - 12 =', ...)",
                captchanote: "(b chn s dng thi gian kha)"
            },
            mail: {
                active: "Kch hot ch  gi mail"
            },
            changepassword: {
                currentpassword: "Mt khu hin ti *",
                newpassword: "Mt khu mi *",
                confirmpassword: "Xc nhn mt khu"
            },
            kntc: {
                enable: "Kch hot"
            }
        },
        scan: {
            rotateLeft: "Quay tri",
            rotateRight: "Quay phi",
            zoomIn: "Phng to",
            zoomOut: "Thu nh",
            setActualSize: "nh gc",
            crop: "Ct nh",
            setBrightnessUp: "Tng  sng",
            setBrightnessDown: "Gim  sng",
            setContrastUp: "Tng  tng phn",
            setContrastDown: "Gim  tng phn",
            addToContent: "a vo ni dung",
            pagePosition: "Trang: 0/0",
            preImage: "nh trc",
            nextImage: "nh sau",
            removeImageScan: "Xa",
            removeAllImageScan: "Xa tt c",
            listScannerLabel: "Chn my scan:",
            reloadListScanner: "Lm mi danh sch my scan",
            pixeltype: "Kiu mu",
            pixeltype2: "Mu",
            pixeltype0: "Mu xm",
            pixeltype1: "Mu en trng",
            resolution: " phn gii",
            resolution75: "75 dpi",
            resolution100: "100 dpi",
            resolution150: "150 dpi",
            resolution200: "200 dpi",
            resolution300: "300 dpi",
            duplex: "Qut 2 mt",
            showui: "Dng giao din ca my scan",
            filename: "Tn tp",
            imageformatLabel: "Lu tp dng",
            imageformatJPEG: "JPEG",
            imageformatPNG: "PNG",
            imageformatGIF: "GIF",
            imageformatTIFF: "TIFF",
            imageformatBMP: "BMP",
            imageformatPDF: "PDF",
            imageformatDOC: "DOC",
            acquire: "Qut nh",
            refresh: "Lm mi danh sch my scan",
            SaveFileAs: "Lu file di dng",
            selectScanMachine: "Chn my Scan",
            FileName: "Tn file",
            removeAllImageScantt: "Xa ton b"
        },
        tab: {
            close: "ng tab",
            home: {
                title: "bo co"
            },
            report: {
                title: "Bo co thng k"
            },
            print: {
                title: "In nhanh"
            },
            search: {
                title: "Tm kim"
            },
            setting: {
                title: "Thit lp"
            },
            saveDraft: "Bn c mun lu nhp li bo co ny?",
            saveChange: "bo co c thay i, bn c mun lu li khng?",
            newDocument: "bo co mi"
        },
        search: {
            compendium: "Trch yu",
            doccode: "S k hiu",
            inoutcode: "S n",
            content: "Ni dung",
            category: "Th loi vb",
            keyword: "T kha",
            urgent: " khn",
            storeprivate: "H s c nhn",
            store: "S bo co",
            categorybusiness: {
                name: "Nghip v",
                all: "Tt c",
                in: "bo co n",
                out: "bo co i",
                one: "H s mt ca"
            },
            InOutPlace: "n v x l",
            OrganizationCreate: "C/Q ban hnh",
            DocField: "Lnh vc",
            UserSuccess: "Ngi k",
            UserCreate: "Ngi khi to",
            CurrentUser: "Ngi gi",
            CurrentDepartment: "Phng ban gi",
            FromDateStr: "Ngy to",
            ToDateStr: "n ngy",
            FromPubDateStr: "Ngy ban hnh",
            showsearch: "Tm kim nng cao",
            createdate: "Ngy khi to",
            createdate1: "Ngy to",
            status: "Trng thi",
            status1: "ang d tho",
            status2: "ang x l",
            status4: " kt thc",
            status8: " hy",
            status16: "Dng x l",
            search: "Tm kim",
            searchnew: "Tm kim mi",
            order: "STT",
            searchnotfound: "Khng tm thy kt qu ph hp",
            view: "Xem",
            download: "Ti v",
            DidYouMean: "C phi bn mun tm",
            all: "Tt c",
            doccodePh: "Nhp s k hiu",
            inoutcodePh: "Nhp s n",
            contentPh: "Nhp ni dung",
            keywordPh: "Nhp t kha",
            error: "C li xy ra khi tm kim. Vui lng lin h qun tr mng.",
            noresult: "Khng tm thy kt qu",
            Compendiumph: "Nhp trch yu bo co",
            openattachmentfile: "M file nh km",
            downloadattachmentfile: "Ti file nh km"
        },
        common: {
            processing: "ang x l...",
            loading: "ang ti...",
            error: "C li xy ra",
            searching: "ang tm kim",
            closeButton: "ng",
            addButton: "Thm",
            editButton: "Sa",
            updateButton: "Cp nht",
            cancelButton: "B qua",
            deleleButton: "Xa",
            confirmButton: "Xc nhn",
            alert: "Thng bo",
            transfering: "ang chuyn",
            currencyUnit: "Vnd",
            save: "Lu",
            messageYesBtn: "C",
            messageNoBtn: "Khng",
            messageCancelBtn: "B qua",
            messageOkBtn: "ng ",
            errorMessage: "C li xy ra, vui lng th li hoc bo cho qun tr",
            saveBtn: "Lu",
            cancelBtn: "B qua",
            view: "Xem",
            updating: "ang cp nht ...",
            showPreviewPrint: "Hin th xem trc khi In"
        },
        file: {
            lenghtIsNotAllow: "File ti ln qu dung lng quy nh.",
            typeIsNotAllow: "File khng ng nh dng quy nh.",
            errorUpload: "C li xy ra khi ti tp ln.",
            errorDownload: "C li xy ra khi ti tp xung.",
            maxLength: "Dung lng ti a: ",
            notAcceptFileTypes: "Loi tp ny khng cho php ti ln"
        },
        home: {
            syncDataError: "C li khi ng b danh sch bo co",
            documentPreView: {
                tooltip: {
                    open: "Hin th tm tt bo co/h s",
                    close: "n tm tt bo co/h s"
                },
                control: {
                    close: "X",
                    open: "open"
                }
            },
            docType: {
                message: {
                    error: {
                        loading: "Khng ti c danh sch loi bo co!"
                    }
                }
            }
        },
        treeDocument: {
            message: {
                confirm: {},
                success: {},
                error: {
                    syncData: "Li khi ng b d liu!"
                }
            }
        },
        treeStore: {
            nameStorePrivateRoot: "H s c nhn",
            nameStoreShareRoot: "H s chia s",
            title: {
                createStore: "To s h s",
                detailSotore: "Xem chi tit",
                addStorePrivateAttachment: "Thm ti liu"
            },
            message: {
                confirm: {
                    openStore: "Bn c chc mun m h s ny khng?",
                    closeStore: "Bn c chc mun ng h s ny khng?",
                    deleteStore: "Bn c chc mun xa h s ny khng?"
                },
                success: {
                    openStore: "M h s thnh cng!",
                    closeStore: "ng h s thnh cng!",
                    deleteStore: "Xa h s thnh cng!"
                },
                error: {
                    createStore: "C li trong qu trnh to mi s h s",
                    updateStore: "C li trong qu trnh cp nht s h s",
                    selectStore: " C li xy ra khi ly d liu",
                    openStore: "C li khi m h s!",
                    closeStore: "C li khi ng h s!",
                    deleteStore: "C li khi xa h s!"
                }
            },
            contextmenu: {
                createStore: "To mi h s",
                updateStore: "Cp nht h s",
                deleteStore: "Xa h s",
                openStore: "M h s",
                closeStore: "ng h s",
                addStorePrivateAttachment: "Thm ti liu",
                messageCloseStore: "Bn c chc mun ng h s ny?.",
                messageOpenStore: "Bn c chc mun m h s ny?."
            }
        },
        documents: {
            title: {
                documentImportant: "B gn quan trng bo co ny",
                documentNotImportant: "Gn quan trng cho bo co ny",
                vanBanDongXuLy: "bo co ng x l",
                vanBanSapHetHan: "bo co sp ht hn (cn 1 ngy)",
                vanBanKhanHoacQuaHanXuLy: "bo co khn hoc qu hn x l",
                vanBanQuaHanHoiBao: "bo co qu hn hi bo",
                vanBanHoaToc: "bo co ha tc",
                vanBanThuong: "bo co bnh thng",
                documentDetail: "Chi tit bo co/h s"
            },
            toolbar: {
                controlName: {
                    all: "Xem tt c",
                    day: "ngy",
                    page: "Trang",
                    dateAppointed: "Ngy ht hn",
                    docTypeName: "Loi h s",
                    documentImportant: "Xem bo co quan trng",
                    documentUnread: "Xem bo co cha c",
                    refresh: "Ti li",
                    dateReceived: "Ngy nhn",
                    sortBy: "Sp xp theo",
                    setting: "Ci t danh sch",
                    preview: "Xem trc",
                    menu: "Menu"
                }
            },
            contextmenu: {
                name: {
                    xemvanban: "Xem bo co...",
                    suavanban: "Sa bo co...",
                    guiykien: "Gi  kin...",
                    xinykien: "Xin  kin...",
                    bangiao: "Bn giao...",
                    thongbao: "Thng bo...",
                    laylaivanban: "Ly li bo co",
                    xacnhanbangiao: "Xc nhn bn giao...",
                    xacnhanxuly: "Xc nhn x l...",
                    yeucaubosung: "Yu cu b sung...",
                    tiepnhanbosung: "Tip nhn b sung...",
                    kyduyet: "K duyt...",
                    ketthucxuly: "Kt thc x l",
                    huyvanban: "Hy bo co",
                    capnhatketquaxulycuoi: "Cp nht kt qu x l cui...",
                    inphieutrinh: "In phiu trnh lnh o...",
                    intomtat: "In tm tt",
                    capnhattiendo: "Cp nht tin ...",
                    xoakhoiduthao: "Xa bo co d tho",
                    contextheodoi: "Fix contextmenu theo di",
                    dungxuly: "Dng x l...",
                    giahanxuly: "Gia hn x l...",
                    chitietvanban: "Chi tit bo co/h s",
                    danhdaudadoc: "nh du  c",
                    danhdauchuadoc: "nh du cha c",
                    movanban: "M bo co",
                    exportToExcell: "Xut danh sch ra tp Excell",
                    exportToWord: "Xut danh sch ra tp Word",
                    removefromstoreprivate: "Xa khi h s",
                },
                printTransferHistory: "In lch s bn giao",

                reOpenDocument: {
                    text: "M li h s",
                    success: "M li thnh cng",
                    error: "C li xy ra"
                },
                duplicateDocument: "Sao chp"
            },
            page: {
                text: "Trang",
                document: "bo co"
            },
            message: {
                error: {
                    quickView: "Li khi ly thng tin bo co!",
                    documentNotExist: "bo co khng tn ti!.",
                    documentNotSelectDelete: "Cha chn bo co  xa!.",
                    pagging: "C li trong qu trnh chuyn sang trang mi",
                    loadNewerDocuments: "C li trong qua trnh ti d liu!",
                    getDocumentDetail: "bo co khng tn ti"
                }
            },
            noDocumentCopyItem: "Khng c bo co cn x l.",
            notFound: "Danh sch bo co hin ti khng c kt qu ph hp. Nhn Enter  ",
            documentNumberDayOverdue: "-{0} ngy",
            validDocuments: "Cn {0} ngy",
            validDocumentsInToday: "Hm nay",
            validDocumentsInTodayMorning: "Sng nay",
            validDocumentsInTodayAfternoon: "Chiu nay",
            validDocumentsTomorrow: "Ngy mai",
            validDocumentsAfterTomorrow: "Ngy kia",
            documentNumberWeekOverdue: "-{0} tun",
            documentNumberMonthOverdue: "-{0} thg",
            documentNumberYearOverdue: "-{0} nm",
            unlimitedTime: "V hn",
            multiselect: "{0}",
            print: {
                success: "In thnh cng",
                error: "C li xy ra"
            },
            transfer: {
                notSelectedDocument: "Bn cha chn bo co no.",
                confirmTitle: "Cho  kin trc khi bn giao.",
                confirmCheckName: "Khng hin th li ln sau.",
                primaryButtonName: "Tip tc",
                addTemplateButtonName: "Chn t mu",
                noAction: "Khng c hng chuyn."
            }
        },
        templateComment: {
            titleDialog: "Mu  kin thng dng",
            btnAddTemplateComment: "Thm mu",
            btnSelected: "Chn",
            table: {
                header: {
                    content: "Ni dung",
                    edit: "Sa",
                    'delete': "Xa"
                }
            },
            addDialog: {
                title: "Thm mu  kin thng dng",
                btnCreate: "To mi",
                errorMessage: "Bn cha mu nhp  kin!"
            },
            editDialog: {
                title: "Cp nht mu  kin thng dng",
                btnEdit: "Cp nht",
                errorMessage: "Bn cha mu nhp  kin!"
            },
            contextmenu: {
                selected: "Chn",
                edit: "Sa/Xem thng tin",
                'delete': "Xa"
            }
        },
        requiredSupplementary: {
            addRequiredTitle: "Thm mu yu cu b sung",
            noRequired: "Khng c mu"
        },
        tree: {
            displayUnRead: "C {0} bo co cha c",
            displayUnReadOnAll: "{0} cha c / tng s {1} bo co",
            displayAll: "C tt c {0} bo co",
            question: {
                label: "Hi p",
                general: "Hi p chung",
                document: "Cu hi h s",
                QuestionName: "Tn cu hi",
                citizenname: "Tn cng dn",
                date: "Ngy hi",
                doccode: "M h s"
            }
        },
        searching: {
            result: "Kt qu tm kim"
        },
        time: {
            date: "Ngy",
            _date: "ngy",
            minute: "Pht",
            _minute: "pht",
            mon: "Th 2",
            tue: "Th 3",
            wed: "Th 4",
            thi: "Th 5",
            fri: "Th 6",
            sat: "Th 7",
            sun: "Ch nht",
            morning: "Bui sng",
            affternoon: "Bui chiu",
            timenotcheck: "Khng kim tra c thi gian",
            checkdate: "Kim tra ngy",
            caculateextendtime: "Tnh lch ngh b",
            nodata: "Khng c ngy ngh no",
            repeat: "Lp li",
            repeatbyyear: "Lp theo nm",
            freeday: "Tn ngy ngh",
            AL: "Ngy m",
            DL: "Ngy dng",
            day: "Th",
            listofrestday: "Danh sch ngy ngh nm",
            weekworktime: "Thi gian lm vic trong tun",
            state: "Trng thi",
            nghibu: "Ngh b",
            nghile: "Ngh l",
            tatca: "Tt c",
            worktime: "Gi hnh chnh",
            listoffsetday: "Danh sch ngy lm b trong nm",
            yesterday: "H.qua",
            minbefore: "{0} pht trc",
            justnow: "Va xong"
        },
        enumResource: {
            actionlevel: {
                levelone: "Mc  1",
                leveltwo: "Mc  2",
                levelthree: "Mc  3",
                levelfour: "Mc  5"
            },
            activitylogtype: {
                dangnhap: "ng nhp",
                dangxuat: "ng xut",
                bangiao: "Bn giao bo co",
                thongbao: "Thng bo bo co",
                huyvanban: "Hy bo co",
                ketthucvanban: "Kt thc bo co",
                phanloai: "Phn loi bo co",
                phathanh: "Pht hnh bo co",
                kyduyet: "K duyt bo co",
                xinykien: "Xin  kin",
                guiykien: "Gi  kin",
                tiepnhan: "Tip nhn",
                xingiahan: "Xin gia hn",
                chuyenykiendonggop: "Chuyn  kin ng gp"
            },
            categorybusinesstypes: {
                vbden: "bo co n",
                vbdi: "bo co i",
                hsmc: "H s mt ca"
            },
            dailyprocesstimeforsearch: {
                allday: "C ngy",
                thirtyminutes: "30 pht trc",
                onehour: "1 ting trc",
                twohour: "2 ting trc",
                am: "Bui sng",
                pm: "Bui chiu"
            },
            datetimereport: {
                trongngay: "Trong ngy",
                trongtuan: "Trong tun",
                tuantruoc: "Tun trc",
                trongthang: "Trong thng",
                thangtruoc: "Thng trc",
                quy1: "Qu 1",
                quy2: "Qu 2",
                quy3: "Qu 3",
                quy4: "Qu 4",
                trongnam: "Trong nm",
                namtruoc: "Nm trc",
                tatca: "Tt c",
                tuychon: "Ty chn"
            },
            displaytreetype: {
                none: "Khng hin th",
                unread: "bo co cha c",
                unreadonall: "Cha c / Tt c",
                all: "Tt c"
            },
            documentprocesstype: {
                tiepnhan: "Tip nhn",
                bangiao: "Bn giao",
                kyduyet: "K duyt",
                traketqua: "Tr kt qu",
                tiepnhanbosung: "Tip nhn b sung",
                giahan: "Gia hn"
            },
            documenttype: {
                thongbao: "Thng bo",
                congvan: "Cng vn"
            },
            egovjobenum: {
                indextimerelapsed: "IndexTimerElapsed",
                checkservices: "Kim tra nhng service khng hot ng",
                getdocumentsfromedoctool: "Kim tra xem c bo co mi ti khng",
                notifydocunread: "Notify nhng bo co cha c",
                notifydocinprocesses: "Notify nhng bo co ch x l",
                checkchangedfile: "Kim tra file b thay i",
                addindex: "nh index tm kim"
            },
            feetype: {
                indextimerelapsed: "Tip nhn",
                thuongbosung: "Thng b sung",
                tracongdan: "Tr cng dn"
            },
            leveltype: {
                sobannganh: "S, Ban ngnh",
                quanhuyen: "Qun, Huyn",
                phuongxa: "X, Phng"
            },
            licensestatus: {
                capmoi: "Cp mi",
                capdoi: "Cp i, b sung",
                thuhoi: "Thu hi"
            },
            option: {
                documentonlinereg: "ng k trc tuyn  c ti khon",
                documentonlineregnoaccount: "ng k trc tuyn m cha c ti khon",
                acceptdoconline: "Chp nhn khi ng k trc tuyn",
                implementdoconline: "Yu cu b sung khi ng k trc tuyn",
                rejectdoconline: "T chi khi ng k trc tuyn"
            },
            papertype: {
                tiepnhan: "Tip nhn",
                thuongbosung: "Thng b sung",
                tracongdan: "Tr cng dn"
            },
            permissiontypes: {
                ktao: "Khi to bo co",
                xly: "X l bo co"
            },
            processfilterexpression: {
                groupby: "Nhm theo",
                equal: "Bng",
                custom: "Khc"
            },
            scheduletype: {
                hangphut: "Hng pht",
                hanggio: "Hng gi",
                hangngay: "Hng ngy",
                hangtuan: "Hng tun",
                hangthang: "Hng thng"
            },
            searchtype: {
                document: "Tm kim bo co",
                file: "Tm kim trong file"
            },
            securitytype: {
                thuong: "Thng",
                mat: "Mt",
                toimat: "Ti mt"
            },
            sendtype: {
                buudien: "Bu in",
                email: "Email",
                fax: "Fax",
                traotay: "Trao tay"
            },
            servicestatus: {
                running: "ang chy",
                stoped: "ang dng",
                paused: "ang tm dng",
                accessdenied: "Khng c quyn truy cp service",
                notfound: "Service cha c ci t trn h thng"
            },
            specialkeyenum: {
                nguoidangnhap: "Ngi in phiu",
                ngaythanghientai: "Ngy thng hin ti",
                meetingtitle: "Tiu  cuc hp",
                meetingresource: "a im hp",
                meetingdate: "Thi im hp",
                meetingtodate: "Thi im kt thc",
                meetingcreator: "Ngi to cuc hp",
                meetingbody: "Ni dung cuc hp",
                meetingusers: "Ngi tham gia cuc hp",
                meetinglastupdate: "Ngi cp nht cuc hp"
            },
            supplementtype: {
                reset: "Tnh li thi gian",
                'continue': "Tip tc x l",
                fixeddays: "Thm ngy c nh"
            },
            templatetype: {
                phieuin: "Phiu in",
                email: "Th in t",
                sms: "Tin nhn sms"
            },
            timerjobtype: {
                warning: "Cnh bo",
                searchindex: "nh ch mc tm kim",
                deletetempfile: "Xa b cc file tm"
            },
            urgent: {
                thuong: "Thng",
                khan: "Khn",
                hoatoc: "Ha tc"
            },
            quickview: {
                hide: "Khng hin th",
                below: " bn di",
                right: " bn phi"
            },
            fontsize: {
                nho: "Ch nh",
                vua: "Ch va",
                lon: "Ch ln"
            },
            notify: {
                documentnotifytype: {
                    hide: "Khng hin th",
                    shownotifyinprocess: "Ch hin th thng bo bo co ch x l",
                    all: "Hin th tt c thng bo bo co c lin quan"
                },
                bmailnotifytype: {
                    hide: "Khng hin th",
                    inbox: "Ch hin th th c nhn",
                    option: "Hin th trn cc th mc  xem",
                    all: "Hin th tt c th nhn c"
                },
            }
        },
        documentNotifications: "Thng bo bo co",
        emptyDocumentNotifications: "Bn khng c thng bo bo co no!",
        openAllDocument: "M tt c bo co c thng bo",
        downloaddesktopversion: "Ti bn desktop",
        gtv: "Kiu g",
        notifications: "Thng bo",
        news: "Tin iu hnh",
        newEmail: "Son th",
        config: "Thit lp",
        reply: "Gi phn hi",
        smallSize: "Xem c nh",
        mediumSize: "Xem c va",
        largeSize: "Xem c ln",
        underPreview: "Xem trc bn di",
        rightPreview: "Xem trc bn phi",
        hidePreview: "n xem trc",
        reload: "Khi ng li",
        logout: "ng xut",
        searchDocument: "Tm kim bo co",
        searchFile: "Tm kim file nh km",
        reloadMessage: "Mt s thit lp yu cu phi reload li h thng. Bn c mun relo",
        closeBtn: "ng",
        submitBtn: "Cp nht",
        titleMessage: "Thng bo!",
        closeAll: "ng tt c li",
        reportL: "Thng k",
        contacts: "S lin lc",
        calendar: "Lch",
        statictisLabel: "Gim st, Thng k",
        cbcl: "Chaas",
        reportLabel: "Bo co",
        chat: "Chat",
        documentslabel: "X l cng vn",
        placeholderSearch: "Tm kim thng tin h s, bo co, tp nh km",
        administrator: "Qun tr h thng",
        links: "Lin kt",
        conversion: "Hi thoi",
        messageNoBtn: "Khng",
        mailNotifications: "Thng bo mail",
        emptyMailNotifications: "Bn khng c thng bo mail no",
        openAllMail: "M tt c mail nhn c",
        chatNotifications: "Thng bo chat",
        emptyChatNotifications: "Bn khng c tin nhn no",
        openAllChat: "M tt c tin nhn nhn c",
        bmail: "Tin iu hnh",
        notJqueryAlert: "Cha c file jquery. Vui lng ti thm file jquery!",
        lblDocument: "bo co",
        lblNewConversion: "Hi thoi",
        lblNewWorkTime: "To lch",
        lblNewMail: "Son th",
        searchMail: "Tm kim mail",
        youHave: "Bn c",
        unreadDocuments: "bo co cha xem",
        'delete': "Xa",
        activityLog: {
            questionDelete: "Bn c mun xa cc nht k ny khng?",
            notChoice: "'Bn cha chn nht k mun xa'"
        },
        level: {
            nodata: "Khng c cp hnh chnh no"
        },
        license: {
            AddLicense: "ng k",
            RegisterLicense: "ng k bn quyn",
            customername: "",
            Phone: "S in thoi",
            Email: "Email",
            ToDate: "Ngy ht hn",
            TotalUser: "S ti khon",
            key: "M kch hot"
        },
        log: {
            logNotSelect: "Bn cha chn nht k mun xa",
            deleteSelection: "Xa nht k c chn",
            detail: "Chi tit nht k"
        },
        notify: {
            noform: "Cha c mu no",
            nouse: "Khng s dng",
            urgent: {
                name: " khn",
                level1: "Bnh thng",
                level2: "Khn",
                level3: "Thng khn"
            },
            hasRead: "c duyt",
            alerttime: " pht (t = 0  gi sms ngay khi c cuc hp mi)",
            noJquery: "Th vin ny s dng jQuery, hy ti th vin jQuery trc khi s d",
            noUnderscore: "Th vin ny s dng Underscore, hy ti th vin Underscore trc ",
            openall: "M tt c",
            closeall: "ng tt c",
            nomailnotify: "Bn khng c thng bo mail no.",
            nodocumentnotify: "Bn khng c thng bo bo co no",
            nochatnotify: "Bn khng c tin nhn no",
            valuemodelnotnull: "Gi tr model khng c  null"
        },
        office: {
            nooffice: "Khng c c quan no"
        },
        paper: {
            nopaper: "Khng c giy t no",
            other: "Khc",
            list: "Danh sch giy t",
            action: "Nghip v",
            docfield: "Lnh vc",
            doctype: "Loi h s",
            addpaper: "Thm mi giy t",
            updatepaper: "Cp nht giy t"
        },
        people: {
            nopeople: "Khng c ngi dng no",
            peoplesearch: "Tm kim ti khon "
        },
        position: {
            sorterror: "C li khi sp xp mc u tin ca chc v.",
            npposition: "Khng c chc v no",
            orderedsort: "Cho php sp xp th t bng cch ko th"
        },
        printer: {
            addprinter: "Thm mi my in",
            editprinter: "Thit lp cho my in",
            nodata: "Khng c my in no",
            notconnect: "Khng kim tra kt ni c ti my in!",
            nameisrequired: "Tn my in khng c  trng!"
        },
        processfunction: {
            selectcolor: "Chn mu",
            user: "Ngi dng",
            position: "Chc v",
            position1: "Phng ban/Chc v",
            all: "Tt c",
            failure: "Bn cha nhp y  thng tin trong phn cu hnh danh sch",
            setupforfilterlist: "Cu hnh danh sch b lc cho node",
            setupforsamelist: "Cu hnh danh sch tng ng vi node",
            enternote: "(Dng phm enter  xung dng (nu  dng cui cng th thm dng ",
            divrole: "Phn quyn",
            addnodefilter: "Thm b lc mi cho node",
            parameterlisthaverequirement: "Bn cha nhp y  thng tin trong phn danh sch tham s",
            docfieldnote1: " Nu tham s c ct gi tr l DocFieldId th h thng s ",
            docfieldnote2: "ngm hiu l cy bo co  s lc theo lnh vc v loi h s",
            columnname: "Tn ct gi tr",
            paraname: "Tn tham s",
            updatenodetype: "Cp nht loi node",
            document: "H s cng vic",
            addNode: "Thm node mi",
            copyNode: "Copy node ny",
            paste: "Dn node",
            'delete': "Xa node ny",
            confirmdeletenode: "Xa 1 node s xa c node con, bn chc chn mun xa ch?",
            deletenodesuccessfull: "Xa node thnh cng!",
            nodata: "Khng c loi node no",
            nofilter: "Khng c b lc no",
            nogroup: "Khng c nhm no",
            alldocument: "---Tt c loi bo co, h s---",
            someinfoisrequired: "Bn cha nhp y  thng tin trong phn cu hnh danh sch",
            parent: "Cha",
            normal: "Bnh thng",
            field: "Trng d liu",
            type: "Kiu",
            displayname: "Tn hin th",
            filterByOverdueDate: "Lc theo hn x l:",
            display: "Hin th",
            defaultdocumentsortconfig: "Cu hnh sp xp bo co mc nh",
            entertobreakpage: "(Dng phm enter  xung dng (nu  dng cui cng th thm dng ",
            configlistbynode: "Cu hnh danh sch tng ng vi node"
        },
        question: {
            nodata: "Khng c cu hi no",
            name: "Tn cu hi",
            content: "Ni dung cu hi",
            citizenname: "Tn cng dn",
            email: "Email",
            phone: "S in thoi",
            uptohome: "Cho ln trang hnh chnh cng",
            quickanswer: "Tr li nhanh",
            answer: "Cu tr li",
            btnAnswer: "Tr li",
            transfer: "Chuyn cn b tr li",
            date: "Thi gian hi",
            Compendium: "Trch yu h s",
            reject: "T chi tr li",
            rejectClause: "L do t chi",
            rejectHolder: "Nhp l do t chi tr li",
            rejectConfirm: "Xc nhn",
            searchUser: "Tm ti khon cn b",
            chooseuser: "Chn cn b x l",
            forwarding: "ang chuyn cu hi",
            forwardsuccess: "Chuyn cu hi thnh cng",
            btnShowDocumentDetail: "Xem chi tit",
            listquestiontitle: "Danh sch cu hi",
            detail: "Chi tit cu hi",
            showadvancededit: "Nng cao",
            commentList: " kin cn b x l",
            compendium: "Trch yu h s",
            transferComment: "Nhp  kin chuyn",
            defaultTransferComment: "Tr li h nhe cng",
            holding: "ang gi cu hi",
            noquestion: "Khng c cu hi no"
        },
        report: {
            fileuploadrpt: "Ch cho php ti ln tp *.rpt",
            showguidewhenwritingsqlquery: "Hin th hng dn son sql",
            showdatabygroup: "Cu hnh xem d liu theo nhm",
            showgroupinreporttree: "Cu hnh hin th nhm ln cy bo co",
            _setting: "[cu hnh]",
            statisticSetting: "Cu hnh thng k",
            permissionreadreport: "Phn quyn c xem bo co",
            privatesetting: "Cu hnh ring",
            settingreport: "S dng cu hnh bo co",
            nodata: "Khng c nhm bo co no",
            deletesuccessfull: "Xa bo co thnh cng",
            confirmdeletereport: "Bn c chc mun xa bo co ny cng vi tt c cc bo co con c",
            config: "Cu hnh bo co",
            configsetup: "[cu hnh]",
            showguide: "Bt/tt hng dn",
            exprort: "Xut ra file",
            group: "Nhm",
            print: "In",
            view: "Xem",
            totalDocuments: "Tng s bo co:",
            totalDocumentNotProcessed: "S bo co cha c x l:",
            totalDocumentProcessed: "S bo co  c x l:",
            totalDocumentOverdue: "S bo co qu hn:"
        },
        resource: {
            nodata: "Khng c resource no",
            choosefileimport: "Chn tp import"
        },
        role: {
            nodata: "Cha c ngi dng no",
            isallow: "Cho php",
            rolename: "Tn quyn",
            nodatagroup: "Khng c nhm ngi dng no"
        },
        scopearea: {
            nodata: "Khng c ScopeArea no"
        },
        shared: {
            productname: "Bkav eGov",
            systemtree: "Cy h thng",
            home: "Trang ch",
            admincustomer: "Qun tr khch hng"
        },
        store: {
            pts: "(Ph trch s)",
            nouser: "Cha c ngi dng no",
            tempforstore: "Danh sch mu cho s",
            alltempname: "Tt c tn mu",
            notemp: "Khng tn ti mu no!",
            _all: "[Tt c]",
            nodocumentstore: "Khng c s h s no",
            choosecategory: "Chn nghip v",
            addstoreviewer: "Thm ngi xem s",
            addDocFields: "Thm lnh vc",
            docField: "Lnh vc"
        },
        template: {
            nodata: "Khng c mu no",
            key: "Key dng chung",
            systemerror: "H thng li, khng thay i c trng thi mu phiu",
            printorder: "Phiu in",
            per1: "Tip nhn",
            per2: "Bn giao",
            per4: "K duyt",
            per8: "Tr kt qu",
            per16: "Tip nhn b sung",
            per32: "Gia hn",
            specialkey: "Key t cuc hp",
            keyfromform: "Key t biu mu",
            questionkey: "Key hi p",
            documentOnlineKey: "Key ng k qua mng",
            dbkey: "Key ly t CSDL",
            commonKey: "Cc key dung chung"
        },
        templatekey: {
            onoffguide: "Bt/tt hng dn",
            showguide: "Hin th hng dn khi son m key, sql, template",
            ex: "Vd:",
            needparameter: "Cu truy vn phi c tham s",
            parametercanuseinquery: "Cc tham s c th s dng trong cu truy vn",
            keyformat: "nh dng key c php",
            speccharacter: "{[a-zA-Z0-9_]+}",
            keyformat2: "bao gm cc ch ci (hoa, thng), ch s v du gch chn (_).",
            getvalueintempdoc: "Ly gi tr trong biu mu no ca h s.",
            currentuserid: "Id ngi ng nhp hin ti.",
            doctype: "Loi giy t.",
            costtype: "Loi l ph.",
            additiondoc: "Danh sch cc giy t b sung.",
            formatofresulequery: "Kt qu cu truy vn c ly theo dng",
            fieldname: "ten_truong",
            sqlresult: "l kt qu ca cu sql dng",
            dataprocessfunctions: "Cc hm x l kiu d liu",
            exdataconvertfunctions: "Tt c cc hm convert d liu:",
            stringprocessingfuntions: "Tt c cc hm x l chui:",
            datefunctions: "Tt c cc hm x l ngy thng:",
            stringformats: "Tt c cc nh dng chui:",
            viewdetail: "Xem chi tit ti:",
            selectdocument: "Chn loi h s",
            selecttemplate: "Chn biu mu",
            selectdocfield: "Chn lnh vc",
            keycode: "M key",
            nokey: "Khng c key no"
        },
        transfertype: {
            nodata: "Khng c hnh thc chuyn no"
        },
        user: {
            username: "Tn ng nhp",
            fullname: "H v tn",
            phone: "S in thoi",
            usernameexist: "Tn ng nhp  tn ti",
            notindepartment: "Cha thuc phng ban no",
            rolename: "Tn quyn",
            groupname: "Tn nhm",
            isadministrator: "L qun tr",
            ismaindepartment: "L phng ban chnh",
            position: "Chc danh",
            position1: "Chc v",
            departmentname: "Tn phng",
            nodata: "Khng c ngi dng no",
            all: "---Tt c---",
            active: "Hot ng",
            unactive: "Khng hot ng",
            confirmtoresetpassword: "Bn c chc chn mun reset mt khu cho ti khon ny khng?",
            resetpasswordsuccess: "Reset mt khu thnh cng!",
            selectusertoimport: "Bn phi chn ngi dng  import",
            importusersuccessfull: "Import ngi dng thnh cng",
            defaultPasswordRest: "Mt khu reset mc nh",
            clearToRandomData: "B trng  to mt khu ngu nhin"
        },
        ward: {
            city: "Tnh/Thnh ph:",
            district: "Qun/huyn:",
            nodata: "Khng c x/phng no",
            updatedata: "Cp nht x/phng",
            datalist: "Danh sch x/phng"
        },
        welcome: {},
        buttons: {
            select: "Chn",
            selectAll: "Chn tt",
            edit: "Sa",
            'delete': "Xa",
            orderedsort: "Lu th t sp xp",
            orderedSortHint: "Cho php sp xp th t bng cch ko th",
            orderedsave: "Lu th t",
            addfilter: "Thm b lc mi",
            addparameter: "Thm tham s",
            save: "Lu",
            confirm: "Xc nhn",
            back: "Quay li danh sch",
            config: "Cu hnh",
            close: "ng",
            deleteAll: "Xa ton b",
            deleteall: "Xa ht",
            search: "Tm kim",
            agree: "ng ",
            ignore: "B qua",
            add: "To mi",
            view: "Xem",
            copy: "Sao chp",
            rerunAll: "Chy li ton b",
            testDVC: "Test dch v cng"
        },
        tableheader: {
            stt: "STT",
            'function': "Chc nng",
            description: "M t",
            form: "Mu",
            edit: "Sa",
            select: "Chn",
            'delete': "Xa",
            type: "Kiu",
            formname: "Tn mu",
            filtername: "Tn b lc",
            columnname: "Tn ct",
            justify: "Cn l",
            displayname: "Tn hin th",
            width: "Chiu rng",
            allowsort: "Cho php sp xp",
            sortcolumn: "Ct sp xp",
            sort: "Sp xp",
            value: "Gi tr",
            name: "Name",
            domain: "Domain",
            ip: "ip",
            zone: "Vng",
            isallow: "Cho php",
            addordelete: "Thm/B",
            sortcolumnname: "Tn ct sp xp",
            sorttype: "Kiu sp xp(tng hoc gim)",
            order: "Th t",
            isallowsort: "Cho php sp xp"
        },
        commonlabel: {
            list: "Danh sch",
            select: "Chn",
            is: "L",
            or: "Hoc...",
            addcolumn: "Thm ct",
            add: "Thm",
            addnew: "Thm mi",
            cancel: "Hy b",
            note: "*Lu :",
            time: {
                date: "Ngy",
                _date: "ngy",
                minute: "Pht",
                _minute: "pht",
                mon: "Th 2",
                tue: "Th 3",
                wed: "Th 4",
                thi: "Th 5",
                fri: "Th 6",
                sat: "Th 7",
                sun: "Ch nht",
                morning: "Bui sng",
                affternoon: "Bui chiu"
            },
            contact: "Lin h",
            errorpage: "Sorry, an error occurred while processing your request.",
            all: "Tt c",
            email: "Email",
            sms: "SMS",
            printcard: "Phiu in",
            vnconcurency: "vnd",
            reject: "B",
            yes: "C",
            no: "Khng",
            search: "Tm",
            allow: "Cho php",
            notallow: "Khng cho php",
            'delete': "Xa",
            other: "Khc",
            haveerrortryagain: "C li xy ra, vui lng th li!",
            deincrease: "Gim dn"
        },
        sitemap: {
            config: "Cu hnh",
            general: "Thit lp h thng",
            processfunction: "Cy bo co",
            resource: "Ti nguyn",
            activitylog: "Nht k hnh ng",
            egovjob: "Qun l tin trnh ca h thng ",
            config4: "Biu mu",
            template: "Qun l mu phiu",
            templatekey: "Qun l key",
            formgroup: "Qun l nhm biu mu",
            form: "Qun l biu mu",
            embryonicform: "Qun l mu phi",
            config5: "Bo co",
            report: "Bo co ng",
            notify: "Thng bo",
            config2: "Danh mc",
            categorybusiness: "Nghip v",
            docfield: "Lnh vc",
            doctype: "Loi bo co",
            configworkflow: "Quy trnh",
            category: "Hnh thc bo co",
            increase: "Nhy s",
            code: "Bng m",
            store: "S h s",
            catalog: "Danh mc ty chn",
            keyword: "T kha",
            transfertype: "Hnh thc gi",
            time: "Thi gian lm vic",
            address: "a ch",
            config3: "C cu t chc",
            imfomation: "C quan",
            department: "Phng ban",
            jobtitles: "Chc danh",
            position: "Chc v",
            user: "Cn b",
            role: "Vai tr v quyn hn",
            authorize: "y quyn",
            client: "Client",
            people: "Ngi dng",
            scopearea: "Vng truy cp",
            config6: "eGovOnline",
            office: "C quan",
            law: "bo co quy phm",
            guide: "Hng dn",
            question: "Cu hi",
            onlinetemplate: "Biu mu hnh chnh",
            treeGroup: "Nhm cy bo co",
            permissionSetting: "Cu hnh quyn trn node",
            config7: "Sao lu",
            docColumnSetting: "Cu hnh hin th danh sch",
            reportgroup: "Nhm bo co",
            paper: "Giy t",
            fee: "L ph",
            requiredSupplementary: "Mu yu cu b sung",
            sharefolder: "a ch lu tr file sao lu",
            backuprestoreconfig: "Sao lu c s d liu",
            backuprestorehistory: "Lch s sao lu c s d liu",
            backuprestorefileconfig: "Sao lu th mc",
            backupRestoreManager: "Qun l tp tin sao lu",
            printer: "Qun l my in",
            interfaceConfig: "Giao din",
            actionlevel: "K bo co"
        },
        docfield: {
            store: "S h s",
            nodocumentstore: "Khng c s h s no"
        },
        crystalreport: {
            copyfromstatisticform: "Sao chp t mu thng k",
            copyfromreportform: "Sao chp t mu bo co",
            reconfig: "Config li t u",
            save: "Lu li"
        },
        doctype: {
            othernodes: "Cc nt khc",
            addcontrol: "Thm control",
            downloadworkflowerror: "C li khi ti quy trnh",
            newworkflow: "Thm quy trnh mi",
            workflownameisrequired: "Bn phi nhp tn quy trnh",
            pasteworkflow: "Dn quy trnh",
            usethisworkflow: "Dng quy trnh ny",
            comfirmtocancel1: "Bn c chc mun ",
            comfirmtocancel2: "b ",
            comfirmtocancel3: "dng quy trnh ny khng?",
            update: "Cp nht danh mc",
            editTemplateWorkflow: "Cu hnh giao din",
            updatenode: "Cp nht node",
            interfaceconfig: "Cu hnh giao din",
            editthisworkflow: "Sa quy trnh ny",
            copythisworkflow: "Copy quy trnh ny",
            deletethisworkflow: "Xa quy trnh ny",
            confirmtodeltethisworkflow: "Bn c chc mun xa quy trnh ny khng?",
            notyouthisworkflow: "B dng quy trnh ny",
            workflowname: "Tn quy trnh",
            exprisedate: "Hn x l",
            date: "Ngy",
            addtemplateform: "Thm mu phi",
            noformdata: "Khng c mu no",
            doctypename: "Tn h s: ",
            docfield: "Lnh vc: ",
            status: "Trng thi:",
            active: "Kch hot",
            notactive: "Khng kch hot",
            noconfiguration: "Cha c cu hnh",
            confirmtodeletereceivenode: "Bn c ng  xa node n ny khng?",
            objectype: "Kiu i tng",
            value: "Gi tr",
            'delete': "Xa",
            receivepostlist: "Danh sch nhn thng bo",
            removeReceiveList: "Bn c ng  xa danh sch thng bo ny khng?",
            of: "Ca",
            allpeople: "Tt c mi ngi",
            level: "Cp",
            user: "Ngi s dng",
            alljobtitle: "Tt c chc danh",
            alljobtitleof: "Tt c chc danh ca ",
            alljobtitleof1: "Tt c ",
            alljobtitleof2: " ca ",
            jobtitledepartment: "Chc danh-phng ban",
            alluserof: "Tt c user ca ",
            fieldisrequired: "Bn phi nhp gi tr",
            embryonicformname: "Tn mu phi:",
            embryonicformlist: "Danh sch cc mu phi:",
            addnewform: "Thm mu mi"
        },
        form: {
            updateform: "Cp nht loi h s, bo co",
            formname: "Tn mu",
            description: "M t",
            tempkey: "Mu phi",
            status: "Trng thi",
            config: "Cu hnh",
            status1: " ang s dng",
            status2: " Khng s dng",
            status3: " Mu lu tm",
            configformtitle: "Title",
            addtitle: "Thm Tiu  (nhn)",
            showgrid: "Hin th ng k",
            shownumber: "Hin th s",
            addrow: "Thm dng",
            chooseextendfield: "- - - Chn trng m rng - - - ",
            choosedocumenttype: "- - - Chn loi bo co - - - ",
            title: "Cu hnh mu cho loi h s",
            brand: " nhp liu (nhn)",
            references: "Quan h",
            account: "Tn ng nhp",
            currentusername: "Tn ngi ng nhp hin ti",
            currentdepartment: "Tn n v/b phn/phng ban",
            docfieldname: "Tn lnh vc",
            doctypename: "Tn loi h s",
            doccode: "M h s",
            receivedate: "Ngy tip nhn",
            appointdate: "Ngy hn tr",
            template: "Mu:",
            insertspecialvalue: "Chn cc gi tr c bit:",
            formgroup: "Nhm mu:",
            formtype: "Loi mu:",
            searchText: "T kha",
            submit: "Tm kim"
        },
        guide: {
            nodata: "Khng c bn hng dn no"
        },
        increase: {},
        infomation: {
            chageinfo: "Thay i thng tin"
        },
        jobtitles: {
            nodata: "Khng c chc danh no",
            dragordroptosort: "Cho php sp xp th t bng cch ko th",
            sorterror: "C li khi sp xp mc u tin ca chc danh."
        },
        editor: {
            deletecol: "Xa ct",
            deleterow: "Xa dng",
            insertabove: "Chn trn",
            insertbelow: "Chn di",
            insertleft: "Chn tri",
            insertright: "Chn phi",
            merge: "Hp nht",
            splitcolumn: "Chia ct",
            splitrow: "Chia dng",
            update: "Cp nht",
            all: "[Tt c]"
        },
        law: {
            choosedocument: "Chn bo co",
            lawnumbercode: "S k hiu",
            subContent: "Tm tt"
        },
        code: {
            choosedepartment: "Chn phng ban",
            name: "Nhy s",
            config1: "Ly ngy hin ti, nu nh hn 10 th thm s 0 ng trc",
            config2: "Ly ngy hin ti",
            config3: "Ly thng hin ti, nu nh hn 10 th thm s 0 ng trc",
            config4: "Ly thng hin ti",
            config5: "Ly nm hin ti",
            config6: "Ly 2 s cui ca nm hin ti"
        },
        deparment: {
            choosejobtitle: "Chn chc danh",
            chooseposition: "Chn chc v",
            listuser: "Danh sch cn b thuc phng ban",
            nouser: "Cha c ngi dng no",
            nodata: "Cha c phng ban",
            addsubdeparment: "Thm mi phng ban trc thuc",
            deparmentinfo: "Thng tin phng ban",
            deparmentname: "Tn phng ban",
            updateinfo: "Cp nht thng tin phng ban",
            adduser: "Thm ngi dng vo phng/ban",
            fullname: "H tn",
            isadmin: "Qun tr",
            jobtitle: "Chc danh",
            position: "Chc v",
            list: "Danh sch phng ban",
            isprimary: "Phng chnh"
        },
        bkavmessagebox: {
            useshowtoreplacealert: "S dng eGovMessage.show(message, title)  thay th cho messageBox",
            useshowtoreplaceconfirm: "S dng eGovMessage.show(message, title, messageButtons.OkCancel) ",
            usenotificationtoreplacetemp: "S dng eGovMessage.notification()  thay th cho messageTemp().",
            closebutton: "X",
            yes: "ng ",
            no: "T b",
            ok: "Xc nhn",
            cancel: "Hy b",
            notify: "Thng bo"
        },
        workflow: {
            user: "Cn b",
            position: "V tr",
            relation: "Quan h",
            belowoffice: "n v cp di",
            underoffice: "n v trc thuc",
            currentoffice: "n v hin ti",
            sameoffice: "Cng n v",
            peernode: "Node ngang hng",
            sameparentnode: "Cng Node cha",
            underuser: "Cp di",
            overuser: "Cp trn",
            addnotifyfouser: "Thm user nhn thng bo",
            nodename: "Tn node",
            choosedepartment: "Chn phng ban",
            listuser: "Danh sch user",
            workflowTypes: "Loi con",
            addWorkflowType: "Thm"
        },
        formtemplate: {
            columnwidth: "Chiu rng ct",
            brandwidth: "Chiu rng nhn",
            height: "Chiu cao",
            disable: "V hiu ha",
            verifydata: "C kim tra d liu",
            compendium: "Trch yu",
            comment: " kin x l",
            doctype: "Loi bo co",
            category: "Hnh thc",
            inoutplace: "n v",
            dateappointed: "Thi hn x l",
            organization: "C quan gi",
            doccode: "S/k hiu *",
            doccode2: "S hiu *",
            datearrived: "Ngy n",
            dateresponse: "Hi bo",
            datepublished: "Ngy ban hnh",
            store: "S h s",
            storeid: "S bo co",
            inoutcode: "S n i",
            totalPage: "S trang",
            choosetotalpage: "Chn s trang",
            docfield: "Lnh vc",
            keyword: "T kha",
            sendtype: "Hnh thc gi",
            doccode1: "M h s",
            citizenname: "Tn cng dn",
            address: "a ch",
            phone: "S in thoi",
            docpapers: "Giy t",
            identitycard: "S CMT",
            email: "Th in t",
            commune: "X phng",
            attachmentlist: "File nh km",
            relationlist: "bo co lin quan",
            cbdetail: "Hin th chi tit bo co n",
            allcomment: "Ni dung x l",
            titlecontent: "Ni dung bo co",
            urgent: {
                name: " khn",
                normal: "Thng",
                fast: "Khn",
                important: "Ha tc"
            },
            securityid: {
                name: " mt",
                normal: "Thng",
                high: "Mt",
                important: "Ti mt",
                highest: "Tuyt mt",

            },
            compendiumtitle: "Nhp trch yu.",
            nocomment: "Cha cho  kin",
            displayform: "Hin th biu mu",
            storeprivate: "H s c nhn",
            storeshare: "H s chia s",
            nextpage: "Trang tip",
            prepage: "Trang trc",
            currentpage: "Trang",
            print: "In",
            btnfinish: "Kt thc",
            viewicontraketqua: "Tr kt qu",
            viewicontiepnhanbosung: "Tip nhn b sung",
            viewiconhuyvanban: "Hy",
            viewiconluu: "Lu s",
            viewiconguiykien: "Gi  kin",
            viewiconthongbao: "Thng bo",
            viewiconxinykien: "Xin  kin",
            viewiconyeucaubosung: "Yu cu b sung",
            viewicongiahanxuly: "Gia hn",
            no: "T chi",
            yes: "ng ",
            btninsertrelation: "bo co lin quan...",
            btninsertattachment: "Tp nh km",
            btninsertscan: "Tp scan...",
            btnpaper: "Giy php...",
            btninsertanticipate: "D kin chuyn...",
            btntransfer: "Chuyn bo co/h s",
            btnedit: "Sa ni dung bo co/h s",
            btninsertfile: "nh km",
            btnapproveryes: "ng  ph duyt",
            btnapproverno: "T chi ph duyt",
            btndestroy: "Hy bo co/h s",
            viewiconketthuc: "",
            btnfinishtt: "Kt thc",
            btnanswer: "Tr li",
            btnchangedoctype: "Phn loi",
            concurrency: "Vnd",
            usercomment: "Ngi x l",
            filename: "Tn tp",
            filesize: "Kch thc",
            fileversion: "Phin bn",
            lastupdatefile: "Cp nht cui",
            finalcomment: " kin gii quyt",
            backtolist: "Quay li danh sch",
            'delete': "Xa",
            mainprocess: "X l chnh:",
            coprocess: "ng x l:",
            sendto: "Chuyn ti",
            thongbao: "Thng bo:",
            xinykien: "Xin  kin:",
            view: "Xem",
            download: "Ti v",
            placelabel: "Ni nhn",
            officename: "Tn c quan",
            placeinoffice: "Ni nhn trong n v",
            approvers: "Ngi k",
            docinpage: "S.bn / s.trang",
            inplace: "Ni lu bn gc",
            publishreceive: "Danh sch nhn bo co",
            createdate: "Ngy khi to",
            createdate1: "Ngy to",
            panelselectorrequire: "Bn phi truyn tham s panelSelector",
            publicoffice: "C quan ban hnh",
            insertanticipate: "D kin chuyn",
            commoncomment: " kin thng dng",
            receivedays: "S ngy th l",
            requirereport: "Yu cu hi bo",
            fees: "L ph",
            documentrelation: "bo co lin quan",
            attachment: "Tp nh km",
            dateOverdue: "Hn x l",
            content: "Ni dung",
            hasauthentication: {
                name: "Thm quyn",
                'true': "Thuc thm quyn gii quyt",
                'false': "Khng thuc thm quyn gii quyt"
            },
            original: {
                name: "Ngun n",
                direct: "Trc tip",
                topdown: "T trn chuyn xung",
                other: "T ni khc chuyn n"
            },
            iscomplain: {
                name: "Phn loi n",
                'true': "Khiu ni",
                'false': "T co"
            },
            dateCreated: "Ngy tip nhn",
            delayReason: "L do mun",
            note: "Ghi ch khc",
            typeReturn: "Ni tr h s"
        },
        catalog: {
            addbewobject: "Thm i tng"
        },
        menu: "Danh mc",
        processdoc: "bo co ch x l",
        userConfig: {
            saveSuccess: "Lu thit lp thnh cng",
            saveError: "Lu thit lp khng thnh cng"
        },
        imagePacket: "nh km nh theo l",
        plugin: {
            noplugin: "Bn cha ci t plugin",
            pluginrequire: "Bn cn ti v v ci t plugin ny  s dng chc nng m tp ",
            needrestartbrowser: "Nu bn vn thy thng bo ny sau khi ci t plugin, hy khi n",
            downloadtosetup: "Ti v v ci t",
            waitforsetup: "ang ch ci t plugin..."
        },
        avatar: {
            nodata: "../../../AvatarProfile/noavatar.jpg",
            errorUrl: "../../../AvatarProfile/noavatar.jpg",
            icon: "../../../AvatarProfile/icon/i ({0}).png",
            troll: "../../../AvatarProfile/troll/t ({0}).png",
            alphabet: "../../../AvatarProfile/alphabet/{0}.png",
            path: "https://danhba.bkav.com/avatars/{0}.bmp"
        },
        mobile: {
            main: {
                documentSearch: "Nhp s k hiu, trch yu,...",
                mailSearch: "Nhp t kha tm kim",
                logout: "ng xut",
                exit: "Thot",
                reload: "Khi ng li",
                config: "Thit lp",
                createPersonMail: "Gi mail c nhn",
                createBoxMail: "Gi tin vo y",
                folderempty: "Lm rng mc tin",
                foldermarkread: "nh du tt c l  c",
                clearNotifies: "Xa tt c thng bo",
                nonotify: "Bn khng c thng bo no"
            },
            usersetting: {
                loadavatar: "Ti nh i din",
                fullscreen: "Ton mn hnh",
                fullscreennode: "(khi cun trang)",
                appstart: "ng dng khi ng",
                fontsize: "C ch",
                fontsizeType: {
                    small: "Nh",
                    normal: "Va",
                    large: "Ln"
                },
                pagesizenode: "(ch cho mail)",
                pagesize: "Phn trang",
                language: "Ngn ng",
                languagenode: "(cn khi ng li)",
                fontfamily: "Font ch",
                systemfont: "Mc nh",
                savelastapp: "Chy sau cng",
                appType: {
                    documents: "bo co",
                    bmail: "Th",
                    chat: "Tr truyn",
                    calendar: "Lch",
                    contacts: "Danh b"
                },
                notify: {
                    config: "Thng bo",
                    noNotify: "Tt thng bo",
                    oneNotify: "Ch hin thng bo cui cng",
                    allNotify: "Hin tt c thng bo"
                }
            },
            notify: {
                mailNotify: "Bn c {0} th mi.",
                chatNotify: "Bn c {0} tin nhn mi.",
                documentNotify: "Bn c {0} bo co thng bo.",
                calendarNotify: "Bn c {0} lch lm vic cha xem.",
                documentNotFound: "bo co thng bo khng tn ti"
            },
            connectionError: "My ch mail khng th kt ni"
        },
        kntc: "Khiu ni t co",
        syncDocType: "ng b cng vn lin thng"
    };

    //egov.resources.transfer = extend(egov.resources.transfer, {
    //    dgUserLabelM: "C nhn, n v nhn bn sao",
    //    dgJobtitleLabelM: "Chc v nhn bn sao",
    //    dgDeptLabelM: "Phng ban nhn bn sao",
    //    dgUserGiamsatM: "Cn b gim st",
    //});
    //#region bmail
    bmail.resources = {
        mailbox: {
            inbox: "Hp th n",
            sent: "Th  gi",
            drafts: "Th nhp",
            junk: "Th rc",
            trash: "Th  xa"
        },
        toolbar: {
            'delete': "Xa",
            deletePer: "Xa vnh vin",
            reply: "Tr li",
            replyall: "Tr li tt c",
            forward: "Chuyn tip",
            edit: "Sa",
            spam: "nh du l spam",
            unspam: "B nh du l spam",
            read: "nh du l  c",
            unread: "nh du l cha c",
            restore: "Khi phc th  xa"
        },
        button: {
            ok: "Xc nhn",
            cancel: "Hy b",
            'delete': "Xa",
            send: "Gi",
            close: "ng"
        },
        notify: {
            success: "Thnh cng",
            error: "Li"
        },
        common: {
            processing: "ang ti",
            label: {
                time: "Thi gian"
            },
            time: {
                today: "Hm nay",
                yesterday: "Hm qua",
                date: "Ngy",
                _date: "ngy",
                minute: "Pht",
                _minute: "pht",
                mon: "Th 2",
                tue: "Th 3",
                wed: "Th 4",
                thi: "Th 5",
                fri: "Th 6",
                sat: "Th 7",
                sun: "Ch nht"
            },
            table: {
                stt: "STT",
                _stt: "S th t"
            },
            searchresult: "Kt qu tm kim"
        },
        main: {
            newmail: "Thm mi th",
            sendto: "Gi ti",
            cc: "Cc",
            bcc: "Bcc",
            subject: "Ch ",
            originmessage: "----- Thng ip gc : ----- ",
            send: "Gi",
            close: "ng",
            confirmSave: "Lu",
            notSave: "Khng lu",
            mailContentChange: "Ni dung th thay i",
            savedraft: "Bn c mun lu nhp th ang son?",
            savedraftsuccess: "Lu nhp thnh cng",
            savedrafterror: "Lu nhp khng thnh cng, vui lng th li sau."
        },
        detail: {
            time: "Thi gian",
            sendto: "Gi ti",
            sendfrom: "Gi t",
            subject: "Ch ",
            nosubject: "Khng c ch ",
            file: {
                toolarge: "Khng nh km c file c kch thc qu ln",
                tryagain: "Li khng nh km c file. Mi bn th li."
            },
            fieldsrequire: "Nhiu thng tin khng c  trng.",
            uploaderror: "Li ti tp tin ln, vui lng th li.",
            confirmdelete: "Bn c mun xa th ny?",
            content: "Ni dung th",
            messageorigin: " ----- Thng ip gc: ----- ",
            downnloadAll: "Ti xung tt c",
            attachList: "Danh sch tp nh km"
        },
        savedraft: {
            success: "Lu nhp thnh cng",
            error: "Lu nhp tht bi, vui lng th li sau."
        },
        sendmail: {
            success: " gi",
            sendding: "ang gi",
            error: "Khng th gi tin, vui lng th li sau."
        },
        error: {
            hasError: "C li xy ra, vui lng th li sau.",
            connectionError: "Kt ni n my ch tht bi, vui lng th li sau."
        }
    }
    //#endregion
})
(window, window.egov = window.egov || {}, window.bmail = window.bmail || {});

(function (egov, Offline) {

    "use strict";

    var RequestManager = function () {
        /// <summary>
        /// i tng qun l cc ajax http request t client ln server.
        /// </summary>
        var check;

        this.profilers = [];

        this.dataDefaults = {
            type: 'GET',
            async: true,
            traditional: false,
            //global: false
        }

        // Kim tra c url trng nhau
        // Khi thm mi 1 query nu trng s b bo ngay.
        check = _.find(_.groupBy(_queries, function (q) { return q.url; }), function (g) {
            return g.length > 1;
        });

        if (check != null) {
            console.log("Lp url, kim tra li  m bo khng b lp: ");
            console.log(check);
        }

        // Kim tra tn trng nhau
        check = _.find(_.groupBy(_queries, function (q) { return q.name; }), function (g) {
            return g.length > 1;
        });

        if (check != null) {
            console.log("Lp tn query, kim tra li  m bo khng b lp");
            console.log(check);
        }

        this.model = _queries;

        this.setDefaultAjaxSetting();
        this.init();

        this._profilers();
    }

    RequestManager.prototype.setDefaultAjaxSetting = function () {
        /// <summary>
        /// X l cc thit lp chung cho mi ajax http request
        /// </summary>

        // X l li mc nh
        //$(document).ajaxError(function (e, jqXHR) {
        //    //if (jqXHR.status === 200) {

        //    //    // X l cc m li  y
        //    //    // window.location.replace(egov.getRelativeEndpointUrl('/Error.html'));
        //    //    egov.log(jqXHR);
        //    //}
        //});
    }

    RequestManager.prototype.init = function () {
        /// <summary>
        /// Render cc function theo cu hnh
        /// </summary>
        /// <returns type="this"></returns>
        var that = this, name;

        //cha danh sch ajax property khi run ajax call d liu =>  c th phng thc ajax
        this.aborts = {};

        // Render cc function theo tn cc query trong danh sch
        _.each(this.model, function (query) {
            name = query['name'];
            that[name] = function (ajaxOption) {
                /// <summary>
                /// T ng to hm theo tn ca query.
                /// </summary>
                /// <param name="ajaxOption" type="object">jQuery ajax option</param>

                // closure: query
                var processName = query.name + JSON.stringify(ajaxOption.data) + "processing";
                that._exeQuery(query, ajaxOption);
                //if (!that[processName]) {
                //    that._exeQuery(query, ajaxOption);
                //} else {
                //    egov.log("Gi lp chc nng " + query.name);
                //}
            }
        });

        return this;
    }

    RequestManager.prototype._exeQuery = function (query, ajaxOption) {
        /// <summary>Private: hm thc thi mt query</summary>
        /// <param name="query" type="QueryModel">Query cn thc thi</param>
        /// <param name="ajaxOption" type="object">Ajax option</param>
        var type,
            callerOptions,
            defaultOptions,
            tokenId,
            processName,
            beforeSendOption,
            completeOption,
            successOption,
            that = this;

        processName = query.name + JSON.stringify(ajaxOption.data);
        defaultOptions = $.extend({}, that.dataDefaults);

        if (query['async'] !== undefined) {
            defaultOptions.async = query['async'];
        }
        defaultOptions.async = true;

        if (query['traditional'] !== undefined) {
            defaultOptions.dataType = 'json';
            defaultOptions.traditional = query['traditional'];
        }

        if (query['hasToken'] !== undefined) {
            tokenId = '#' + query['url'].replace(/\//g, '');
            ajaxOption.data['__RequestVerificationToken'] = $("input[name='__RequestVerificationToken']", tokenId).val();
        }

        beforeSendOption = ajaxOption.beforeSend;
        ajaxOption.beforeSend = function (xhr, settings) {
            that[processName] = true;
            that.profilers.push({
                processName: processName,
                Name: settings.url,
                Started: new Date
            });

            if (typeof beforeSendOption === 'function')
                beforeSendOption();
        };

        successOption = ajaxOption.success;
        ajaxOption.success = function (result) {
            var profiler = _.find(that.profilers, function (p) { return p.processName === processName });
            profiler && (profiler.durations = new Date - profiler.Started);

            delete that[processName];
            if (typeof successOption === 'function')
                successOption(result);
        };

        completeOption = ajaxOption.complete;
        ajaxOption.complete = function () {
            console.log(that.profilers);
            delete that[processName];

            if (typeof completeOption === 'function')
                completeOption();
        };

        ajaxOption.data = ajaxOption.data || {};
        ajaxOption.data.puid = egov.userid;
        callerOptions = $.extend({}, defaultOptions, query, ajaxOption);

        //Overide li XmlhttpRequest  ly trng thi kt ni ca request y c tr v  nh trng thi kt ni
        if (Offline && !egov.isMobile) {
            Offline.options.checks = {
                xhr: callerOptions
            };
        }

        this.aborts[query['name']] = $.ajax(callerOptions);
    }

    //#region Log Profilers

    RequestManager.prototype._profilers = function () {
        setInterval(function () {
            if (this.profilers.length === 0) return;

            var data = _.map(this.profilers, function (p) {
                return {
                    Name: p.Name,
                    Started: p.Started.toServerString(),
                    DurationMilliseconds: p.durations
                }
            });

            this.profilers = [];

            $.ajax({
                url: '/profiler/updateclient',
                type: 'Post',
                data: { json: JSON.stringify(data) },
                complete: function () {

                }
            });
        }.bind(this), 5 * 1000);
    }

    //#endregion

    //#region Private Fields

    // Danh sch tt c cc query t client ln server
    var _queries = [

        //#region Common
        
        { name: 'getDataCompile', url: '/Document/GetDataCompile' },

        // Ly danh sch tt c user trong h thng
        { name: 'getAllUsers', url: '/Common/GetAllUsers' },

        // Ly danh sch tt c category trong h thng
        { name: 'getCategories', url: '/Common/GetCategories' },

        // Ly danh sch tt c department theo user trong h thng
        { name: 'getDepartmentsByUser', url: '/Common/GetDepartmentsByUser' },

        // Ly danh sch tt c department theo user trong h thng
        { name: 'getDepartmentsCurrent', url: '/Common/GetCurrentDepartments' },

        // Ly danh sch tt c department trong h thng
        { name: 'getAllDepartment', url: '/Common/GetAllDepartment' },

        // Ly danh sch tt c jobtitle trong h thng
        { name: 'getAllJobTitlies', url: '/Common/getAllJobTitlies' },

        { name: 'getAllUserDepartmentJobTitlesPosition', url: '/Common/GetAllUserDepartmentJobTitlesPosition' },

        // Ly ra danh sch tt c cc chc v trong h thng
        { name: 'getAllPosition', url: '/Common/GetAllPosition' },

        { name: 'getAllAddress', url: '/Common/GetAllAddress' },

        // Ly danh sch tt c user trong h thng
        { name: 'getKeywords', url: '/Common/GetKeywords' },

        // Ly danh sch tt c user trong h thng
        { name: 'getDocField', url: '/Common/GetDocField' },

        { name: 'getSendTypes', url: '/Common/GetSendTypes' },

        { name: 'getDeptAndUsers', url: '/Common/GetDeptAndUsers' },

        // Ly danh sch bng m.
        { name: 'GetCodes', url: '/Common/GetCodes', type: 'Get' },

        // Ly danh sch c quan ban hnh ca n v hin ti.
        { name: 'getOrganizations', url: '/Common/GetOrganizations', type: 'Get' },

        //#endregion

        //#region Vn bn

        //Sa vn bn
        { name: 'editNew', url: '/Document/EditNew/', type: 'Get' },

        // Ly ni dung form
        { name: 'getFormContent', url: '/Document/GetFormContent' },

        // Ly ni dung form
        { name: 'getFormUrl', url: '/Document/GetFormUrl' },

        // Xc nhn bn giao
        { name: 'confirmTransfer', url: '/Document/ConfirmTransfer', type: 'Post', hasToken: true },

        // Xc nhn x l
        { name: 'confirmProcess', url: '/Document/ConfirmProcess', type: 'Post', hasToken: true },

        // Ly danh sch vn bn lin quan
        { name: 'getDocumentRelations', url: '/document/GetDocumentRelations', type: 'Get' },

        // Gia hn x l h s
        { name: 'renewals', url: '/Document/Renewals', type: 'Post' },

        // Ly quyn thao tc x l vn bn h s
        { name: 'getDocumentPermission', url: '/Document/GetDocumentPermission', traditional: true, async: true },

        // Sa vn bn
        { name: 'getDocumentInfoForEdit', url: '/Document/GetDocumentDetail' },

        // Sa vn bn
        { name: 'getMultiDocument', url: '/Document/GetDocumentDetails', traditional: true, },

        // M vn bn mobile
        { name: 'getDocumentInfoForMobile', url: '/Document/getDocumentInfoForMobile' },

         // To vn bn mobile
        { name: 'getDocumentInfoForCreateMobile', url: '/Document/GetDocumentInfoForCreateMobile' },

        // To vn bn
        { name: 'getDocumentInfoForCreate', url: '/Document/GetDocumentInfoForCreate' },

        // Ly li vn bn  cc node
        { name: 'getContextItemForUndoTransfering', url: '/Document/GetContextItemForUndoTransfering/' },

        // Xa vn bn/h s
        { name: 'removeDocument', url: '/Document/RemoveDocument', type: 'Post', hasToken: true, traditional: true, },

        // Ly li vn bn
        { name: 'undoTransfering', url: '/Document/UndoTransfering', type: 'Post', hasToken: true },

        // Ly nhng ngi nhn vn bn  undo li
        { name: 'getUsersForUndoTransfering', url: '/Document/GetUsersForUndoTransfering' },

        // Set trang thi c vn bn
        { name: 'setDocumentViewed', url: '/Document/SetViewed/', type: 'Post' },

        // Sa h s ng k trc tuyn
        { name: 'editDocumentOnline', url: '/Document/EditDocumentOnline/' },

        // Sa ni dung h s
        { name: 'editDocumentContent', url: '/Document/EditContent/', type: 'Post' },

        // Tr v cc phin bn ca ni dung vn bn
        { name: 'getDocumentContentVersion', url: '/Document/getDocumentContentVersion', type: 'Get' },

        // Lay y kien thuong dung cua nguoi dung
        { name: 'getCommonComments', url: '/Document/GetCommonComments/' },

        // Lay y kien thuong dung cua nguoi dung
        { name: 'getTemplateComments', url: '/Document/GetTemplateComments/' },

        { name: 'createTemplateComments', url: '/Document/CreateTemplateComments/', type: 'Post' },

        //Cap nhat mu template  kin m ngi dng  son mu trc
        { name: 'updateTemplateComments', url: '/Document/UpdateTemplateComments', type: 'post' },

        //Tao moi mu template  kin m ngi dng  son mu trc
        { name: 'deleteTemplateComments', url: '/Document/DeleteTemplateComments', type: 'post' },

        // Tim kiem van ban
        { name: 'searchDocuments', url: '/Document/SearchDocuments', type: 'Post', traditional: true },

        // Thit lp vn bn quan trong hay khng quan trng
        { name: 'setDocumentImportant', url: '/Document/SetDocumentImportant', type: 'Post' },

        // Xem trc thng tin vn bn h s
        { name: 'quickViewDocument', url: '/Home/QuickViewDocument', type: 'Get' },

        // Ly file cu hnh form vn bn
        { name: 'getDocumentTemplate', url: '/Document/GetDocumentTemplate', type: 'Get' },

        
        // Ly file cu hnh form vn bn
        { name: 'getCatalog', url: '/Document/GetCatalog', type: 'Get' },

        // Cp nht kt qu x l cui cng
        { name: 'updateLastResult', url: '/Document/UpdateLastResult', type: 'Post' },

        // To nh t file PDf, tr v url nh
        { name: 'createImagesFromBeginAndLastPdfPages', url: '/Document/CreateImagesFromBeginAndLastPdfPages', type: 'Get' },

        { name: 'GetDocumentInfoFromScan', url: '/Parallel/GetDocumentInfoFromScan', type: 'Get', traditional: true },

         // tr v url nh
        { name: 'getImageTemp', url: '/Document/GetImageTemp', type: 'Get' },

        // Hy s  cp
        { name: 'cancelCode', url: '/Document/CancelCode', type: 'Get' },

        // Ly danh sch s k hiu, m h s
        { name: 'GetDocCodes', url: '/Document/GetDocCodes', type: 'Get' },

        // Ly danh sch s n i
        { name: 'GetInOutCode', url: '/Document/GetInOutCode', type: 'Get' },

        // Ly trng thi pht hnh
        { name: 'GetIsTransferPublish', url: '/Document/GetIsTransferPublish', type: 'Get' },

        // Xa doc paper
        { name: 'deleteDocPaper', url: '/Document/DeleteDocPaper', type: 'Post' },

        // Xa doc fee
        { name: 'deleteDocFee', url: '/Document/DeleteDocFee', type: 'Post' },

        // Thu hi vn bn
        { name: 'acceptThuHoi', url: '/Document/AcceptThuHoi', type: 'Post' },

        // Ly loi h s, vn bn
        { name: 'getDoctype', url: '/Doctype/GetDocType' },

        //Lay loai van ban
        { name: 'getDocTypes', url: '/Doctype/GetDocTypes' },

        // Tr v giy t v l ph ca doctype
        { name: 'getDoctypePaperAndFees', url: '/Doctype/GetPaperAndFees' },

        // Cp nht giy t v l ph ca loi h s
        { name: 'updateDoctypePaperAndFees', url: '/Doctype/UpdatePaperAndFees', type: 'Post' },

        // Xa doctype paper
        { name: 'deleteDoctypePaper', url: '/Document/DeleteDoctypePaper', type: 'Post' },

        // Xa doctype paper
        { name: 'deleteDoctypeFee', url: '/Document/DeleteDoctypeFee', type: 'Post' },

        // Kim tra s k hiu  c dng
        { name: 'checkDocCodeIsUsed', url: '/Document/CheckDocCodeIsUsed' },

        //#endregion

         //#region Mission (To nhim v)

        // Ly thng tin user
        { name: 'GetListUser', url: '/Mission/GetListUser', type: 'Get' },

        // To nhim v
        { name: 'CreateMission', url: '/Mission/CreateMission', type: 'post', traditional: true, async: true },

        // Ly thng tin user
        { name: 'LinkDetailMission', url: '/Mission/LinkDetailMission', type: 'post', traditional: true, async: true },

         //#endregion Mission (To nhim v)

        //#region nh km

        // Ti v tp nh km mi ti ln.
        { name: 'downloadAttachmentTemp', url: '/Attachment/DownloadAttachmentTempBase64', type: 'Get' },

        // Ti v tp nh km c sn
        { name: 'downloadAttachment', url: '/Attachment/DownloadAttachmentBase64', type: 'Get' },

        // Ti v tp nh km  k
        { name: 'downloadAttachmentForSignBase64', url: '/Attachment/DownloadAttachmentForSignBase64', type: 'Get', traditional: true },

        //Upload file scan
        { name: 'uploadTempScan', url: '/Attachment/UploadTempScan', type: 'Post' },

        //#endregion

        //#region Workflow

         // Ly danh sch cc hng chuyn vi vn bn ang edit
        { name: 'getAction', url: '/Workflow/GetActions', type: 'Get' },
        // Ly danh sch cc hng chuyn vi vn bn ang edit
        { name: 'getDocumentEditAction', url: '/Workflow/GetActionsEdit', type: 'Get' },

        // Ly danh sch cc hng chuyn vi vn bn to mi
        { name: 'getDocumentCreateAction', url: '/Workflow/GetActionsCreate', type: 'Get' },

        // Ly danh sch ngi nhn theo hng chuyn
        { name: 'getUserByAction', url: '/Workflow/GetUserByAction', type: 'Get' },

        // Ly cc hng chuyn ca ngi dng theo duwj kieen
        { name: 'getActionsTransferPlan', url: '/Workflow/GetActionsTransferPlan', type: 'Get' },

         // Ly danh sch ngi nhn theo hng chuyn theo lo
        { name: 'getUserByActionTheoLo', url: '/Workflow/GetUserByActionTheoLo', type: 'post', traditional: true },

        // Ly danh sch hng chuyn theo lo
        { name: 'getActionTheoLoVanBan', url: '/Workflow/GetActionTheoLoVanBan', type: 'post', traditional: true, async: true },

        //#endregion

        //#region X l vn bn

        // Phat hang va ket thuc
        { name: 'publishAndFinish', url: '/Transfer/PublishAndFinish', type: 'Post', traditional: true, hasToken: true },
        // Chuyn vn bn
        { name: 'transfer', url: '/Transfer/TransferDocument', type: 'Post', traditional: true, hasToken: true },
        //pht hnh phiu kho st
        { name: 'surveyRelease', url: '/Transfer/SurveyReleased', type: 'Post', traditional: true, hasToken: true },
        // hoan thnh phiu kho st
        { name: 'surveyComplete', url: '/Transfer/SurveyComplete', type: 'Post', traditional: true, hasToken: true },
        // Chinh sa cu hinh bao cao
        { name: 'surveySaveReport', url: '/Transfer/SurveySaveReport', type: 'Post', traditional: true, hasToken: true },
        // Chuyen theo lo
        { name: 'transferTheoLo', url: '/Transfer/TransferMultiple', type: 'Post', traditional: true, hasToken: true },

        // Chuyn vn bn
        { name: 'lightTransfer', url: '/Transfer/LightTransfer', type: 'Post' },

        // Chuyn  kin ng gp: cho vn bn xin  kin, ng x l.
        { name: 'TransferYKienDongGop', url: '/Transfer/TransferAnswer', type: 'Post', traditional: true, hasToken: true },

        // Tip nhn h s.
        { name: 'TransferTiepNhan', url: '/Transfer/TransferTiepNhan', type: 'Post', traditional: true, hasToken: true },

        // Thng bo
        { name: 'TransferAnnouncement', url: '/Transfer/TransferAnnouncement', type: 'Post', traditional: true, hasToken: true },

        // Xin  kin
        { name: 'TransferConsult', url: '/Transfer/TransferConsult', type: 'Post', traditional: true, hasToken: true },

        // Pht hnh bo co ln VP chnh ph
        { name: 'publishGov', url: '/Publish/TransferPublishGov', type: 'Post', traditional: true, hasToken: true },

        // Lu s v pht hnh vn bn
        { name: 'publish', url: '/Publish/TransferPublish', type: 'Post', traditional: true, hasToken: true },

        // Lu s v pht hnh ni b
        { name: 'privatePublish', url: '/Publish/TransferPrivatePublish', type: 'Post', traditional: true, hasToken: true },

        // Lu s v pht hnh ni b theo l
        { name: 'privatePublishTheoLo', url: '/Publish/TransferPrivatePublishTheoLo', type: 'Post', traditional: true, },

        // Lu s v pht hnh vn bn theo l
        { name: 'publishTheoLo', url: '/Publish/TransferPublishTheoLo', type: 'Post', traditional: true, hasToken: true },

        // D kin pht hnh
        { name: 'publishmentPlan', url: '/Publish/PublishmentPlan', type: 'Post' },

        // Pht hnh tip
        { name: 'rePublish', url: '/Publish/RePublish', type: 'Post', traditional: true },

        // Cp nht vn bn
        { name: 'saveDoc', url: '/Transfer/SaveDoc', type: 'Post', hasToken: true, traditional: true },

        // Lu vn bn d tho
        { name: 'saveDocDraft', url: '/Transfer/SaveDocDraft', type: 'Post', hasToken: true },

        // Lu vn bn d tho
        { name: 'transferLienThong', url: '/Publish/transferLienThong', type: 'Post', hasToken: true, traditional: true },

        // Thu hi vn bn lin thng
        { name: 'recalledLienThong', url: '/Publish/RecalledLienThong', type: 'Post', hasToken: true, traditional: true },

        // Gi lin thng li
        { name: 'resendLienThong', url: '/Transfer/ResendLienThong', type: 'Post', hasToken: true, traditional: true },

        // Gi  kin
        { name: 'sendComment', url: '/Document/SendComment', type: 'Post', hasToken: true },

         // nh chnh vn bn
        { name: 'dinhchinh', url: '/Finish/DinhChinh', type: 'Post' },
         // Kt thc x l vn bn
        { name: 'fiAndPub', url: '/Finish/FinishAndPublish', type: 'Post', hasToken: true },

        // Kt thc x l vn bn
        { name: 'finish', url: '/Finish/UpdateFinish', type: 'Post', hasToken: true },

         // Ly li vn bn  kt thc
        { name: 'undoFinish', url: '/Finish/UndoFinish', type: 'Post' },

        // K duyt
        { name: 'approverSend', url: '/Approver/Send', type: 'Post', hasToken: true },

        { name: 'deleteApprover', url: '/Approver/deleteApprover', type: 'Post', hasToken: true },

        { name: 'deleteResult', url: '/Document/DeleteResult', type: 'Post', hasToken: true },

        //#endregion

        //#region hi p

        { name: 'getNodeQuestion', url: '/Question/GetNode', type: 'Get' },

        { name: 'getsQuestion', url: '/Question/GetQuestions', type: 'Get' },

        { name: 'answerQuestion', url: '/Question/Answer', type: 'POST' },

        { name: 'rejectQuestion', url: '/Question/Reject', type: 'POST' },

        { name: 'forwardQuestion', url: '/Question/ForwardQuestion', type: 'POST' },

        { name: 'rejectAnswer', url: '/Question/RejectAnswer', type: 'POST' },

        { name: 'getForwardList', url: '/Question/GetForwardList', type: 'Get' },

        { name: 'getsHolderList', url: '/Question/GetsHolderList', type: 'Get' },

        //#endregion

        //#region H s c nhn

        // Ly danh sch S vn bn
        { name: 'GetStores', url: '/Common/GetStores', type: 'Get' },

        // Ly danh sch h s c nhn, h s chia s
        { name: 'getStorePrivate', url: '/StorePrivate/Gets', type: 'Get' },

        // To mi h s c nhn,h s chia s
        { name: 'createStorePrivate', url: '/StorePrivate/Create', type: 'Post', hasToken: true, traditional: true },

        // Cp nht h s c nhn. h s chia s
        { name: 'updateStorePrivate', url: '/StorePrivate/Update', type: 'Post', hasToken: true, traditional: true },

        { name: 'anycStoreShare', url: '/StorePrivate/AnycStoreShare', type: 'Get' },

        // M h s c nhn. h s chia s
        { name: 'openStorePrivate', url: '/StorePrivate/Open', type: 'Post', hasToken: true },

        // ng h s c nhn. h s chia s
        { name: 'closeStorePrivate', url: '/StorePrivate/Close', type: 'Post', hasToken: true },

        // Xa h s c nhn. h s chia s
        { name: 'deleteStorePrivate', url: '/StorePrivate/Delete', type: 'Post', hasToken: true },

        // Ly danh sch vn bn h s trong h s c nhn, h s chia s
        { name: 'getStorePrivateDocuments', url: '/StorePrivate/GetDocuments', type: 'Post' },

        // Xa vn bn ra khi h s
        { name: 'removeStorePrivateDocument', url: '/StorePrivate/RemoveDocuments', type: 'Post', traditional: true },

        //Ly danh sch ngi dng trong h s c nhn. h s chia s
        { name: 'getUserJoined', url: '/StorePrivate/GetUserJoined', type: 'Get' },

        //Thm vn bn vo h s c nhn/chia s
        { name: 'SaveDocumentToStorePrivate', url: '/Document/SaveDocumentToStorePrivate', type: 'Post', hasToken: true },

        // M file t h s c nhn, h s chia s
        { name: 'storePrivateOpenFile', url: '/StorePrivate/DownloadAttachmentBase64', type: 'Get' },

        // Xo file trong h s
        { name: 'storePrivateRemoveFile', url: '/StorePrivate/RemoveAttachment', type: 'post', hasToken: true },

        // Loi h s khi h s thng bo
        { name: 'removeDocumentAnnouncement', url: '/Document/RemoveDocumentAnnouncement', type: 'post' },

        //#endregion

        //#region Danh sch vn bn

        // Ly danh sch vn bn theo kho
        { name: 'getDocumentStore', url: '/Home/GetDocumentStore' },

        //#endregion

        //#region Cy vn bn

        //Ly danh sch cy vn bn
        { name: 'getDocumentTree', url: '/Home/GetFunctionByParentId', type: 'get' },

        //Ly danh sch cy vn bn c hng chuyn theo l
        { name: 'getDocumentTreeHasTransferTheoLo', url: '/Home/GetFunctionHasTransferTheoLoByParentId', type: 'get' },

        // Ly danh sch cy vn bn
        { name: 'syncDocumentStore', url: '/Home/SyncDocumentStore' },

        // Ly danh sch cc kho vn bn
        { name: 'getFunctionGroups', url: '/Home/GetFunctionGroups' },

        //#endregion

        //#region Home

        // Ly cc cu hnh ca ngi dng
        { name: 'getCommonConfigs', url: '/Home/GetCommonConfigs', type: 'Get' },

        // Ly cc cu hnh b lu s
        { name: 'hasHideSaveStore', url: '/Home/HasHideSaveStore', type: 'Post' },

        // Ly ngy ht hn
        { name: 'getDateAppointed', url: '/Document/GetDateAppointed', type: 'Post' },

        // Thit lp cc config ca ngi dng
        { name: 'setUserConfig', url: '/Account/SetUserConfig/', type: 'Post' },

        // Thit lp cc config ca ngi dng
        { name: 'setPopUpSize', url: '/Account/setPopUpSize/', type: 'Post' },

        { name: 'filterCitizen', url: '/Document/FilterCitizen/', type: 'Get' },

        // Trang in
        { name: 'print', url: '/Print/Index', type: 'Get' },

        { name: 'previewPrint', url: '/Print/PreviewPrint', type: 'Get' },

        // Tr v danh sch cc phiu in ca h s 
        { name: 'getPrints', url: '/Print/GetPrints', type: 'Get' },

        // Tr v danh sch cc mu phiu in theo nghip v
        { name: 'getPrintTemplates', url: '/Print/GetPrintTemplates', type: 'Get' },

        // Tr v danh sch cc mu phiu in theo danh sch h s
        { name: 'getPrintByDocCopys', url: '/Print/GetPrintByDocCopys', type: 'Get' },

        // In phiu bin nhn
        { name: 'quickPrint', url: '/Print/QuickPrint', type: 'Get' },

        { name: 'getPrinters', url: '/Print/GetActivePrinters', type: 'Get' },

        { name: 'printTransferHistory', url: '/Print/PrintTransferHistory', type: 'Get' },

        // Tr v d liu cho form tr kt qu
        { name: 'getReturnResult', url: '/Return/GetReturnResult', type: 'Get' },

        // Tr v d liu cho form tr kt qu
        { name: 'updateReturn', url: '/Return/UpdateReturn', type: 'Post' },

        // Form yu cu b sung mi
        { name: 'createSupplementary', url: '/Supplementary/CreateSupplementary', type: 'Get' },

        // Tip nhn b sung
        { name: 'receiveSupplementary', url: '/Supplementary/GetDetails', type: 'Get' },

        // Tip nhn b sung - Posts
        { name: 'supplementaryReceive', url: '/Supplementary/Receive', type: 'Post' },

        // Tr v ngy hn tr mi khi tip nhn b sung
        { name: 'getNewDateAppointed', url: '/Supplementary/GetDateAppointed', type: 'Get' },

        // To yu cu b sung h s
        { name: 'sendRequiredSupplementary', url: '/Supplementary/SendRequire', type: 'Post', hasToken: true },

        // Hy yu cu b sung
        { name: 'cancelReceiveSupplementary', url: '/Supplementary/CancelReceive', type: 'Post', hasToken: true },

        // Tip tc x l
        { name: 'continueProcess', url: '/Supplementary/continueProcess', type: 'Post' },

        //Tm kim nhanh
        { name: 'quickSearch', url: '/Search/QuickSearch', type: 'Get', traditional: true },

        { name: 'getMailTemplates', url: '/Document/GetMailTemplates', type: 'Get', },

        { name: 'getSmsTemplates', url: '/Document/GetSmsTemplates', type: 'Get', },

        { name: 'sendMailToPeople', url: '/Document/SendMailToPeople', type: 'Post', },

        { name: 'sendSmsToPeople', url: '/Document/SendSmsToPeople', type: 'Post', },

        { name: 'getVersionValue', url: '/Home/GetVersionValue', type: 'Get' },


        //#endregion

        //#region Khc - kim tra li nu khng dng th b

        // Ly ra tng s cc vn bn h s cha c
        { name: 'getTotalDocumentUnreadMultiFunction', url: '/Parallel/GetTotalDocumentUnreadMultiFunction', type: 'Post' },

        { name: 'getTotalDocumentUnread', url: '/Home/GetTotalDocumentUnread', type: 'Post' },

        // Ly danh sch h s, vn bn
        { name: 'getDocuments', url: '/home/GetDocuments', type: 'Post' },

        // Ly ton b danh sch vn bn ca node hin ti
        { name: 'getAllDocument', url: '/Home/GetAllDocument', type: 'Post' },

        // Ly danh sch h s vn bn theo phn trang
        { name: 'getDocumentPaging', url: '/Home/GetDocumentPaging', type: 'Post' },

        // Ly danh sch h s, vn bn mi c thm vo node v nhng vn bn xa khi node
        { name: 'getLastestDocuments', url: '/Home/GetLastestDocuments', type: 'Post', traditional: true },

          // Ly danh sch h s, vn bn mi c thm vo node v nhng vn bn xa khi node
        { name: 'getLastestReports', url: '/HomeSMReport/GetLastestDocuments', type: 'Post', traditional: true },

         { name: 'getReports', url: '/HomeSMReport/GetDocuments', type: 'Post', traditional: true },

        //Tm kim nng cao
        { name: 'searchAdvance', url: '/Search/SearchAdvance', type: 'Get', traditional: true },

        //ly form tm kim nng cao
        { name: 'getSearchAdvanceForm', url: '/Search/GetSearchAdvanceForm', type: 'Get', },

        //ly form tm kim nng cao
        { name: 'getDiffVersionTrees', url: '/Home/DiffVersionTree', type: 'Get', },

        //#endregion

        //#region ng k qua mng

        //tiep nhan
        { name: 'acceptOnline', url: '/DocumentOnline/AcceptOnline', type: 'Post' },

        //tu choi
        { name: 'rejectOnline', url: '/DocumentOnline/RejectOnline', type: 'Post' },

        //tu choi
        { name: 'onlineSupplementary', url: '/DocumentOnline/OnlineSupplementary', type: 'Post' },

        { name: 'additionalRequirements', url: '/DocumentOnline/AdditionalRequirements', type: 'Post' },

        //Tong so van ban dang ky qua mang
        { name: 'getTotalOnlineRegistration', url: '/DocumentOnline/GetTotalOnlineRegistration', type: 'Get' },

         //Danh sach van ban dang ky qua mang
        { name: 'getDocumentOnlineRegistration', url: '/DocumentOnline/GetDocumentOnlineRegistration', type: 'Get' },

        //Tong so van ban dang ky qua mang b hy b
        { name: 'getTotalOnlineCancel', url: '/DocumentOnline/GetTotalOnlineCancel', type: 'Get' },

         //Danh sach van ban dang ky qua mang b hy b
        { name: 'getDocumentOnlineCancel', url: '/DocumentOnline/GetDocumentOnlineCancel', type: 'Get' },

        //chi tiet hos dang ky qua mang
        { name: 'getDocumentDetailOnlineRegistration', url: '/DocumentOnline/GetDocumentDetailOnlineRegistration', type: 'Get' },

        //Kim tra h s cng dn ang ng k trc tuyn
        { name: 'checkDocumentOnline', url: '/DocumentOnline/CheckDocumentOnline/', type: 'Get' },

        //Kim tra danh sch h s ang c ca cng dn trn h thng
        { name: 'checkDocument', url: '/DocumentOnline/CheckDocument/', type: 'Get' },

        //M li cng vn kt thc nhm
        { name: 'reOpenDocument', url: '/Document/ReOpenDocument', type: 'Get' },

        //Xuat danh sach ra file
        { name: 'exportToFile', url: '/Home/ExportToFile', type: 'Post' },

          //Ly mu phi ca mail, sms
        { name: 'editTemplate', url: '/Document/EditTemplate', type: 'Get' },

        //#endregion

        //#region Mobile

        // Ly tng s vn bn thng bo
        { name: 'notificationsCount', url: '/Mobile/GetNotificationsCount', type: 'Get' },

        // Thit lp cc config ca ngi dng cho Mobile
        { name: 'setMobileUserConfig', url: '/Account/SetMobileUserConfig/', type: 'Post', hasToken: true },

        //#endregion

        //Ly Xa tp nh km
        { name: 'removeAttachment', url: '/Attachment/RemoveAttachment', type: 'Post' },

        // ly tng s cu hi chung
        { name: 'getTotalGeneralQuestion', url: '/Question/GetTotal?isGetGeneral=true', type: 'Get' },

        // ly tng s cu hi theo h s
        { name: 'getTotalDocumentQuestion', url: '/Question/GetTotal?isGetGeneral=false', type: 'Get' },

         //#region Giy php doanh nghip
        { name: 'getBusinessLicense', url: '/BusinessLicense/BusinessLicenses', type: 'Get' },

         //#region Giy php doanh nghip
        { name: 'removeBusinessLicense', url: '/BusinessLicense/RemoveLicenses', type: 'Post', traditional: true },

           //#region Giy php doanh nghip
        { name: 'createCitizen', url: '/BusinessLicense/CreateCitizen', type: 'Post', traditional: true },

            //#region Giy php doanh nghip
        { name: 'createLicense', url: '/BusinessLicense/CreateLicense', type: 'Post', traditional: true },
        //#endregion

        // To mi ha n
        { name: 'createInvoice', url: '/DocumentInvoice/ImportInvoice', type: 'Post' },

        // ly ha n
        { name: 'getInvoice', url: '/DocumentInvoice/LookupInvoice', type: 'Get' },

        // chi tit ha n
        { name: 'getDetailInvoice', url: '/DocumentInvoice/DetailInvoice', type: 'Get' },

        // chi tit ha n
        { name: 'removeInvoice', url: '/DocumentInvoice/RemoveInvoice', type: 'Post' },

        //#region Mobile

        // Ly tng s vn bn thng bo
      { name: 'createVote', url: '/Referendum/Vote', type: 'Post', traditional: true },
      { name: 'updateVote', url: '/Referendum/VoteUpdate', type: 'Post', traditional: true },
      { name: 'deleteVote', url: '/Referendum/DeleteVote', type: 'Post', traditional: true },
      // Ly tng s cc vote cu ngi dng hin ti
      { name: 'getVotes', url: '/Referendum/GetVotes', type: 'Get' },
      // Ly tng s cc vote cu ngi dng hin ti
      { name: 'getVoteDetail', url: '/Referendum/GetVoteDetail', type: 'Get' },
      // DeleteVote
      { name: 'createCommentDiff', url: '/Referendum/CreateCommentDiff', type: 'Post', traditional: true },
      // 
      { name: 'checkVote', url: '/Referendum/CheckVote', type: 'Post', traditional: true },

      // Gui
      { name: 'checkVoteResult', url: '/Referendum/CheckVoteResult', type: 'Post', traditional: true },
        // 
      { name: 'uncheckVote', url: '/Referendum/UncheckVote', type: 'Post', traditional: true },
      { name: 'getUserInfos', url: '/Referendum/GetUserInfos', type: 'get' },
      { name: 'getVoteDetailReload', url: '/Referendum/GetVoteDetailReload', type: 'get' },


        //#endregion
        //#endregion

    ];

    //#endregion

    egov.request = new RequestManager();
})
(this.egov = this.egov || {}, window.Offline);
// bt.util.date.js

/*
    Author: TienBV
    DateCreated: 25/06/2015
    Version: 1.0

    Description:

    - Cc n v thi gian:
        year: "year",
        quarter: "quarter",
        month: "month",
        week: "week",
        date: "date",
        day: "day",
        hour: "hours",
        minute: "minutes",
        second: "seconds",
        miniSecond: "miniSecond"

    - Cc nh dng format
        yy: "yy",                   // Nm: 96, 97, ... 14, 15
        yyyy: "yyyy",               // Nm y : 1996, 1997, ... 2014, 2015
        q: "q",                     // Qu: 1, 2, 3, 4
        M: "M",                     // Thng: 1, 2, ... 12
        MM: "MM",                   // Thng y : 01, 02, ... 12
        MMM: "MMM",                 // Thng: Th1, Th2, ... Th12
        MMMM: "MMMM",               // Thng: Thng mt, Thng hai, ... Thng mi hai
        w: "w",                     // Tun: 1, 2, ... 52
        ww: "ww",                   // Tun: 01, 02, ... 52
        d: "d",                     // Ngy trong thng: 1, 2, ... 31
        dd: "dd",                   // Ngy trong thng: 01, 02, ... 31
        ddd: "ddd",                 // Ngy trong tun: Th 2, th 3, ... 
        h: "h",                     // Gi (12): 1, 2, ... 12    
        hh: "hh",                   // Gi (12): 01, 02, ... 12
        H: "H",                     // Gi (24): 1, 2, ... 23
        HH: "HH",                   // Gi (24): 01, 02, ... 23
        a: "a",                     // Am/pm: am/pm
        A: "A",                     // Am/pm: AM/PM
        m: "m",                     // Pht: 1, 2, ... 59
        mm: "mm",                   // Pht: 01, 02, ... 59
        s: "s",                     // Giy: 1, 2, ... 59
        ss: "ss",                   // Giy: 01, 02, ... 59
        sss: "sss",                 // Tch tc: 1, 2, ... 999
        z: "z",                     // Timezone: EST CST ... MST PST

    - Cc method cho kiu d liu Date

        + parse(value, format): Chuyn i string sang datetime theo format ch nh. Mc nh h thng parse theo ISODate format.
            Date.parse("2015-07-15T16:20:04.021Z")  = Wed Jul 15 2015 09:20:04 GMT-0700 (Pacific Daylight Time)
            Date.parse("2015-07-15", "yyyy-MM-dd)  = Wed Jul 15 2015 09:20:04 GMT-0700 (Pacific Daylight Time)
            
            Notes: s c trong phin bn 1.1

        + daysInMonth(month, year): Tr v s ngy trong thng.
            Date.daysInMonth(7, 2015)  = 31

        + compare(date1, date2): Tr v kt qu so snh gia 2 i tng ngy thng.
            Notes: s c trong phin bn 1.1

        + max([date1, date2, ...]): Tr v i tng ngy thng ln nht.
            Notes: s c trong phin bn 1.1

        + min([date1, date2, ...]): Tr v i tng ngy thng nh nht.
            Notes: s c trong phin bn 1.1

    - Cc method cho i tng d liu String

        + format(partern): Convert ngy thng theo chui theo nh dng yu cu v tr v kt qu; partern mc nh hh:mm dd/MM/yyyy (Vn_vi)
            new Date().format("dd/MM/yy") = "15/07/15"
          
        + subtract(value, unit): Tr i mt khong thi gian theo n v thi gian ( trn) ca i tng ban u v tr v i tng mi.
            new Date().subtract(1, "month").format("dd/MM/yy") = "15/06/15"

        + add(value, unit): Tr i mt khong thi gian theo n v thi gian ( trn) ca i tng ban u v tr v i tng mi.
            new Date().add(1, "month").format("dd/MM/yy") = "15/06/15"

        + month(value): Ly hoc thit lp thng ca i tng thi gian hin ti: 1, 2, ... 12
            new Date().month() = 07
            new Date().month(12).format("dd/MM/yy") = "15/12/15";

        + year(value): Tng t hm month  trn.
            new Date().year() = 2015
            new Date().year(2017).format("dd/MM/yy") = "15/07/17";

        + date(value): Ly hoc thit lp ngy trong thng ca i tng thi gian hin ti: 1, 2, ... 31
            new Date().date() = 15
            new Date().date(24).format("dd/MM/yy") = "24/07/17";

        + day(): Tr v th t ngy trong tun ca i tng thi gian hin ti tnh t ch nht: 0, 6
            new Date().day() = 03

        + weekOfYear():  Tr v th t tun trong nm ca i tng thi gian hin ti: 1, 2, ... 52
            new Date().weekOfYear() = 29

        + dayOfYear(): Tr v th t ngy trong nm ca i tng thi gian hin ti: 1, 2, ... 365 (366)
            new Date().dayOfYear() = 196

        + hours(value): Ly hoc thit lp gi ca i tng thi gian hin ti: 1, 2, ... 23
            var d = new Date(); d.setHours(15); d.format("hh:mm")    = "15:33"

        + minutes(value): Tng t hours

        + seconds(value): Tng t hours

        + miniSeconds(value): Tng t hours

        + quarter(): Tr v qu ca i tng thi gian hin ti
            new Date().quarter() = 3

        + endOf(): Thit lp i tng thi gian hin ti thnh thi im cui cng theo n v thi gian truyn vo v tr v ngy mi tng ng.
            new Date().endOf("year").format("dd/MM/yyyy")   = "31/12/2015"          ( Ngy cui cng trong nm )
            new Date().endOf("month").format("dd/MM/yyyy")  = "31/07/2015"          ( Ngy cui cng trong thng )
            new Date().endOf("day").format()                = "23:59 15/07/2015"    ( Thi im cui cng trong ngy)
            ...

        + startOf(): Tng t endOf
            new Date().startOf("year").format("dd/MM/yyyy")   = "01/01/2015"          ( Ngy u tin trong nm )
            new Date().startOf("month").format("dd/MM/yyyy")  = "01/07/2015"          ( Ngy u tin trong thng )
            new Date().startOf("day").format()                = "00:00 15/07/2015"    ( Thi im u tin trong ngy)
            ...

        + isLeapYear(): Tr v gi tr xc nh nm hin ti c phi l nm nhun khng; true = nm nhun; false = khng.
            new Date().subtract(1, "year").isLeapYear() = true;
*/


bt_util_date_resource = {
    vi: {
        months: ["thng 1", "thng 2", "thng 3", "thng 4", "thng 5", "thng 6", "thng 7", "thng 8", "thng 9", "thng 10", "thng 11", "thng 12"],
        shortMonths: ["Th1", "Th2", "Th3", "Th4", "Th5", "Th6", "Th7", "Th8", "Th9", "Th10", "Th11", "Th12"],
        weeks: ["ch nht", "th hai", "th ba", "th t", "th nm", "th su", "th by"],
        shortWeeks: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
        times: {
            future: '%s ti',
            ago: '%s trc',
            s: 'vi giy',
            m: 'mt pht',
            mm: '%d pht',
            h: 'mt gi',
            hh: '%d gi',
            d: 'mt ngy',
            dd: '%d ngy',
            M: 'mt thng',
            MM: '%d thng',
            y: 'mt nm',
            yy: '%d nm'
        },
        calendar: {
            sameDay: 'Hm nay',
            nextDay: 'Ngy mai',
            lastDay: 'Hm qua',
            sameWeek: 'Tun ny',
            nextWeek: 'Tun ti',
            lastWeek: 'Tun trc',
            sameMonth: 'Thng ny',
            lastMonth: 'Thng trc'
        }
    }
};

(function (window) {
    "use strict";

    var _date, _prototype, _unitType, _formatObject, _formatTokens, _defaultFormat, _resource, _defaultFarseFormat;
    _date = Date;
    _prototype = _date.prototype;
    _unitType = {
        year: "year",
        quarter: "quarter",
        month: "month",
        week: "week",
        date: "date",
        day: "day",
        hour: "hours",
        minute: "minutes",
        second: "seconds",
        miniSecond: "miniSecond"
    };
    _formatTokens = /(\[[^\[]*\])|(\\)?(MM?M?M?|dd?d?|ww?|q|yy?yy?|a|A|hh?|HH?|mm?|ss?s?|z|.)/g;
    _defaultFormat = "hh:mm dd/MM/yyyy";
    _defaultFarseFormat = "yyyy-MM-ddTHH:mm:ss";
    _formatObject = {
        yy: "yy",                   // Nm: 96, 97, ... 14, 15
        yyyy: "yyyy",               // Nm: 1996, 1997, ... 2014, 2015
        q: "q",                     // Qu: 1, 2, 3, 4
        M: "M",                     // Thng: 1, 2, ... 12
        MM: "MM",                   // Thng: 01, 02, ... 12
        MMM: "MMM",                 // Thng: Th1, Th2, ... Th12
        MMMM: "MMMM",               // Thng: Thng mt, Thng hai, ... Thng mi hai
        w: "w",                     // Tun: 1, 2, ... 52
        ww: "ww",                   // Tun: 01, 02, ... 52
        d: "d",                     // Ngy trong thng: 1, 2, ... 31
        dd: "dd",                   // Ngy trong thng: 01, 02, ... 31
        ddd: "ddd",                 // Ngy trong tun: Th 2, th 3, ... 
        h: "h",                     // Gi (12): 1, 2, ... 12    
        hh: "hh",                   // Gi (12): 01, 02, ... 12
        H: "H",                     // Gi (24): 1, 2, ... 23
        HH: "HH",                   // Gi (24): 01, 02, ... 23
        a: "a",                     // Am/pm: am/pm
        A: "A",                     // Am/pm: AM/PM
        m: "m",                     // Pht: 1, 2, ... 59
        mm: "mm",                   // Pht: 01, 02, ... 59
        s: "s",                     // Giy: 1, 2, ... 59
        ss: "ss",                   // Giy: 01, 02, ... 59
        sss: "sss",                 // Tch tc: 1, 2, ... 999
        z: "z",                     // Timezone: EST CST ... MST PST 
    };
    _resource = bt_util_date_resource["vi"];

    //#region Prototype Methods

    _prototype.format = function Date$format(partern) {
        /// <summary>
        /// Convert ngy thng thnh chui theo nh dng yu cu
        /// </summary>
        /// <param name="partern">nh dng chui cn xut ra.</param>
        var formats, leng, match, i, formatResult;
        var result = "";

        partern = partern || _defaultFormat;
        formats = partern.match(_formatTokens);
        leng = formats.length;

        for (i = 0; i < leng; i++) {
            match = formats[i].toString();
            match = match.replace("[", "").replace("]", "");
            result += isFormatting(match) ? this._getFormattingValue(match) : match;
        }

        return result;
    }

    _prototype.subtract = function Date$subtract(value, unit) {
        /// <summary>
        /// Tr i mt khong thi gian v tr v khong thi gian mi t thi gian ban u.
        /// </summary>
        /// <param name="value">Gi tr tr</param>
        /// <param name="unit">Trng thi gian cn tr</param>
        switch (unit) {
            case _unitType.year:
                this.year(this.year() - value);
                break;
            case _unitType.month:
                this.month(this.month() - value);
                break;
            case _unitType.date:
                this.date(this.date() - value);
                return this;
            case _unitType.hour:
                this.hours(this.hours() - value);
                break;
            case _unitType.minute:
                this.minutes(this.minutes() - value);
                break;
            case _unitType.second:
                this.seconds(this.seconds() - value);
                break;
            case _unitType.miniSecond:
                this.miniSeconds(this.miniSeconds() - value);
                break;
            default:
                break;
        }

        return this;
    }

    _prototype.add = function Date$add(value, unit) {
        /// <summary>
        /// Thm mt khong thi gian vo thi gian ban u v tr v thi gian mi
        /// </summary>
        /// <param name="value">Khong thi gian cn thm</param>
        /// <param name="unit">Trng thi gian cn thm</param>
        switch (unit) {
            case _unitType.year:
                this.year(this.year() + value);
                break;
            case _unitType.month:
                this.month(this.month() + value);
                break;
            case _unitType.date:
                this.date(this.date() + value);
                return this;
            case _unitType.hour:
                this.hours(this.hours() + value);
                break;
            case _unitType.minute:
                this.minutes(this.minutes() + value);
                break;
            case _unitType.second:
                this.seconds(this.seconds() + value);
                break;
            case _unitType.miniSecond:
                this.miniSeconds(this.miniSeconds() + value);
                break;
            default:
                break;
        }

        return this;
    }

    _prototype.month = function Date$month(value) {
        /// <summary>
        /// Ly hoc thit lp thng ca ngy ny: 1,2 ... 12
        /// </summary>

        if (value == 2 && this.date() > 28) {
            this.date(28);
        }

        if (hasValue(value)) {
            this.setMonth(value - 1);
            return this;
        }

        return this.getMonth() + 1;
    }

    _prototype.year = function Date$year(value) {
        /// <summary>
        /// Ly hoc thit lp nm ca ngy ny
        /// </summary>
        if (hasValue(value)) {
            this.setFullYear(value);
            return this;
        }

        return this.getFullYear();
    }

    _prototype.date = function Date$date(value) {
        /// <summary>
        /// Ly hoc thit lp ngy trong thng ca ngy ny
        /// </summary>
        /// <param name="value" type="int">Ngy cn set, gn null  ly gi tr.</param>

        if (hasValue(value)) {
            this.setDate(value);
            return this;
        }

        return this.getDate();
    }

    _prototype.day = function Date$day() {
        /// <summary>
        /// Tr v ngy trong tun ca ngy ny
        /// </summary>

        return this.getDay();
    }

    _prototype.weekOfYear = function Date$week() {
        /// <summary>
        /// Tr v tun trong nm ca ngy ny
        /// </summary>
        var firstDay = new Date(this.getFullYear(), 0, 1);
        return Math.ceil((((this - firstDay) / 86400000) + firstDay.day() - 1) / 7);
    }

    _prototype.dayOfYear = function Date$dayOfYear() {
        /// <summary>
        /// Tr v ngy trong nm ca ngy ny, v d ngy th 234 ca 365
        /// </summary>
        var firstDay = new Date(this.getFullYear(), 0, 1);
        return Math.ceil((this - firstDay) / 86400000);
    }

    _prototype.hours = function Date$hours(value) {
        /// <summary>
        /// Ly hoc thit lp gi ca ngy ny
        /// </summary>

        if (hasValue(value)) {
            this.setHours(value);
            return this;
        }

        return this.getHours();
    }

    _prototype.minutes = function Date$minutes(value) {
        /// <summary>
        /// Ly hoc thit lp pht ca ngy ny
        /// </summary>

        if (hasValue(value)) {
            this.setMinutes(value);
            return this;
        }

        return this.getMinutes();
    }

    _prototype.seconds = function Date$seconds(value) {
        /// <summary>
        /// Ly hoc thit lp giy ca ngy ny
        /// </summary>
        if (hasValue(value)) {
            this.setSeconds(value);
            return this;
        }

        return this.getSeconds();
    }

    _prototype.miniSeconds = function Date$miniSeconds(value) {
        /// <summary>
        /// Ly hoc thit lp mini giy ca ngy ny
        /// </summary>

        if (hasValue(value)) {
            this.setMilliseconds(value);
            return this;
        }

        return this.getMilliseconds();
    }

    _prototype.quarter = function Date$quarter() {
        /// <summary>
        /// Tr v qu ca ngy ny
        /// </summary>
        return Math.floor(((this.month() - 1) / 3) + 1);
    }

    _prototype.endOf = function Date$endOf(unit) {
        /// <summary>
        /// Thit lp ngy hin ti thnh thi im cui cng ca n v truyn vo v tr v ngy mi tng ng.
        /// </summary>
        /// <param name="unit">
        /// n v:
        /// - "year": thit lp ngy hin ti v ngy cui cng trong nm vi ngy hin ti.
        /// - "quarter": thit lp ngy hin ti v ngy cui cng ca qu vi ngy hin ti
        /// - "month": thit lp ngy hin ti v ngy cui cng trong thng vi ngy hin ti.
        /// - "week": thit lp ngy hin ti v ngy cui cng trong tun vi ngy hin ti.
        /// - "day": thit lp ngy hin ti v thi im 23:59:59 ca ngy hin ti.
        /// - "hour": thit lp ngy hin ti v thi im 59:59 ca gi hin ti.
        /// - "minute": thit lp ngy hin ti v thi im 59s ca pht hin ti.
        /// - "second": thit lp ngy hin ti v thi im 999ms ca giy hin ti.
        /// </param>
        if (_unitType[unit] === undefined) {
            throw "n v truyn vo khng hp l.";
        }

        var year, quarter, month, days, date;
        year = this.year();
        quarter = this.quarter();
        month = this.month();
        date = this.date();

        switch (unit) {
            case _unitType.year:
                this.month(12).date(31).hours(23).minutes(59).seconds(59).miniSeconds(999);
                break;
            case _unitType.quarter:
                month = quarter * 3;
                days = _date.daysInMonth(month, year);
                this.month(month).date(days).hours(23).minutes(59).seconds(59).miniSeconds(999);
                break;
            case _unitType.month:
                days = _date.daysInMonth(month, year);
                this.date(days).hours(23).minutes(59).seconds(59).miniSeconds(999);
                break;
            case _unitType.week:
                days = date - this.day() + 6;
                this.date(days).hours(23).minutes(59).seconds(59).miniSeconds(999);
                break;
            case _unitType.day:
                this.hours(23).minutes(59).seconds(59).miniSeconds(999);
                break;
            case _unitType.hour:
                this.minutes(59).seconds(59).miniSeconds(999);
                break;
            case _unitType.minute:
                this.seconds(59).miniSeconds(999);
                break;
            case _unitType.second:
                this.miniSeconds(999);
                break;
        }

        return this;
    }

    _prototype.startOf = function Date$startOf(unit) {
        /// <summary>
        /// Thit lp ngy hin ti thnh thi im u tin ca n v truyn vo v tr v ngy mi tng ng.
        /// </summary>
        /// <param name="unit">
        /// n v:
        /// - "year": thit lp ngy hin ti v ngy u tin trong nm vi ngy hin ti.
        /// - "quarter": thit lp ngy hin ti v ngy u tin ca qu vi ngy hin ti
        /// - "month": thit lp ngy hin ti v ngy u tin trong thng vi ngy hin ti.
        /// - "week": thit lp ngy hin ti v ngy u tin trong tun vi ngy hin ti.
        /// - "day": thit lp ngy hin ti v thi im 12:00:00 am ca ngy hin ti.
        /// - "hour": thit lp ngy hin ti v thi im 00:00 ca gi hin ti.
        /// - "minute": thit lp ngy hin ti v thi im 00s ca pht hin ti.
        /// - "second": thit lp ngy hin ti v thi im 000ms ca giy hin ti.
        /// </param>
        if (_unitType[unit] === undefined) {
            throw "n v truyn vo khng hp l.";
        }

        var quarter, month, days, date;
        quarter = this.quarter();
        date = this.date();

        switch (unit) {
            case _unitType.year:
                this.month(1).date(1).hours(0).minutes(0).seconds(0).miniSeconds(0);
                break;
            case _unitType.quarter:
                month = quarter * 3 - 2;
                this.month(month).date(1).hours(0).minutes(0).seconds(0).miniSeconds(0);
                break;
            case _unitType.month:
                this.date(1).hours(0).minutes(0).seconds(0).miniSeconds(0);
                break;
            case _unitType.week:
                days = date - this.day();
                this.date(days).hours(0).minutes(0).seconds(0).miniSeconds(0);
                break;
            case _unitType.day:
                this.hours(0).minutes(0).seconds(0).miniSeconds(0);
                break;
            case _unitType.hour:
                this.minutes(0).seconds(0).miniSeconds(0);
                break;
            case _unitType.minute:
                this.seconds(0).miniSeconds(0);
                break;
            case _unitType.second:
                this.miniSeconds(0);
                break;
        }

        return this;
    }

    _prototype.isLeapYear = function Date$isLeapYear() {
        /// <summary>
        /// Tr v gi tr xc nh nm hin ti c phi l nm nhun khng.
        /// </summary>
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    _prototype._getFormattingValue = function Date$_getFormattingValue(partern) {
        var result;
        switch (partern) {
            case _formatObject.yy:
                result = this.year().toString().substr(2, 2);
                break;
            case _formatObject.yyyy:
                result = this.year();
                break;
            case _formatObject.q:
                result = this.quarter();
                break;
            case _formatObject.M:
                result = this.month();
                break;
            case _formatObject.MM:
                result = toDigit(this.month());
                break;
            case _formatObject.MMM:
                result = _resource.shortMonths[this.month() - 1];
                break;
            case _formatObject.MMMM:
                result = _resource.months[this.month() - 1];
                break;
            case _formatObject.d:
                result = this.date();
                break;
            case _formatObject.dd:
                result = toDigit(this.date());
                break;
            case _formatObject.ddd:
                result = _resource.weeks[this.day()];
                break;
            case _formatObject.h:
                result = to12Hour(this.hours());
                break;
            case _formatObject.hh:
                result = toDigit(to12Hour(this.hours()));
                break;
            case _formatObject.H:
                result = this.hours();
                break;
            case _formatObject.HH:
                result = toDigit(this.hours());
                break;
            case _formatObject.m:
                result = this.minutes();
                break;
            case _formatObject.mm:
                result = toDigit(this.minutes());
                break;
            case _formatObject.s:
                result = this.seconds();
                break;
            case _formatObject.ss:
                result = toDigit(this.seconds());
                break;
            case _formatObject.S:
                result = this.miniSeconds();
                break;
            case _formatObject.Z:
                result = this.year();
                break;
            default:
                result = "";
                break;
        }
        return result;
    }

    _prototype.relativeDate = function () {
        /// <summary>
        /// Time ago
        /// </summary>

        var seconds = Math.floor((new Date() - this) / 1000);
        var interval = Math.floor(seconds / 31536000);

        if (interval > 1) {
            return interval + " nm";
        }
        interval = Math.floor(seconds / 2592000);
        if (interval > 1) {
            return interval + " Thg";
        }
        interval = Math.floor(seconds / 604800);
        if (interval > 1) {
            return interval + " tun";
        }
        interval = Math.floor(seconds / 86400);
        if (interval > 1) {
            return interval + " ngy";
        }
        interval = Math.floor(seconds / 3600);
        if (interval > 1) {
            return interval + " gi";
        }
        interval = Math.floor(seconds / 60);
        if (interval > 1) {
            return interval + " pht";
        }
        return "Va mi";
    }

    _prototype.toServerString = function Date$toServerString() {
        //2017-10-25T11:04:23
        return this.format(_defaultFarseFormat);
    }

    _prototype.getVNDay = function () {
        var day = this.getDay();
        return bt_util_date_resource.vi.weeks[day];
    }

    _prototype.timeInWord = function () {
        /// <summary>
        ///
        /// </summary>

        var date = this; var distanceMillis;
        var now = Date.now();

        var today = now.format("yyyyMMwwdd");
        var lastDay = now.subtract(1, _unitType.date).format("yyyyMMwwdd");
        var week = now.format("yyyyMMww");
        var lastWeek = now.subtract(1, _unitType.week).format("yyyyMMww");
        var month = now.format("yyyyMM");
        var lastMonth = now.subtract(1, _unitType.month).format("yyyyMM");

        var year = now.format("yyyy");

        var dateFormat = date.format("yyyyMMwwddhh");
        if (dateFormat.indexOf(today) === 0) {
            return _resource.calendar.sameDay;
        }
        if (dateFormat.indexOf(lastDay) === 0) {
            return _resource.calendar.lastDay;
        }

        if (dateFormat.indexOf(week) === 0) {
            return _resource.calendar.sameWeek;
        }
        if (dateFormat.indexOf(lastWeek) === 0) {
            return _resource.calendar.lastWeek;
        }

        if (dateFormat.indexOf(month) === 0) {
            return _resource.calendar.sameMonth;
        }
        if (dateFormat.indexOf(lastMonth) === 0) {
            return _resource.calendar.lastMonth;
        }

        if (dateFormat.indexOf(year) === 0)
            return date.format("[Thng] MM");

        return date.format("[Thng] MM - yyyy");
    }

    _prototype.isToday = function () {
        var today = Date.now().format("yyyyMMdd");
        var date = this.format("yyyyMMdd");
        return date === today;
    }

    _prototype.isYesterday = function () {
        var yesterday = new Date().add(-1, _unitType.date).format("yyyyMMdd");
        var date = this.format("yyyyMMdd");
        return date === yesterday;
    },

    //#endregion

    //#region Statis Methods

    _date.parse = function Date$parse(value, format) {
        /// <summary>
        /// Chuyn i string thnh nh dng ngy thng theo format ch nh
        /// </summary>
        /// <param name="value"></param>
        /// <param name="format"></param>
        format = format || _defaultFarseFormat;

        if (!value)
            return null;

        if (Globalize) {
            return Globalize.parseDate(value, format)
        }

        return null;
    }

    _date.parseFromIsoString = function Date$parseFromIsoString(input) {
        var arr = input.split(/[^0-9]/);
        return new Date(arr[0], arr[1] - 1, arr[2], arr[3], arr[4], arr[5]);
    }

    _date.daysInMonth = function Date$daysInMonth(month, year) {
        /// <summary>
        /// Tr v s ngy trong thng
        /// </summary>
        /// <param name="month">Thng</param>
        /// <param name="year">Nm</param>
        return new Date(year, month, 0).date();
    }

    _date.compare = function Date$compare(date1, date2) {
        /// <summary>
        /// So snh 2 ngy thng v tr v kt qu so snh nh hn, bng, ln hn.
        /// </summary>
        /// <param name="date1">Ngy 1</param>
        /// <param name="date2">Ngy 2</param>
        /// <returns type="int">1-ngy 1 ln hn ngy 2; 0-ngy 1 bng ngy 2; -1-ngy 1 nh hn ngy 2</returns>
    }

    _date.max = function () {
        /// <summary>
        /// Tr v ngy ln nht ca kiu d liu Date
        /// </summary>
    }

    _date.min = function () {
        /// <summary>
        /// Tr v ngy nh nht ca kiu d liu Date
        /// </summary>
    }

    _date.now = function () {
        return new Date;
    }

    //#endregion

    //#region Private Methods

    var hasValue = function (value) {
        /// <summary>
        /// Tr v kt qu kim tra gi tr phi l null hay khng.
        /// </summary>
        /// <param name="value">Gi tr</param>
        return value !== undefined && value !== null;
    };

    var _isObject = function (obj) {
        /// <summary>
        /// Tr v kt qu kim tra gi tr c phi l mt object khng
        /// </summary>
        /// <param name="obj"></param>
        return typeof obj === "object";
    };

    var _isNumber = function (val) {
        /// <summary>
        /// Tr v kt qu kim tra gi tr hin ti c phi l 1 number hay khng.
        /// </summary>
        /// <param name="val"></param>

    };

    var toDigit = function (number) {
        return number > 9 ? number : ("0" + number);
    };

    var to12Hour = function (value) {
        return value > 12 ? (value - 12) : value;
    };

    var isFormatting = function (value) {
        return _formatObject[value] !== undefined;
    };

    //#endregion
})(this);
// bt.util.string.js

/*
    Author: TienBV
    DateCreated: 25/06/2015
    Version: 1.0

    Description:

    - Cc method cho kiu d liu String

        + format:               String.format("Ti l {0}", "TienBV")   => return: "Ti l TienBV"

        + isNullOrEmpty:        String.isNullOrEmpty("")                => return: true

        + isNullOrWhiteSpace:   String.isNullOrWhiteSpace("   ")        => return: true

        + isString:             String.isString("TienBV")               => return: true

    - Cc method cho i tng d liu String

        + trim, trimStart, trimEnd: ct cc k t trng  2 u chui, hoc u chui, hoc cui chui
            "   Bkav v i   ".trim()        = "Bkav v i"; 
            "   Bkav v i   ".trimStart()   = "Bkav v i   "; 
            "   Bkav v i   ".trimEnd()     = "   Bkav v i";

        + startWith(prefix, ignoreCase): Tr v gi tr xc nh chui cn kim tra c phi nm  u chui hin ti khng.
            "Bkav v i".startWith("Bkav")         = true;  
            "Bkav v i".startWith("bKaV", true)   = true;

        + endWith(prefix, ignoreCase)      => tng t startWith

        + equals(value, ignoreCase): Tr v gi tr xc nh chui cung cp c bng vi chui hin ti khng.
            "Bkav v i".equals("Bkav v i")         = true; 
            "Bkav v i".equals("Bkav V i", true)   = true

        + remove(startIndex, count): Tr v chui sau khi  xa nhng k t  cc v tr truyn vo.
            "Bkav v i".remove(4)             = "Bkav";
            "Bkav v i".remove(0, 5)          = "v i";

        + replaceAll(searchValue, replaceValue): Tr v chui sau khi thay th cc chui c c ch nh bng chui mi.
            "Bkav v i".replaceAll("v", "i")  = "Bkai i i";

        + contains(value): Tr v gi tr xc nh chui cn kim tra c thuc chui hin ti khng.
            "Bkav v i".contains("v")        = true;

        + toCharArray():  Tr v mt mng tt c cc k t trong chui
            "Bkav".toCharArray()        = ["B", "k", "a", "v"]

        + reverse(): o chui
            "Bkav".reverse()            = "vakB";

        + removeVietnamChars(): loi b du ting vit
            "Bkav v i".removeVietnamChars()      = "Bkav vo doi";

*/

(function () { var t = String, n = t.prototype, i = ["a", "A", "d", "D", "e", "E", "i", "I", "o", "O", "u", "U", "y", "Y"]; n.trim = function () { return this.replace(/^\s+|\s+$/g, "") }; n.trimStart = function () { return this.replace(/^\s+/, "") }; n.trimEnd = function () { return this.replace(/\s+$/, "") }; n.startWith = function (n, t) { if (!String.isString(n)) throw "Gi tr truyn vo khng hp l"; return t = t || !1, n.equals(this.substr(0, n.length), t) }; n.endWith = function (n, t) { if (!String.isString(n)) throw "Gi tr truyn vo khng hp l"; return t = t || !1, n.equals(this.substr(this.length - n.length), t) }; n.equals = function (n, t) { if (!String.isString(n)) throw "Gi tr truyn vo khng hp l"; return t = t || !1, t ? this.toLowerCase() === n.toLowerCase() : this.toString() === n }; n.remove = function (n, t) { var i; if (typeof n != "number") throw "Start Index phi l mt ch s"; return i = this.slice(0, n), t != undefined && typeof t == "number" && (i += this.slice(n + t)), i }; n.replaceAll = function (n, t) { if (!String.isString(n) || !String.isString(t)) throw "Cc tham s truyn vo phi l string"; var i = new RegExp(n.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"); return this.replace(i, t) }; n.contains = function (n) { if (!String.isString(n)) throw "Tham s truyn vo phi l chui"; return this.indexOf(n) > -1 }; n.toCharArray = function () { return this.split("") }; n.reverse = function () { return this.split("").reverse().join("") }; n.forEach = function (n) { if (typeof n == "function") for (var i = this.length, t = 0; t < i; t++) n(this.charAt(t), t) }; n.removeVietnamChars = function () { var t = [], r = this, n; return r.forEach(function (r, u) { for (t[u] = r, n = 0; n < i.length; n++) if (i[n].contains(r)) { t[u] = i[n][0]; break } }), t.join("") }; t.format = function () { return String._toFormattedString(!1, arguments) }; t.isNullOrEmpty = function (n) { return n === null || n === undefined || n === "" }; t.isNUllOrWhiteSpace = function (n) { return n = n.trim(), String.isNullOrEmpty(n) }; t.isString = function (n) { return typeof n == "string" }; t._toFormattedString = function (n, t) { for (var o, u, c, r, e = "", f = t[0], i = 0; ;) { if (o = f.indexOf("{", i), u = f.indexOf("}", i), o < 0 && u < 0) { e += f.slice(i); break } if (u > 0 && (u < o || o < 0)) { if (f.charAt(u + 1) !== "}") throw new Error("format stringFormatBraceMismatch"); e += f.slice(i, u + 1); i = u + 2; continue } if (e += f.slice(i, o), i = o + 1, f.charAt(i) === "{") { e += "{"; i++; continue } if (u < 0) throw new Error("format stringFormatBraceMismatch"); var s = f.substring(i, u), h = s.indexOf(":"), l = parseInt(h < 0 ? s : s.substring(0, h), 10) + 1; if (isNaN(l)) throw new Error("format stringFormatInvalid"); c = h < 0 ? "" : s.substring(h + 1); r = t[l]; (typeof r == "undefined" || r === null) && (r = ""); e += r.toFormattedString ? r.toFormattedString(c) : n && r.localeFormat ? r.localeFormat(c) : r.format ? r.format(c) : r.toString(); i = u + 1 } return e } })(this);


(function (egov, $, _) {
    var regexUtcDate = /\d{4}-[0-1]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-6]\d$/;

    egov.commonFn = {
        event: {
            changeTitleForMobile: function (app, title) {
                $("#header-title span[data-app='" + app + "']").text(title);
            },

            showNavbar: function () {
                $("#main-page").removeClass("hidelayoutnav");
            },

            hideNavbar: function () {
                $("#main-page").addClass("hidelayoutnav");
            },

            //Logout
            logout: function () {
                var cookies = document.cookie.split(";");
                for (var i = 0; i < cookies.length; i++) {
                    var eqPos = cookies[i].indexOf("=");
                    var name = eqPos > -1 ? cookies[i].substr(0, eqPos) : cookies[i];
                    name = name.trim();
                    $.cookie(name, "", { domain: document.domain, path: "/", expires: -1, secure: true });
                    $.cookie(name, "", { expires: -1, secure: true });
                }
                if (helper.isTool) {
                    if (typeof window.external.CB_Logout === 'function') {
                        window.external.CB_Logout();
                    }
                    $.cookie("isLogin", "", { expires: -1, secure: true });
                }
                window.document.location.reload();
            },
        },
        util: {
            getCustomTime: function (date, isGetOverdue) {
                /// <summary>
                /// Ly ngy qu hn x l vn bn cho Mobile
                /// </summary>
                /// <param name="date">Ngy truyn vo</param>
                /// <param name="isGetOverdue">true nu ly c hn tng, dng cho Mobile</param>
                if (date == null || date == '') {
                    return "";
                }

                if (regexUtcDate.test(date) || (date instanceof Date)) {
                    if (regexUtcDate.test(date)) {
                        var array = date.split(/[^0-9]/);
                        date = new Date(array[0], array[1] - 1, array[2], array[3], array[4], array[5])
                    } else {
                        date = new Date(date);
                    }
                }
                else {
                    date = new Date(date);
                }

                var dateNow = new Date();
                var diff = ((dateNow.getTime() - date.getTime()) / 1000);

                //Nu ly thi hn x l th o ngc li
                if (isGetOverdue) {
                    diff = diff * -1;
                }

                var day_diff = Math.floor(diff / 86400);

                if (day_diff < 0) {
                    day_diff = Math.abs(day_diff);
                    if (day_diff > 365) {
                        return String.format(egov.resources.documents.documentNumberYearOverdue, Math.round(day_diff / 365));
                    }
                    else if (day_diff > 30) {
                        return String.format(egov.resources.documents.documentNumberMonthOverdue, Math.round(day_diff / 30));
                    }
                    else if (day_diff > 6) {
                        return String.format(egov.resources.documents.documentNumberWeekOverdue, Math.round(day_diff / 7));
                    }

                    return String.format(egov.resources.documents.documentNumberDayOverdue, day_diff); //  'QH ' + Math.abs(day_diff) + ' ngy';
                }
                else if (day_diff === 0 && date.getDate() === dateNow.getDate()) {
                    if (diff < 120) {
                        return String.format(egov.resources.time.minbefore, 1);
                    }
                    else if (diff < 3600) {
                        return String.format(egov.resources.time.minbefore, Math.floor(diff / 60));
                    }
                    else {
                        return date.format("HH:mm");
                    }
                }
                else if (dateNow.getDate() - date.getDate() === 1 && dateNow.getMonth() == date.getMonth()) {
                    return egov.resources.time.yesterday; // + ", " + date.format("HH:mm")
                }
                else if (date.weekOfYear() === dateNow.weekOfYear()) {
                    return date.getVNDay();
                }
                else if (date.getFullYear() === dateNow.getFullYear()) {
                    return date.format("dd/M");
                }

                return date.format("dd/MM/yy");
            },

            getCommonTime: function (date) {
                /// <summary>
                /// Ly ngy x l thng thng
                /// </summary>
                /// <param name="date">Ngy truyn vo</param>
                if (date == null || date == '') {
                    return egov.resources.documents.unlimitedTime;
                }

                if (regexUtcDate.test(date) || (date instanceof Date)) {
                    if (regexUtcDate.test(date)) {
                        var array = date.split(/[^0-9]/);
                        date = new Date(array[0], array[1] - 1, array[2], array[3], array[4], array[5])
                    } else {
                        date = new Date(date);
                    }
                }
                else {
                    date = new Date(date);
                }

                var dateNow = new Date();
                var diff = ((dateNow.getTime() - date.getTime()) / 1000);

                var day_diff = Math.floor(diff / 86400);
                if (day_diff < 0) {
                    //Trng hp ny thi gian ca server chy nhanh hn thi gian hin ti ca client
                    return egov.resources.time.justnow;
                }
                else if (day_diff === 0 && date.getDate() === dateNow.getDate()) {
                    if (diff < 120) {
                        return String.format(egov.resources.time.minbefore, 1);
                    }
                    else if (diff < 3600) {
                        return String.format(egov.resources.time.minbefore, Math.floor(diff / 60));
                    }
                    else {
                        return date.format("HH:mm");
                    }
                }
                else if (dateNow.getDate() - date.getDate() === 1 && dateNow.getMonth() == date.getMonth()) {
                    return egov.resources.time.yesterday; //  + ", " + date.format("HH:mm")
                }
                else if (date.weekOfYear() === dateNow.weekOfYear()) {
                    return date.getVNDay();
                }
                else if (date.getFullYear() === dateNow.getFullYear()) {
                    return date.format("dd/MM");
                }
                return date.format("dd/M/yy");
            },

            getDetailDate: function (date, format) {
                if (date == null || date == '') {
                    return egov.resources.documents.unlimitedTime;
                }
                if (regexUtcDate.test(date) || (date instanceof Date)) {
                    if (regexUtcDate.test(date)) {
                        var array = date.split(/[^0-9]/);
                        date = new Date(array[0], array[1] - 1, array[2], array[3], array[4], array[5])
                    } else {
                        date = new Date(date);
                    }
                }
                else {
                    date = new Date(date);
                }
                if (!format) {
                    return date.format("dd/MM/yyyy");
                }
                return date.format(format);
            }
        },

    }
})
(egov = window.egov || {}, $, _);


(function () {

    var Dialog = {
        _confirmEl: "#confirm.mdl-dialog",
        _confirmActionsEl: '#confirmActions.mdl-dialog',
        _tranferEl: "#tranfer.mdl-dialog",

        confirm: function (options) {
            var title = options.title;
            var message = options.message;
            var confirm = options.confirm;
            var cancel = options.cancel;
            var $el = $(this._confirmEl);
            var el = document.querySelector(this._confirmEl);

            document.querySelector(".confirm-dialog .mdl-dialog__content").textContent = message;
            document.querySelector(".confirm-dialog .mdl-dialog__title").textContent = title;

            document.querySelector(".confirm-dialog .btnConfirm, .confirm-dialog .btnCancel").removeEventListener("click", null);

            document.querySelector(".confirm-dialog .btnConfirm").addEventListener("click", function () {
                el.style["display"] = "none";
                el.close();

                if (typeof confirm === "function")
                    confirm();
                return;
            });

            document.querySelector(".confirm-dialog .btnCancel").addEventListener("click", function () {
                el.style["display"] = "none";
                el.close();

                if (typeof cancel === "function")
                    cancel();

                return;
            });

            el.style["display"] = "block";
            if (!el.showModal) {
                dialogPolyfill.registerDialog(el);
            }

            el.showModal();

        },

        confirmActions: function (options) {
            var title = options.title;
            var message = options.message;
            var el = document.querySelector(this._confirmActionsEl);

            $(".confirmActions-dialog .mdl-dialog__content").text(message);
            $(".confirmActions-dialog .mdl-dialog__title").text(title);
            this.firstAction = options.buttons[0];
            this.secondaryAction = options.buttons[1];

            var firstActionEl = $(".confirmActions-dialog .btnFirstAction");
            var secondaryActionEl = $(".confirmActions-dialog .btnSecondaryAction");

            firstActionEl.off('click');
            secondaryActionEl.off('click');

            firstActionEl.removeClass('hidden');
            firstActionEl.text(this.firstAction.text);
            firstActionEl.on("click", this.firstActionHandler.bind(this));

            secondaryActionEl.removeClass('hidden');
            secondaryActionEl.text(this.secondaryAction.text);
            secondaryActionEl.on("click", this.secondaryActionHander.bind(this));

            $(".confirmActions-dialog .btnCancel").on("click", function () {
                el.style["display"] = "none";
                el.close();
                return;
            });

            el.style["display"] = "block";
            if (!el.showModal) {
                dialogPolyfill.registerDialog(el);
            }

            el.showModal();
        },
                
        firstActionHandler: function (e) {
            var el = document.querySelector(this._confirmActionsEl);
            el.style["display"] = "none";
            el.close();

            this.firstAction && (typeof this.firstAction.callback === "function") && this.firstAction.callback();
            e.preventDefault();
        },

        secondaryActionHander: function (e) {
            var el = document.querySelector(this._confirmActionsEl);
            el.style["display"] = "none";
            el.close();

            this.secondaryAction && (typeof this.secondaryAction.callback === "function") && this.secondaryAction.callback();
            e.preventDefault();
        }
};

egov.dialog = Dialog;

})();
(function (egov) {

    egov.template = {

        // ======================================================
        documentList: {
            DocumentItem: "text!templates/document_list_item.html"
        },

        // ======================================================
        document: {
            mobileInfo: "text!templates/document-info.html",
            mobileCreate: "text!templates/document-create.html",
            commentMobile: "text!templates/document-comment.html",
            attachment: "text!templates/document-attachment.html",
        },

        bmail: {
            folderItem: "text!templates/bmail-folder-item.html",
            listItem: "text!templates/bmail-list-item.html",
            detail: "text!templates/bmail-detail.html",
            toolbar: "text!templates/bmail-toolbar.html",
            attachmentItem: "text!templates/bmail-attachment-item.html",
            createOrReply: 'text!templates/bmail-createorreply.html',
        },

        // ======================================================
        transfer: {
            transferMobile: 'text!templates/transfer-mobile.html',
            transferItemMobile: 'text!templates/transferItem-mobile.html',
            transferExtendMobile: 'text!templates/transferExtend-mobile.html'
        },

        calendar: {
            detail: 'text!templates/calendar-detail.html',
            item: 'text!templates/calendar-list-item.html'
        },

        toolbar: {
            mobile: "text!templates/document/toolbar-tablet-mobile.html"
        },

        notifyItem: "text!templates/notification-list-item.html",

        contact: {
            listItem: 'text!/scripts/mobile/templates/contact-list-item.html',
        },
        history: {
            listItem: 'text!/scripts/mobile/templates/history_list_item.html',
        },
        chat: {
            messageView: 'text!templates/chat-message.html',
            messageGroup: 'text!templates/chat-message-chattergroup.html',
            messageItem: 'text!templates/chat-message-item.html',
            messageFileItem: 'text!templates/chat-message-fileitem.html',
            messageImgItem: 'text!templates/chat-message-imgitem.html',
            messageInfo: 'text!templates/chat-message-info.html',
            imagePreview: 'text!templates/chat-message-preview.html',
            config: 'text!templates/chat-message-config.html'
        },

        search: {
            document: 'text!templates/search-document.html',
            documentResult: 'text!templates/search-document-item.html',
            bmail: 'text!templates/search-bmail.html',
            bmailResult: 'text!templates/search-bmail-item.html'
        }
    }
})
(this.egov = this.egov || {});
(function (egov) {

    egov.enum = {

        categoryBusiness: {
            vbden: 1,
            vbdi: 2,
            hsmc: 4,
            kntc: 8,
        },

        urgents: {
            thuong: 1,
            khan: 2,
            hoatoc: 3
        },

        securityLevel: {
            thuong: 1,
            mat: 2,
            toimat: 3
        },

        transferType: {
            xulychinh: 1,
            dongxuly: 2,
            thongbao: 3,
            xyk: 4,
            giamsat: 5
        },

        documentTransferType: {
            taoMoiThongThuong: 1,
            banGiaoThongThuong: 2,
            banGiaoKhiTraLoi: 4,
            banGiaoKhiPhanLoai: 8
        },

        documentListSize: {
            small: 0,
            medium: 1,
            large: 2
        },

        documentViewType: {
            'default': 0,
            preView: 1,     //HIn th vn bn h s  khung preview (Ngi dung thit lp hin  th ton b thng tin vn bn h s  khung xem trc vn bn)
            dialog: 2        //Hin th trn vn bn h s khi hin dialog khi click 'Chi tit vn bn '  contextmenu
        },

        quickViewType: {
            hide: 0,   ///Khng hin th tm tt vn bn
            right: 1,   //Hin th tm tt vn bn bn phi
            below: 2   //Hin th tm tt vn bn bn di
        },

        documentOriginal: {
            egov: 0,
            egovOnline: 1,
            other: 2
        },

        fontSizeType: {
            nho: 0,  //Ch nh
            vua: 1,  //Ch va
            lon: 2   //Ch ln
        },

        searchType: {
            document: 1, //Tm vn bn.
            file: 2       //Tm trong file.
        },

        processFilterType: {
            group: 1,
            equal: 2,
            custom: 3
        },

        documentStatus: {
            DuThao: 1,
            DangXuLy: 2,
            KetThuc: 4,
            LoaiBo: 8,
            DungXuLy: 16
        },

        permission: {
            khoitaovanban: 1,
            xemvanban: 2,
            dinhkem: 4,
            suavanban: 8,
            guiykien: 16,
            bangiao: 32,
            thongbao: 64,
            xinykien: 128,
            phanloai: 256,
            traloivanban: 512,
            laylaivanban: 1024,
            xacnhanbangiao: 2048,
            xacnhanxuly: 4096,
            yeucaubosung: 8192,
            tiepnhanbosung: 16384,
            kyduyet: 32768,
            traketqua: 65536,
            giahanxuly: 131072,
            dungxuly: 262144,
            ketthucxuly: 524288,
            huyvanban: 1048576,
            luuhosocanhan: 2097152,
            luuso: 4194304,
            phathanh: 8388608,
            capnhatketquaxulycuoi: 16777216,
            luuvanban: 33554432,
            traloiykien: 67108864,
            capphep: 134217728,
            doihanxulykhiphanloai: 268435456,
            molaivanban: 536870912,
            danhlaisoden: 1073741824,
            xoavanbankhoihoso: 2147483648
        },

        actionSpecial: {
            thongThuong: { name: 'ThongThuong', value: 0 },
            luuSoVaPhatHanhNoiBo: { name: 'LuuSoVaPhatHanhNoiBo', value: 1 },
            luuSoNoiBo: { name: 'LuuSoNoiBo', value: 2 },
            luuSoVaPhatHanhRaNgoai: { name: 'LuuSoVaPhatHanhRaNgoai', value: 3 },
            chuyenNguoiKhoiTao: { name: 'ChuyenNguoiKhoiTao', value: 4 },
            chuyenYKienDongGopVbDxl: { name: 'ChuyenYKienDongGopVbDxl', value: 5 },
            tiepTucXuLy: { name: 'TiepTucXuLy', value: 6 },
            chuyenNguoiCoQuyenDongGopYKien: { name: 'ChuyenNguoiCoQuyenDongGopYKien', value: 7 },
            tiepNhanHoSo: { name: 'TiepNhanHoSo', value: 8 },
            tiepNhanHoSoVaTiepTuc: { name: 'TiepNhanHoSoVaTiepTuc', value: 9 },
            capNhatKetQuaDungXuLy: { name: 'CapNhatKetQuaDungXuLy', value: 10 },
            chuyenYKienDongGopVbXinYKien: { name: 'ChuyenYKienDongGopVbXinYKien', value: 11 },
            chuyenNguoiGui: { name: 'ChuyenNguoiGui', value: 12 },
            tiepNhanBoSung: { name: 'TiepNhanBoSung', value: 13 },
            lienThong: { name: 'LienThong', value: 14 },
            transferMultiple: { name: 'TransferMultiple', value: 15 }
        },

        commentType: {
            Common: 1,
            Consulted: 2,
            Contribution: 3,
            Supplementary: 4,
            Signed: 5,
            Success: 6,
            Finished: 7
        },

        formType: {
            html: 1,
            dynamic: 2,
            fromUrl: 3
        },

        language: {
            VietNam: 1,
            Laos: 2
        },

        defaultToolbar: {
            Create: 1,
            Edit: 2,
            InsertImagePacket: 3
        },

        commonTemplate: {
            InBienNhanBanGiao: 1
        }
    };

    //#region HSMC

    egov.enum.feeType = {
        TiepNhan: 1,
        ThuongBosung: 2,
        TraCongDan: 3
    };

    egov.enum.paperType = {
        TiepNhan: 1,
        ThuongBosung: 2,
        TraCongDan: 3
    };

    egov.enum.supplementaryType = {
        renew: 1,
        "continue": 2,
        add: 3
    };

    egov.enum.printProcessType = {
        TiepNhan: 1,

        BanGiao: 2,

        KyDuyet: 4,

        TraKetQua: 8,

        TiepNhanBoSung: 16,

        GiaHan: 32
    };

    //#endregion


})(this.egov = this.egov || {});
(function (egov) {

    egov.models = egov.models || {};
    egov.viewModels = egov.viewModels || {};

    //#region Document

    egov.models.document = Backbone.Model.extend({
        defaults: {
            Address: '',
            CategoryBusinessId: 0,
            CategoryId: 0,
            CitizenInfo: null,
            CitizenName: null,
            Color: 0,
            Comment: "",
            Comments: {},
            Compendium: "",
            Compendium2: "",
            DateAppointed: "",
            DateArrived: null,
            DateCreated: new Date(),
            DateFinished: null,
            DateModified: "",
            DateOfIssueCode: null,
            DatePublished: null,
            DateReceived: "",
            DateReceivedFormat: "",
            DateResponse: null,
            DateResponsed: null,
            DateResponsedOverdue: null,
            DateResult: "",
            DateReturned: null,
            DateSuccess: null,
            DocCode: null,
            DocFieldId: null,
            DocFieldIds: null,
            DocType: {},
            DocTypeId: "",
            DocTypePermission: 0,
            DocumentCopyId: 0,
            DocumentId: "00000000-0000-0000-0000-000000000000",
            Email: null,
            IdentityCard: null,
            InOutCode: null,
            InOutPlace: "",
            IsAcknowledged: 0,
            IsConverted: 0,
            IsDocumentImportant: 0,
            IsGettingOut: 0,
            IsReturned: null,
            IsSuccess: null,
            IsSupplemented: null,
            IsViewed: 0,
            Keyword: null,
            LastComment: "",
            LastUserIdComment: 0,
            Organization: null,
            Original: 1,
            Phone: null,
            ProcessedMinutes: null,
            ResultStatus: null,
            ReturnNote: null,
            SecurityId: null,
            SendTypeId: null,
            Status: 0,
            StoreId: null,
            SuccessNote: null,
            TotalPage: null,
            UrgentId: 1,
            UserCurrentId: 0,
            UserCreatedId: 0,
            UserCurrentFirstName: "",
            UserCurrentFullName: "",
            UserReturnedId: null,
            UserSuccessId: null,
            Selected: false,
            DocumentCopyType: 0,
            DocCopyStatus: 0,
            DateOverdue: '',
            NumberDayOverdue: '0',    //hn gi
            NumberDayAppointed: '0',  //Hn tng
            IsFile: 0,                 //C phi l file hay khng(dng trong s h s):Mc nh l 0(khng phi file)
            WorkflowId: 0,            //Quy trnh ca vn bn
            NodeCurrentId: 0,          //Node hin ti ca vn bn trn quy trnh
            DocCopyDateModified: null,
            WorkflowTypes: "",
            WorkflowTypeId: "",
            WorkflowTypeName: "",
            Note: ""
        },

        initialize: function () {
            this.set('id', this.get('DocumentCopyId'));
        }
    });

    egov.models.documentList = Backbone.Collection.extend({
        model: egov.models.document
    });

    //#endregion

    //#region Document Permission

    egov.models.documentPermission = Backbone.Model.extend({
        defaults: { value: 0 }
    });

    egov.models.documentPermissionList = Backbone.Collection.extend({
        model: egov.models.documentPermission
    });

    //#endregion

    //#region Documents Toolbar

    egov.models.toolbar = Backbone.Model.extend({
        defaults: {
            text: '',
            className: '',
            disable: false,
            icon: '',
            dataUrl: '',
            shortKey: '',
            data: null,
            callback: null,
            dropdownWidth: 90,
            dropdownHeight: 0,
            position: {
                at: 'right bottom',
                my: 'right top'
            },
            contentId: '',
            isDatePicker: false,
            isDropdownMenu: false,
            hasShortKey: false,
            showSelected: false,
            defaultSelectedText: 'Tt c'
        }
    });

    egov.models.toolbarList = Backbone.Collection.extend({
        model: egov.models.toolbar
    });

    //#endregion

    //#region Context Menu

    egov.models.contextMenu = Backbone.Model.extend({
        defaults: {
            selector: null,
            trigger: 'right',   // 'left'
            dataUrl: '',        // Url ly d liu (nu c)
            param: '',          // Param cho url
            data: null,         // Danh sch cc item l th hin ca collection egov.models.ContextMenuItemModel
            callback: null,     // Hm thc thi khi select trc thi thc thi hm callback trong data
            style: {},
            position: {},
            isDatePicker: false, // t true nu mun th hin ni dung x ra l datatimepicker
            // Hin th loading trc ri bind d liu sau
            // v d: var context = selector.contextmenu({isShowLoading: true});
            // context.model.set('data', data);
            // context.render();
            isShowLoading: false,
            key: null
        },

        initialize: function () {
            var style = this.get('style');
            if (style.height === 0 || style.height === undefined) {
                style.height = 'auto';
            }

            this.set('style', $.extend({}, {
                display: 'none'
            }, style));

            this.set('position', $.extend({}, {
                at: 'right bottom',
                my: 'right top'
            }, this.get('position')));
        }
    });

    egov.models.contextMenuItem = Backbone.Model.extend({
        defaults: {
            text: '',
            value: '',
            callback: '',
            icon: '',
            selected: false
        },

        initialize: function () {
            var rootIconFolder = '/Content/Images/Toolbar/';
            if (this.get('icon') !== '') {
                this.set('icon', rootIconFolder + this.get('icon'));
            }
        }
    });

    egov.models.contextMenuList = Backbone.Collection.extend({
        model: egov.models.contextMenuItem
    });

    //#endregion

    //#region Tree

    var showTotalInTreeType = {
        none: 0,         //Khng hin th
        unread: 1,       //Vn bn cha c
        unreadOnAll: 2,  //Cha c / Tt c
        all: 3           //Tt c
    };

    egov.models.TreeModel = Backbone.Model.extend({
        defaults: {
            functionId: 0,
            parentId: 0,
            name: "",
            params: "",
            paramId: 0,
            icon: "",
            state: "closed",
            order: 0,
            totalDocumentUnread: 0,
            totalDocument: 0,
            children: [],
            url: "",
            pagingUrl: "",
            isLoadChildren: false,
            showTotalInTreeType: showTotalInTreeType.unread,
            defaultSort: null,
            hasUyQuyen: false,
            userUyQuyen: null,
            isOpen: false,
            isSelected: false,
            hasTransferTheoLo: false,
            isOnlineRegistration: false,
            treeGroupId: null,
            treeGroupOrder: 0,
            hasExportFile: false
        },

        initialize: function () {
            this.set('id', this.get('functionId'));
            var url = '/Home/GetDocuments/' + this.get('functionId');
            var pagingUrl = '/Home/GetDocumentPaging/' + this.get('functionId');
            if (typeof this.get('params') === 'object') {
                this.set('params', JSON.stringify(this.get('params')));
            }
            if (this.get('params') !== '') {
                url += '?params=' + this.get('params');
                pagingUrl += '?params=' + this.get('params');
            }
            this.set('url', url);
            this.set('pagingUrl', pagingUrl);
            this.set('isLoadChildren', false);

            //  this.set("children", new egov.models.TreeList(this.get("children") ? this.get("children") : []));

            if (typeof this.get('defaultSort') === 'object') {
                this.set('defaultSort', JSON.stringify(this.get('defaultSort')));
            }

            if (typeof this.get('userUyQuyen') === 'string') {
                this.set('userUyQuyen', JSON.parse(this.get('userUyQuyen')));
            }
        }
    });

    egov.models.TreeList = Backbone.Collection.extend({
        model: egov.models.TreeModel
    });

    egov.models.StorePrivateModel = Backbone.Model.extend({
        defaults: {
            level: 0,
            parentId: 0,
            status: 0,
            storePrivateId: 0,
            storePrivateName: "",
            name: "",
            children: [],
            state: "closed",
            url: "",
            pagingUrl: "",
            root: false,
            isStoreShared: false,
            descStorePrivate: "",
            userIdJoined: [],
            deptExtJoined: []
        },

        initialize: function () {
            var pagingUrl = '/StorePrivate/GetDocuments/' + this.get('storePrivateId');
            this.set('id', this.get('storePrivateId'));
            this.set('pagingUrl', pagingUrl);

            this.set("children", new egov.models.StorePrivateList(this.get("children") ? this.get("children") : []));
        }
    });

    egov.models.StorePrivateList = Backbone.Collection.extend({
        model: egov.models.StorePrivateModel
    });

    //#endregion

    //#region Question

    egov.models.question = Backbone.Model.extend({
        defaults: {
            QuestionId: 0,
            Date: "",
            AskPeople: "",
            Detail: "",
            Name: "",
            Email: "",
            Phone: "",
            DocCode: "",
            QuestionType: 0,
            IsGeneralQuestion: true,
            UserComments: [],
            AnswerHolder: null,
            isMe: false,
            Compendium: "",
            DocumentHolderName: "",
            DocumentHolderAccount: "",
            DocumentHolderFullAccount: "",
        },

        initialize: function () {
        }
    });

    egov.models.questionList = Backbone.Collection.extend({
        model: egov.models.question
    });

    egov.models.QuestionTreeModel = Backbone.Model.extend({
        defaults: {
            level: 0,
            status: 0,
            name: "",
            children: [],
            state: "closed",
            root: false,
            isGeneral: false
        },

        initialize: function () {
            this.set("children", new egov.models.QuestionTreeList(this.get("children") ? this.get("children") : []));
        }
    });

    egov.models.QuestionTreeList = Backbone.Collection.extend({
        model: egov.models.QuestionTreeModel
    });

    //#endregion

    //#region Tabs

    egov.models.TabModel = Backbone.Model.extend({
        defaults: {
            id: 0,
            name: '',
            title: '',
            href: '',
            hasTooltip: true,
            hasCloseButton: false,
            isRoot: false,
            privateId: 0,
            //  isCookie: false,
            attributes: {},
            isCreateDocument: false,
            type: 0,
            cateBusId: 0,
            hasLoadContent: true
        }
    });

    egov.models.TabList = Backbone.Collection.extend({
        model: egov.models.TabModel
    });

    //#endregion

    //#region Transfer

    egov.models.action = Backbone.Model.extend({
        defaults: {
            currentNodeId: 0,
            id: "",
            isAllow: true,
            isAllowSign: false,
            isSpecial: false,
            name: "",
            nextNodeId: 0,
            priority: 0,
            userIdNext: 0,
            workflowId: 0
        }
    });

    egov.models.userAction = Backbone.Model.extend({
        defaults: {
            id: 0,
            value: 0,
            label: '',
            fullname: '',
            department: '',
            username: '',
            position: '',
            isMainProcess: false,
            isCoProcess: false
        },

        initialize: function () {
            this.set('id', this.get('value'));
        }
    });

    egov.models.actionUserList = Backbone.Collection.extend({
        model: egov.models.userAction
    });

    //#endregion

    //#region Attachment

    egov.models.attachment = Backbone.Model.extend({
        defaults: {
            Id: 0,
            Name: '',
            Extension: '',
            Size: 0,
            Versions: [],
            fileData: undefined,
            isRemoved: false,
            isNew: false,
            isMofified: false,
            isOpen: false,
            icon: ''
        },

        initialize: function () {
            var extension,
                icon;

            extension = this.get('Extension');
            if (extension.indexOf('.') !== 0) {
                extension = "." + extension;
            }

            switch (extension) {
                case '.doc':
                case '.docx':
                    icon = 'icon-file-word';
                    break;
                case '.xls':
                case '.xlsx':
                    icon = 'icon-file-excel';
                    break;
                case '.pdf':
                    icon = 'icon-file-pdf';
                    break;
                case '.txt':
                    icon = 'icon-text';
                    break;
                case '.zip':
                case '.rar':
                case '.7z':
                    icon = 'icon-file-zip';
                    break;
                case '.ppt':
                case '.pptx':
                    icon = 'icon-file-powerpoint';
                    break;
                case '.html':
                    icon = 'icon-chrome';
                    break;
                case '.jpg':
                case '.jpeg':
                case '.bmp':
                case '.png':
                case '.ico':
                case '.gif':
                    icon = 'icon-image2';
                    break;
                default:
                    icon = 'icon-file4';
                    break;
            }

            this.set('icon', icon);
        }
    });

    egov.models.attachmentList = Backbone.Collection.extend({
        model: egov.models.attachment
    });

    //#endregion

    //#region Relation

    egov.models.relation = Backbone.Model.extend({
        defaults: {
            id: 0,
            RelationCopyId: 0,
            RelationId: '',
            RelationType: 0,
            IsAddNext: false,
            Compendium: '',
            CitizenName: '',
            DocCode: '',
            DateCreated: '',
            CategoryName: '',
            IsRemoved: false,
            IsNew: false
        },

        initialize: function () {
            // Thit lp id  trnh gn trng relation id
            this.set('id', this.get('RelationCopyId'));
        }
    });

    egov.models.relationList = Backbone.Collection.extend({
        model: egov.models.relation
    });

    //#endregion

    //#region QuickView

    egov.models.quickView = Backbone.Model.extend({
        defaults: {
            id: 0,
            type: 1,
            compendium: null,
            lastComment: null,
            category: null,
            department: null,
            dateCreate: null,
            lastUser: null,
            docField: null,
            urgent: null,
            docCode: null,
            totalPage: null,

            ///online
            docType: null,
            dateReceived: null,
            DateReceivedFormat: "",
            dateAppoint: null,
            personInfo: null,
            email: null,
            phone: null,
            address: null,
        },
        initialize: function () {

        }
    });

    egov.models.quickViewList = Backbone.Collection.extend({

        model: egov.models.quickView,

        initialize: function () {
        }
    });

    //#endregion

    //#region Publish

    egov.models.address = Backbone.Model.extend({
        defaults: {
            IsShow: false,
            ParentId: null
        },
        initialize: function () {
            // Set cc trng cho autocomplete
            this.set('id', this.get('AddressId'));
            this.set('value', this.get('AddressId'));
            this.set('label', this.get('Name'));
            this.set('isSelected', false);
        }
    });

    egov.models.addressCollection = Backbone.Collection.extend({
        model: egov.models.address
    });

    egov.models.publish = Backbone.Model.extend({
        defaults: {
            StoreId: 0,
            CodeId: 0,
            Code: '',
            DatePublished: new Date(),
            DateResponse: null,
            TotalPage: 1,
            SecurityId: 1,
            TotalCopy: 1,
            Approvers: '',
            KeyWordId: 0,
            InPlace: 0,
            IsCustomCode: false,
            Address: []
        }
    });

    //#endregion

    //#region Supplementary

    egov.models.supplementary = Backbone.Model.extend({
        SupplementaryId: 0,
        Comment: "",
        DateSend: "",
        IsDeleted: false,
        UserSendId: 0,
        UserSendName: ""
    });

    egov.models.supplementaryList = Backbone.Collection.extend({
        model: egov.models.supplementary
    });

    //#endregion

    //#region Search

    egov.models.search = Backbone.Model.extend({
        defaults: {
            Compendium: '',
            CategoryId: null,
            KeyWord: '',
            Content: '',
            DocCode: '',
            InOutCode: '',
            UrgentId: null,
            CategoryBusinessId: null,
            StorePrivateId: null,
            CurrentUserId: null,
            InOutPlace: '',
            FromDateStr: '',
            ToDateStr: '',
            BeforeDate: '',
            AfterDate: '',
            OrganizationCreate: '',
            DocFieldId: null,
            UserSuccessId: null
        }
    });

    egov.models.searchResultItem = Backbone.Model.extend({
        defaults: {
            Address: '',
            CategoryName: '',
            CitizenName: '',
            Compendium: '',
            DateAppointed: '',
            DateArrived: '',
            DateCreated: '',
            DocCode: '',
            DocumentCopyId: 0,
            DocumentId: '',
            InOutCode: 0,
            LastUserComment: '',
            UserSuccess: '',
            DateReceived: '',
            IsSelected: false
        }
    });

    egov.models.searchResult = Backbone.Collection.extend({
        model: egov.models.searchResultItem
    });

    //#endregion

    //#region Modal

    egov.models.modal = Backbone.Model.extend({
        defaults: {
            title: '',  // Tiu  modal
            keyboard: false, // n modal khi nhn esc
            resizable: false, // cho php thay i kch thc
            draggable: false, // cho php ko th v tr
            animation: true, // hin th dng fadein
            remote: '', // url ni dung modal - dng  load ni dung modal sau theo url
            content: '', // ni dung modal - html c sn
            height: 'auto', // chiu cao
            width: 'auto', // chiu rng,
            ignoreText: '',
            buttons: [], // cc nt chc nng
            hide: null,   // callback sau khi n modal
            close: null,   // callback trc khi n modal 
            loaded: null,   // callback sau khi load xong ni dung = remote url.
            backdrop: "static",
            confirm: null
        }
    });

    //#endregion

    //#region Document Permission

    egov.models.totalNotifications = Backbone.Model.extend({
        defaults: {
            totalNotify: 0,
            total: 0
        }
    });

    egov.models.notification = Backbone.Model.extend({
        defaults: {
            NotificationId: 0,
            NotificationType: 0,
            Title: "",
            Content: "",
            SenderAvatar: "",
            SenderUserName: "",
            SenderFullName: "",
            Date: "",
            DateFormat: "",
            ReceiveDate: "",
            ViewdDate: "",
            IsViewed: false,

            //egov
            DocumentCopyId: 0,

            //mail
            MailId: 0,
            folderId: 0,

            //chat
            ChatId: "",
            chatterJid: "",
            messageId: ""
        }
    });

    egov.models.notificationList = Backbone.Collection.extend({
        model: egov.models.notification
    });

    egov.models.layoutNotify = Backbone.Model.extend({
        defaults: {
            total: 0,
            unreadTotal: 0,
            model: []
        }
    });

    //#endregion

    //#region Gn ra model cho cc view. Mi view ch s dng mt model tng ng.

    // Cy vn bn
    egov.viewModels.tree = new egov.models.TreeList();

    // Danh sch vn bn
    egov.viewModels.documentList = new egov.models.documentList();

    // Danh sch tab
    egov.viewModels.tabList = new egov.models.TabList();

    // Danh sch ngi nhn trn form bn giao
    egov.viewModels.actionUserList = new egov.models.actionUserList();

    //#endregion

})
(this.egov = this.egov || {});

// Ly keycode
(function (window) {
    var exports = {};
    var codes = exports.codes = {
        'backspace': 8,
        'tab': 9,
        'enter': 13,
        'shift': 16,
        'ctrl': 17,
        'alt': 18,
        'pause/break': 19,
        'caps lock': 20,
        'esc': 27,
        'space': 32,
        'page up': 33,
        'page down': 34,
        'end': 35,
        'home': 36,
        'left': 37,
        'up': 38,
        'right': 39,
        'down': 40,
        'insert': 45,
        'delete': 46,
        'command': 91,
        'left command': 91,
        'right command': 93,
        'numpad *': 106,
        'numpad +': 107,
        'numpad -': 109,
        'numpad .': 110,
        'numpad /': 111,
        'num lock': 144,
        'scroll lock': 145,
        'my computer': 182,
        'my calculator': 183,
        ';': 186,
        '=': 187,
        ',': 188,
        '-': 189,
        '.': 190,
        '/': 191,
        '`': 192,
        '[': 219,
        '\\': 220,
        ']': 221,
        "'": 222
    }

    var aliases = exports.aliases = {
        'windows': 91,
        '': 16,
        '': 18,
        '': 17,
        '': 91,
        'ctl': 17,
        'control': 17,
        'option': 18,
        'pause': 19,
        'break': 19,
        'caps': 20,
        'return': 13,
        'escape': 27,
        'spc': 32,
        'pgup': 33,
        'pgdn': 34,
        'ins': 45,
        'del': 46,
        'cmd': 91
    }

    // k t vit thng
    for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32

    // s
    for (var i = 48; i < 58; i++) codes[i - 48] = i

    // phm chc nng
    for (i = 1; i < 13; i++) codes['f' + i] = i + 111

    // phm trn bn phm s
    for (i = 0; i < 10; i++) codes['numpad ' + i] = i + 96

    var names = exports.names = {} 

    
    for (i in codes) names[codes[i]] = i

    
    for (var alias in aliases) {
        codes[alias] = aliases[alias]
    }

    window.KeyCode = exports.codes;
    window.KeyCode.names = exports.names;

    /*
     * s dng
     * KeyCode.a = 65
     * tm kim
     * KeyCode.names[65] = 'a'
     */

})(window);



(function (egov, $) {
    /**
    * PubSub nh l mt h thng EventEmitter.
    * Cc Widget ng k cc s kin publish v s kin c s dng chung cho tt c cc subscriber khc.
    * 
    * Notes: s dng egov.events.js  qun l tn cc event c ng k.
    */
    egov.pubsub = (function () {
        var queue = [],
            that = {};

        that.publish = function (eventName, data, position) {
            /// <summary>
            /// Thc thi cc hm callback c lin kt vi eventName
            /// </summary>
            /// <param name="eventName">Tn event cn thc thi</param>
            /// <param name="data">D liu truyn cho hm callback</param>
            var context, intervalId, idx = 0;
            var events = queue[eventName];
            if (!events) return;

            intervalId = setInterval(function () {
                if (events[idx]) {
                    try {
                        context = events[idx].context || this;
                        events[idx].callback.call(context, data, position);
                    } catch (e) {
                        // log the message for developers
                        console.log('C li xy ra khi thc thi mt trong nhng hm callback cho s kin "' + eventName + '"');
                        console.log('Li  l: "' + e + '"');
                    }

                    idx += 1;
                } else {
                    clearInterval(intervalId);
                }
            }, 0);
        };

        that.subscribe = function (eventName, callback, context) {
            /// <summary>
            /// ng k mt s kin. C S kin ng k tip theo s lun c thm vo (ch khng overwrite).
            ///  hy b ng k mt s kin, s dng hm unsubscribe.
            /// </summary>
            /// <param name="eventName">Tn s kin ng k, nn s dng du .  phn bit cc event</param>
            /// <param name="callback">Hm thc thi.</param>
            /// <param name="context">Context  thc thi hm callback</param>
            if (!queue[eventName]) {
                queue[eventName] = [];
            }

            queue[eventName].push({
                callback: callback,
                context: context
            });
        };

        that.unsubscribe = function (eventName, callback, context) {
            /// <summary>
            /// Hy b ng k s kin.
            /// </summary>
            /// <param name="eventName">Tn s kin</param>
            /// <param name="callback">Hm callback sau khi hy b. S dng  chc chn rng s kin  c hy b.</param>
            /// <param name="context">Context thc thi hm callback.</param>
            if (queue[eventName]) {
                queue[eventName].pop({
                    callback: callback,
                    context: context
                });
            }
        };

        return that;
    }());

}(this.egov = this.egov || {}, jQuery));

(function (egov) {
    var _readonlyExtensions = ['pdf', 'png', 'gif', 'jpg', 'jpeg', 'bmp'];
    var _signRegex = /(.doc|.docx|.pdf|.xls|.xlsx)$/i;

    var FileExtension = {
        getFileName: function (fileName) {
            var _dotIndex = fileName.lastIndexOf(".");
            if (_dotIndex === -1) return fileName;

            return fileName.substring(0, _dotIndex);
        },

        getExtension: function (fileName) {
            var _dotIndex = fileName.lastIndexOf(".");
            if (_dotIndex === -1) return "";

            var ext = fileName.substring(_dotIndex + 1, fileName.length);
            return ext.toLowerCase();
        },

        getExtensionWithDot: function (fileName) {
            var ext = this.getExtension(fileName);
            return ext === "" ? "" : ("." + ext);
        },

        isPdf: function (fileName) {
            var ext = this.getExtensionWithDot(fileName);
            return ext === ".pdf";
        },

        isMsOfficeFile: function (fileName) {
            var ext = this.getExtensionWithDot(fileName);
            return ext === ".doc" || ext === ".docx";
        },

        isReadonly: function (fileName) {
            var extension = this.getExtension(fileName);
            return _readonlyExtensions.indexOf(extension) >= 0;
        },

        isForSign: function (fileName) {
            var ext = this.getExtensionWithDot(fileName);
            return _signRegex.test(ext);
        },

        getSizeText: function (filesize) {
            var oneKiloByte = 1024;
            var oneMegaByte = 1048576;
            var oneGigaByte = 1073741824;

            if (filesize >= oneGigaByte) {
                return Math.round(filesize / oneGigaByte) + " GB";
            }
            if (filesize >= oneMegaByte) {
                return Math.round(filesize / oneMegaByte) + " MB";
            }
            if (filesize >= oneKiloByte) {
                return Math.round(filesize / oneKiloByte) + " KB";
            }

            return filesize + " bytes";
        },

        downloadUri: function (uri, name) {
            var link = document.createElement("a");
            link.download = name;
            link.href = uri;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            delete link;
        }
    };

    egov.fileExtension = FileExtension;
})(window.egov || {});